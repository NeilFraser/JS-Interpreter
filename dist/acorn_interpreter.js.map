{"version":3,"sources":["webpack:///dist/acorn_interpreter.js","webpack:///webpack/bootstrap 8ee9dc209b294c66f8d6","webpack:///./lib/acorn_interpreter.ts","webpack:///./lib/acorn.js","webpack:///(webpack)/buildin/module.js","webpack:///./lib/interpreter.ts","webpack:///(webpack)/buildin/global.js"],"names":["Interpreter","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","require","acorn","apply","__WEBPACK_AMD_DEFINE_FACTORY__","_typeof","Symbol","iterator","obj","constructor","root","mod","setOptions","opts","options","opt","defaultOptions","sourceFile","raise","pos","message","loc","getLineInfo","input","line","column","err","SyntaxError","raisedAt","tokPos","makePredicate","words","compareTo","arr","length","f","JSON","stringify","split","cats","out","j","push","sort","a","b","cat","Function","line_loc_t","this","tokCurLine","tokLineStart","initTokenState","tokRegexpAllowed","skipSpace","finishToken","type","val","tokEnd","locations","tokEndLoc","tokType","tokVal","beforeExpr","skipBlockComment","startLoc","onComment","start","end","indexOf","lineBreak","lastIndex","match","exec","index","slice","skipLineComment","ch","charCodeAt","inputLen","next","nonASCIIwhitespace","test","String","fromCharCode","readToken_dot","readNumber","_dot","readToken_slash","readRegexp","finishOp","_assign","_slash","readToken_mult_modulo","_multiplyModulo","readToken_pipe_amp","code","_logicalOR","_logicalAND","_bitwiseOR","_bitwiseAND","readToken_caret","_bitwiseXOR","readToken_plus_min","newline","lastEnd","readToken","_incDec","_plusMin","readToken_lt_gt","size","_bitShift","_relational","readToken_eq_excl","_equality","_eq","_prefix","getTokenFromCode","_parenL","_parenR","_semi","_comma","_bracketL","_bracketR","_braceL","_braceR","_colon","_question","readHexNumber","readString","forceRegexp","tokStart","tokStartLoc","_eof","isIdentifierStart","readWord","tok","nonASCIIidentifierStart","str","escaped","inClass","content","charAt","mods","readWord1","_regexp","RegExp","readInt","radix","len","total","e","Infinity","_num","startsWithDot","isFloat","octal","parseFloat","strict","parseInt","quote","_string","readHexChar","containsEsc","word","first","isIdentifierChar","esc","escStr","_name","isKeyword","keywordTypes","forbidReserved","ecmaVersion","isReservedWord3","isReservedWord5","isStrictReservedWord","lastStart","lastEndLoc","setStrict","strct","lastIndexOf","node_t","node_loc_t","source","startNode","node","directSourceFile","ranges","range","startNodeFrom","other","finishNode","isUseStrict","stmt","expression","value","eat","canInsertSemicolon","strictSemicolons","semicolon","unexpected","expect","checkLVal","expr","isStrictBadIdWord","parseTopLevel","program","inFunction","labels","body","parseStatement","starttype","_break","_continue","isBreak","label","parseIdent","lab","kind","keyword","_debugger","_do","loopLabel","pop","_while","parseParenExpression","_for","parseFor","_var","init","parseVar","declarations","_in","parseForIn","parseExpression","_function","parseFunction","_if","consequent","alternate","_else","_return","argument","_switch","discriminant","cases","switchLabel","cur","sawDefault","_case","_default","isCase","_throw","_try","block","parseBlock","handler","_catch","clause","param","guard","guardedHandlers","empty","finalizer","_finally","_with","maybeName","isLoop","allowStrict","oldStrict","update","left","right","noIn","decl","id","noComma","parseMaybeAssign","expressions","parseMaybeConditional","isAssign","operator","parseExprOps","parseExprOp","parseMaybeUnary","minPrec","prec","binop","op","prefix","isUpdate","parseExprSubscripts","postfix","parseSubscripts","parseExprAtom","base","noCalls","computed","callee","arguments","parseExprList","_this","raw","_null","_true","_false","atomValue","tokStartLoc1","tokStart1","elements","parseObj","_new","parseNew","sawGetSet","properties","allowTrailingCommas","prop","key","parsePropertyName","isGetSet","conflict","isStatement","params","oldInFunc","oldLabels","close","allowTrailingComma","allowEmpty","elts","liberal","version","parse","inpt","offset","tokenize","getToken","t","endLoc","jumpTo","reAllowed","break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","while","with","null","true","false","new","in","instanceof","typeof","void","delete","tokTypes","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","slash","eq","eof","num","regexp","string","kw","nonASCIIidentifierStartChars","nonASCIIidentifier","webpackPolyfill","deprecate","paths","children","global","opt_initFunc","PARSE_OPTIONS","ast","initFunc_","paused_","polyfills_","functionCounter_","stepFunctions_","create","stepMatch","props","getOwnPropertyNames","methodName","bind","createScope","join","stripLocations_","state","MyState","done","stateStack","run","nodeConstructor","OBJECT","OBJECT_PROTO","FUNCTION","FUNCTION_PROTO","ARRAY","ARRAY_PROTO","REGEXP","REGEXP_PROTO","NaN","appendCode","Error","populateScope_","scope","step","stack","nextState","STEP_ERROR","initGlobalScope","setProperty","READONLY_DESCRIPTOR","MyObject","initFunction","initObject","proto","initArray","initString","initBoolean","initNumber","initDate","initRegExp","initError","initMath","initJSON","thisInterpreter","func","createNativeFunction","x","EvalError","eval","isNaN","isFinite","strFunctions","escape","unescape","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","wrapper","nativeFunc","throwException","URI_ERROR","NONENUMERABLE_DESCRIPTOR","identifierRegexp","var_args","calledWithNew","newFunc","createObjectProto","args","SYNTAX_ERROR","parentScope","boxThis","isObject","getScope","box","getPrototype","data","thisArg","func_","funcThis_","arguments_","pseudoToNative","TYPE_ERROR","doneExec_","setNativeFunctionPrototype","toString","valueOf","throwIfNullUndefined","nativeToPseudo","keys","descriptor","preventExtensions","ReferenceError","getOwnPropertyDescriptor","setter","set","writable","pseudoDescriptor","Boolean","propertyIsEnumerable","newArray","legalArrayLength","RANGE_ERROR","class","Array","shift","unshift","reverse","howmany","list","splice","opt_begin","opt_end","opt_separator","iLength","getProperty","hasProperty","element","isa","jLength","searchElement","opt_fromIndex","STRING","functions","compareString","locales","localeCompare","separator","limit","jsList","search","substr","newSubstr","replace","BOOLEAN","Number","NUMBER","numConsts","READONLY_NONENUMERABLE_DESCRIPTOR","fractionDigits","toExponential","ERROR","digits","toFixed","precision","toPrecision","toLocaleString","Date","concat","DATE","now","UTC","pattern","flags","rgx","populateRegExp","result","opt_message","newError","createObject","createErrorSubclass","EVAL_ERROR","REFERENCE_ERROR","myMath","mathConsts","Math","numFunctions","myJSON","text","nativeObj","child","childObj","legalArrayIndex","pseudoRegexp","nativeRegexp","ignoreCase","multiline","createFunction","opt_constructor","illegalConstructor","createAsyncFunction","asyncFunc","interpreter","map","pseudoObj","isArray","opt_cycles","cycles","pseudo","native","myObj","isGetter","TypeError","opt_descriptor","max","defObj","firstNode","createSpecialScope","opt_scope","getValueFromScope","prevNode","setValueToScope","VARIABLE_DESCRIPTOR","nodeClass","isConstructor","getValue","ref","SCOPE_REFERENCE","setValue","errorClass","error","executeException","throwValue","realError","errorTable","RangeError","URIError","createGetter_","funcThis","doneCallee_","doneArgs_","createSetter_","stepArrayExpression","n_","array_","stepAssignmentExpression","doneLeft_","components","doneRight_","leftReference_","doneGetter_","leftValue_","leftValue","doneSetter_","rightValue","stepBinaryExpression","stepBlockStatement","stepBreakStatement","isSwitch","stepCallExpression","funcNode","paramName","paramValue","argsList","evalNode","callback","argsWithCallback","stepCatchClause","done_","stepConditionalExpression","mode","mode_","stepContinueStatement","stepDebuggerStatement","stepDoWhileStatement","test_","stepEmptyStatement","stepEvalProgram_","stepExpressionStatement","stepForInStatement","doneInit_","doneObject_","variable_","object_","visited_","name_","props_","doneVariable_","stepForStatement","stepFunctionDeclaration","stepFunctionExpression","stepIdentifier","stepIfStatement","stepLabeledStatement","stepLiteral","stepLogicalExpression","stepMemberExpression","propName","doneProperty_","stepNewExpression","stepObjectExpression","properties_","kinds","stepProgram","stepReturnStatement","stepSequenceExpression","stepSwitchStatement","switchValue_","index_","switchCase","matched_","defaultCase_","tested_","stepThisExpression","stepThrowStatement","stepTryStatement","doneBlock_","doneHandler_","doneFinalizer_","stepUnaryExpression","stepUpdateExpression","leftSide_","changeValue","returnValue","stepVariableDeclaration","declarationNode","init_","stepWithStatement","doneBody_","stepWhileStatement","toStringCycles_","strs","self","g","window"],"mappings":"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","file":"./dist/acorn_interpreter.js","sourcesContent":["var Interpreter =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, acorn, Interpreter) {\r\n    \"use strict\";\r\n    /*!\r\n     * @license\r\n     * JavaScript Interpreter bundled with acorn v0.4.1\r\n     *\r\n     * Copyright 2013-2017 Google Inc. and Jun Kato\r\n     *\r\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n     * you may not use this file except in compliance with the License.\r\n     * You may obtain a copy of the License at\r\n     *\r\n     *   http://www.apache.org/licenses/LICENSE-2.0\r\n     *\r\n     * Unless required by applicable law or agreed to in writing, software\r\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n     * See the License for the specific language governing permissions and\r\n     * limitations under the License.\r\n     */\r\n    /**\r\n     * @fileoverview Interpreting JavaScript in JavaScript (concatenated with acorn)\r\n     * @author fraser@google.com (Neil Fraser)\r\n     * @author i@junkato.jp (Jun Kato)\r\n     */\r\n    Interpreter.acorn = acorn;\r\n    return Interpreter;\r\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke and released under an MIT\n// license. The Unicode regexps (for identifiers and whitespace) were\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/marijnh/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/marijnh/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\n(function (root, mod) {\n  if (( false ? \"undefined\" : _typeof(exports)) == \"object\" && ( false ? \"undefined\" : _typeof(module)) == \"object\") return mod(exports); // CommonJS\n  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD\n  mod(root.acorn || (root.acorn = {})); // Plain browser env\n})(undefined, function (exports) {\n  \"use strict\";\n\n  exports.version = \"0.4.1\";\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api], with the caveat that the SpiderMonkey-specific syntax\n  // (`let`, `yield`, inline XML, etc) is not recognized.\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function (inpt, opts) {\n    input = String(inpt);inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n    return parseTopLevel(options.program);\n  };\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = exports.defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\n    // be either 3 or 5. This\n    // influences support for strict mode, the set of reserved words, and\n    // support for getters and setter.\n    ecmaVersion: 5,\n    // Turn on `strictSemicolons` to prevent the parser from doing\n    // automatic semicolon insertion.\n    strictSemicolons: false,\n    // When `allowTrailingCommas` is false, the parser will not allow\n    // trailing commas in array and object literals.\n    allowTrailingCommas: true,\n    // By default, reserved words are not enforced. Enable\n    // `forbidReserved` to enforce them.\n    forbidReserved: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `location` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `location` is on or off.\n    directSourceFile: null\n  };\n\n  function setOptions(opts) {\n    options = opts || {};\n    for (var opt in defaultOptions) {\n      if (!Object.prototype.hasOwnProperty.call(options, opt)) options[opt] = defaultOptions[opt];\n    }sourceFile = options.sourceFile || null;\n  }\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  var getLineInfo = exports.getLineInfo = function (input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreak.lastIndex = cur;\n      var match = lineBreak.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else break;\n    }\n    return { line: line, column: offset - cur };\n  };\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenize` export provides an interface to the tokenizer.\n  // Because the tokenizer is optimized for being efficiently used by\n  // the Acorn parser itself, this interface is somewhat crude and not\n  // very modular. Performing another parse or call to `tokenize` will\n  // reset the internal state, and invalidate existing tokenizers.\n\n  exports.tokenize = function (inpt, opts) {\n    input = String(inpt);inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n\n    var t = {};\n    function getToken(forceRegexp) {\n      readToken(forceRegexp);\n      t.start = tokStart;t.end = tokEnd;\n      t.startLoc = tokStartLoc;t.endLoc = tokEndLoc;\n      t.type = tokType;t.value = tokVal;\n      return t;\n    }\n    getToken.jumpTo = function (pos, reAllowed) {\n      tokPos = pos;\n      if (options.locations) {\n        tokCurLine = 1;\n        tokLineStart = lineBreak.lastIndex = 0;\n        var match;\n        while ((match = lineBreak.exec(input)) && match.index < pos) {\n          ++tokCurLine;\n          tokLineStart = match.index + match[0].length;\n        }\n      }\n      tokRegexpAllowed = reAllowed;\n      skipSpace();\n    };\n    return getToken;\n  };\n\n  // State is kept in (closure-)global variables. We already saw the\n  // `options`, `input`, and `inputLen` variables above.\n\n  // The current position of the tokenizer in the input.\n\n  var tokPos;\n\n  // The start and end offsets of the current token.\n\n  var tokStart, tokEnd;\n\n  // When `options.locations` is true, these hold objects\n  // containing the tokens start and end line/column pairs.\n\n  var tokStartLoc, tokEndLoc;\n\n  // The type and value of the current token. Token types are objects,\n  // named by variables against which they can be compared, and\n  // holding properties that describe them (indicating, for example,\n  // the precedence of an infix operator, and the original name of a\n  // keyword token). The kind of value that's held in `tokVal` depends\n  // on the type of the token. For literals, it is the literal value,\n  // for operators, the operator name, and so on.\n\n  var tokType, tokVal;\n\n  // Interal state for the tokenizer. To distinguish between division\n  // operators and regular expressions, it remembers whether the last\n  // token was one that is allowed to be followed by an expression.\n  // (If it is, a slash is probably a regexp, if it isn't it's a\n  // division operator. See the `parseStatement` function for a\n  // caveat.)\n\n  var tokRegexpAllowed;\n\n  // When `options.locations` is true, these are used to keep\n  // track of the current line, and know when a new line has been\n  // entered.\n\n  var tokCurLine, tokLineStart;\n\n  // These store the position of the previous token, which is useful\n  // when finishing a node and assigning its `end` position.\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  // This is the parser's state. `inFunction` is used to reject\n  // `return` statements outside of functions, `labels` to verify that\n  // `break` and `continue` have somewhere to jump to, and `strict`\n  // indicates whether strict mode is on.\n\n  var inFunction, labels, strict;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  function raise(pos, message) {\n    var loc = getLineInfo(input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos;err.loc = loc;err.raisedAt = tokPos;\n    throw err;\n  }\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // These are the general types. The `type` property is only used to\n  // make them recognizeable when debugging.\n\n  var _num = { type: \"num\" },\n      _regexp = { type: \"regexp\" },\n      _string = { type: \"string\" };\n  var _name = { type: \"name\" },\n      _eof = { type: \"eof\" };\n\n  // Keyword tokens. The `keyword` property (also used in keyword-like\n  // operators) indicates that the token originated from an\n  // identifier-like word, which is used when parsing property names.\n  //\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var _break = { keyword: \"break\" },\n      _case = { keyword: \"case\", beforeExpr: true },\n      _catch = { keyword: \"catch\" };\n  var _continue = { keyword: \"continue\" },\n      _debugger = { keyword: \"debugger\" },\n      _default = { keyword: \"default\" };\n  var _do = { keyword: \"do\", isLoop: true },\n      _else = { keyword: \"else\", beforeExpr: true };\n  var _finally = { keyword: \"finally\" },\n      _for = { keyword: \"for\", isLoop: true },\n      _function = { keyword: \"function\" };\n  var _if = { keyword: \"if\" },\n      _return = { keyword: \"return\", beforeExpr: true },\n      _switch = { keyword: \"switch\" };\n  var _throw = { keyword: \"throw\", beforeExpr: true },\n      _try = { keyword: \"try\" },\n      _var = { keyword: \"var\" };\n  var _while = { keyword: \"while\", isLoop: true },\n      _with = { keyword: \"with\" },\n      _new = { keyword: \"new\", beforeExpr: true };\n  var _this = { keyword: \"this\" };\n\n  // The keywords that denote values.\n\n  var _null = { keyword: \"null\", atomValue: null },\n      _true = { keyword: \"true\", atomValue: true };\n  var _false = { keyword: \"false\", atomValue: false };\n\n  // Some keywords are treated as regular operators. `in` sometimes\n  // (when parsing `for`) needs to be tested against specifically, so\n  // we assign a variable name to it for quick comparing.\n\n  var _in = { keyword: \"in\", binop: 7, beforeExpr: true };\n\n  // Map keyword names to token types.\n\n  var keywordTypes = { \"break\": _break, \"case\": _case, \"catch\": _catch,\n    \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n    \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n    \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n    \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n    \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n    \"instanceof\": { keyword: \"instanceof\", binop: 7, beforeExpr: true }, \"this\": _this,\n    \"typeof\": { keyword: \"typeof\", prefix: true, beforeExpr: true },\n    \"void\": { keyword: \"void\", prefix: true, beforeExpr: true },\n    \"delete\": { keyword: \"delete\", prefix: true, beforeExpr: true } };\n\n  // Punctuation token types. Again, the `type` property is purely for debugging.\n\n  var _bracketL = { type: \"[\", beforeExpr: true },\n      _bracketR = { type: \"]\" },\n      _braceL = { type: \"{\", beforeExpr: true };\n  var _braceR = { type: \"}\" },\n      _parenL = { type: \"(\", beforeExpr: true },\n      _parenR = { type: \")\" };\n  var _comma = { type: \",\", beforeExpr: true },\n      _semi = { type: \";\", beforeExpr: true };\n  var _colon = { type: \":\", beforeExpr: true },\n      _dot = { type: \".\" },\n      _question = { type: \"?\", beforeExpr: true };\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator. `isUpdate` specifies that the node produced by\n  // the operator should be of type UpdateExpression rather than\n  // simply UnaryExpression (`++` and `--`).\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  var _slash = { binop: 10, beforeExpr: true },\n      _eq = { isAssign: true, beforeExpr: true };\n  var _assign = { isAssign: true, beforeExpr: true };\n  var _incDec = { postfix: true, prefix: true, isUpdate: true },\n      _prefix = { prefix: true, beforeExpr: true };\n  var _logicalOR = { binop: 1, beforeExpr: true };\n  var _logicalAND = { binop: 2, beforeExpr: true };\n  var _bitwiseOR = { binop: 3, beforeExpr: true };\n  var _bitwiseXOR = { binop: 4, beforeExpr: true };\n  var _bitwiseAND = { binop: 5, beforeExpr: true };\n  var _equality = { binop: 6, beforeExpr: true };\n  var _relational = { binop: 7, beforeExpr: true };\n  var _bitShift = { binop: 8, beforeExpr: true };\n  var _plusMin = { binop: 9, prefix: true, beforeExpr: true };\n  var _multiplyModulo = { binop: 10, beforeExpr: true };\n\n  // Provide access to the token types for external users of the\n  // tokenizer.\n\n  exports.tokTypes = { bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n    parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n    dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n    num: _num, regexp: _regexp, string: _string };\n  for (var kw in keywordTypes) {\n    exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n  } // This is a trick taken from Esprima. It turns out that, on\n  // non-Chrome browsers, to check whether a string is in a set, a\n  // predicate containing a big ugly `switch` statement is faster than\n  // a regular expression, and on Chrome the two are about on par.\n  // This function uses `eval` (non-lexical) to produce such a\n  // predicate from a space-separated string of words.\n  //\n  // It starts by sorting the words by length.\n\n  function makePredicate(words) {\n    words = words.split(\" \");\n    var f = \"\",\n        cats = [];\n    out: for (var i = 0; i < words.length; ++i) {\n      for (var j = 0; j < cats.length; ++j) {\n        if (cats[j][0].length == words[i].length) {\n          cats[j].push(words[i]);\n          continue out;\n        }\n      }cats.push([words[i]]);\n    }\n    function compareTo(arr) {\n      if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n      f += \"switch(str){\";\n      for (var i = 0; i < arr.length; ++i) {\n        f += \"case \" + JSON.stringify(arr[i]) + \":\";\n      }f += \"return true}return false;\";\n    }\n\n    // When there are more than three length categories, an outer\n    // switch first dispatches on the lengths, to save on comparisons.\n\n    if (cats.length > 3) {\n      cats.sort(function (a, b) {\n        return b.length - a.length;\n      });\n      f += \"switch(str.length){\";\n      for (var i = 0; i < cats.length; ++i) {\n        var cat = cats[i];\n        f += \"case \" + cat[0].length + \":\";\n        compareTo(cat);\n      }\n      f += \"}\";\n\n      // Otherwise, simply generate a flat `switch` statement.\n    } else {\n      compareTo(words);\n    }\n    return new Function(\"str\", f);\n  }\n\n  // The ECMAScript 3 reserved word list.\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  // ECMAScript 5 reserved words.\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  // The additional reserved words in strict mode.\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  // The forbidden variable names in strict mode.\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  // And the keywords.\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u0620-\\u0649\\u0672-\\u06D3\\u06E7-\\u06E8\\u06FB-\\u06FC\\u0730-\\u074A\\u0800-\\u0814\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0840-\\u0857\\u08E4-\\u08FE\\u0900-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09D7\\u09DF-\\u09E0\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5F-\\u0B60\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2-\\u0CE3\\u0CE6-\\u0CEF\\u0D02\\u0D03\\u0D46-\\u0D48\\u0D57\\u0D62-\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E34-\\u0E3A\\u0E40-\\u0E45\\u0E50-\\u0E59\\u0EB4-\\u0EB9\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F41-\\u0F47\\u0F71-\\u0F84\\u0F86-\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u170E-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17B2\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1920-\\u192B\\u1930-\\u193B\\u1951-\\u196D\\u19B0-\\u19C0\\u19C8-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A15\\u1A20-\\u1A53\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1B46-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C00-\\u1C22\\u1C40-\\u1C49\\u1C5B-\\u1C7D\\u1CD0-\\u1CD2\\u1D00-\\u1DBE\\u1E01-\\u1F15\\u200C\\u200D\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2D81-\\u2D96\\u2DE0-\\u2DFF\\u3021-\\u3028\\u3099\\u309A\\uA640-\\uA66D\\uA674-\\uA67D\\uA69F\\uA6F0-\\uA6F1\\uA7F8-\\uA800\\uA806\\uA80B\\uA823-\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C4\\uA8D0-\\uA8D9\\uA8F3-\\uA8F7\\uA900-\\uA909\\uA926-\\uA92D\\uA930-\\uA945\\uA980-\\uA983\\uA9B3-\\uA9C0\\uAA00-\\uAA27\\uAA40-\\uAA41\\uAA4C-\\uAA4D\\uAA50-\\uAA59\\uAA7B\\uAAE0-\\uAAE9\\uAAF2-\\uAAF3\\uABC0-\\uABE1\\uABEC\\uABED\\uABF0-\\uABF9\\uFB20-\\uFB28\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  // Whether a single character denotes a newline.\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  // Test whether a given character code starts an identifier.\n\n  var isIdentifierStart = exports.isIdentifierStart = function (code) {\n    if (code < 65) return code === 36;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  // Test whether a given character is part of an identifier.\n\n  var isIdentifierChar = exports.isIdentifierChar = function (code) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  // ## Tokenizer\n\n  // These are used when `options.locations` is on, for the\n  // `tokStartLoc` and `tokEndLoc` properties.\n\n  function line_loc_t() {\n    this.line = tokCurLine;\n    this.column = tokPos - tokLineStart;\n  }\n\n  // Reset the token state. Used at the start of a parse.\n\n  function initTokenState() {\n    tokCurLine = 1;\n    tokPos = tokLineStart = 0;\n    tokRegexpAllowed = true;\n    skipSpace();\n  }\n\n  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and\n  // `tokRegexpAllowed`, and skips the space after the token, so that\n  // the next one's `tokStart` will point at the right position.\n\n  function finishToken(type, val) {\n    tokEnd = tokPos;\n    if (options.locations) tokEndLoc = new line_loc_t();\n    tokType = type;\n    skipSpace();\n    tokVal = val;\n    tokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n    var startLoc = options.onComment && options.locations && new line_loc_t();\n    var start = tokPos,\n        end = input.indexOf(\"*/\", tokPos += 2);\n    if (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n    tokPos = end + 2;\n    if (options.locations) {\n      lineBreak.lastIndex = start;\n      var match;\n      while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n        ++tokCurLine;\n        tokLineStart = match.index + match[0].length;\n      }\n    }\n    if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t());\n  }\n\n  function skipLineComment() {\n    var start = tokPos;\n    var startLoc = options.onComment && options.locations && new line_loc_t();\n    var ch = input.charCodeAt(tokPos += 2);\n    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++tokPos;\n      ch = input.charCodeAt(tokPos);\n    }\n    if (options.onComment) options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t());\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  function skipSpace() {\n    while (tokPos < inputLen) {\n      var ch = input.charCodeAt(tokPos);\n      if (ch === 32) {\n        // ' '\n        ++tokPos;\n      } else if (ch === 13) {\n        ++tokPos;\n        var next = input.charCodeAt(tokPos);\n        if (next === 10) {\n          ++tokPos;\n        }\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch === 10 || ch === 8232 || ch === 8233) {\n        ++tokPos;\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch > 8 && ch < 14) {\n        ++tokPos;\n      } else if (ch === 47) {\n        // '/'\n        var next = input.charCodeAt(tokPos + 1);\n        if (next === 42) {\n          // '*'\n          skipBlockComment();\n        } else if (next === 47) {\n          // '/'\n          skipLineComment();\n        } else break;\n      } else if (ch === 160) {\n        // '\\xa0'\n        ++tokPos;\n      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++tokPos;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  // The `forceRegexp` parameter is used in the one case where the\n  // `tokRegexpAllowed` trick does not work. See `parseStatement`.\n\n  function readToken_dot() {\n    var next = input.charCodeAt(tokPos + 1);\n    if (next >= 48 && next <= 57) return readNumber(true);\n    ++tokPos;\n    return finishToken(_dot);\n  }\n\n  function readToken_slash() {\n    // '/'\n    var next = input.charCodeAt(tokPos + 1);\n    if (tokRegexpAllowed) {\n      ++tokPos;return readRegexp();\n    }\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() {\n    // '%*'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) {\n    // '|&'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() {\n    // '^'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) {\n    // '+-'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) {\n      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {\n        // A `-->` line comment\n        tokPos += 3;\n        skipLineComment();\n        skipSpace();\n        return readToken();\n      }\n      return finishOp(_incDec, 2);\n    }\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) {\n    // '<>'\n    var next = input.charCodeAt(tokPos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n      return finishOp(_bitShift, size);\n    }\n    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      tokPos += 4;\n      skipLineComment();\n      skipSpace();\n      return readToken();\n    }\n    if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n    return finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) {\n    // '=!'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n    return finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit.\n      case 46:\n        // '.'\n        return readToken_dot();\n\n      // Punctuation tokens.\n      case 40:\n        ++tokPos;return finishToken(_parenL);\n      case 41:\n        ++tokPos;return finishToken(_parenR);\n      case 59:\n        ++tokPos;return finishToken(_semi);\n      case 44:\n        ++tokPos;return finishToken(_comma);\n      case 91:\n        ++tokPos;return finishToken(_bracketL);\n      case 93:\n        ++tokPos;return finishToken(_bracketR);\n      case 123:\n        ++tokPos;return finishToken(_braceL);\n      case 125:\n        ++tokPos;return finishToken(_braceR);\n      case 58:\n        ++tokPos;return finishToken(_colon);\n      case 63:\n        ++tokPos;return finishToken(_question);\n\n      // '0x' is a hexadecimal number.\n      case 48:\n        // '0'\n        var next = input.charCodeAt(tokPos + 1);\n        if (next === 120 || next === 88) return readHexNumber();\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:\n        // 1-9\n        return readNumber(false);\n\n      // Quotes produce strings.\n      case 34:case 39:\n        // '\"', \"'\"\n        return readString(code);\n\n      // Operators are parsed inline in tiny state machines. '=' (61) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case 47:\n        // '/'\n        return readToken_slash(code);\n\n      case 37:case 42:\n        // '%*'\n        return readToken_mult_modulo();\n\n      case 124:case 38:\n        // '|&'\n        return readToken_pipe_amp(code);\n\n      case 94:\n        // '^'\n        return readToken_caret();\n\n      case 43:case 45:\n        // '+-'\n        return readToken_plus_min(code);\n\n      case 60:case 62:\n        // '<>'\n        return readToken_lt_gt(code);\n\n      case 61:case 33:\n        // '=!'\n        return readToken_eq_excl(code);\n\n      case 126:\n        // '~'\n        return finishOp(_prefix, 1);\n    }\n\n    return false;\n  }\n\n  function readToken(forceRegexp) {\n    if (!forceRegexp) tokStart = tokPos;else tokPos = tokStart + 1;\n    if (options.locations) tokStartLoc = new line_loc_t();\n    if (forceRegexp) return readRegexp();\n    if (tokPos >= inputLen) return finishToken(_eof);\n\n    var code = input.charCodeAt(tokPos);\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) return readWord();\n\n    var tok = getTokenFromCode(code);\n\n    if (tok === false) {\n      // If we are here, we either found a non-ASCII identifier\n      // character, or something that's entirely disallowed.\n      var ch = String.fromCharCode(code);\n      if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n      raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n    }\n    return tok;\n  }\n\n  function finishOp(type, size) {\n    var str = input.slice(tokPos, tokPos + size);\n    tokPos += size;\n    finishToken(type, str);\n  }\n\n  // Parse a regular expression. Some context-awareness is necessary,\n  // since a '/' inside a '[]' set does not end the expression.\n\n  function readRegexp() {\n    var content = \"\",\n        escaped,\n        inClass,\n        start = tokPos;\n    for (;;) {\n      if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n      var ch = input.charAt(tokPos);\n      if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n      if (!escaped) {\n        if (ch === \"[\") inClass = true;else if (ch === \"]\" && inClass) inClass = false;else if (ch === \"/\" && !inClass) break;\n        escaped = ch === \"\\\\\";\n      } else escaped = false;\n      ++tokPos;\n    }\n    var content = input.slice(start, tokPos);\n    ++tokPos;\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n    var mods = readWord1();\n    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n    return finishToken(_regexp, new RegExp(content, mods));\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  function readInt(radix, len) {\n    var start = tokPos,\n        total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = input.charCodeAt(tokPos),\n          val;\n      if (code >= 97) val = code - 97 + 10; // a\n      else if (code >= 65) val = code - 65 + 10; // A\n        else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n          else val = Infinity;\n      if (val >= radix) break;\n      ++tokPos;\n      total = total * radix + val;\n    }\n    if (tokPos === start || len != null && tokPos - start !== len) return null;\n\n    return total;\n  }\n\n  function readHexNumber() {\n    tokPos += 2; // 0x\n    var val = readInt(16);\n    if (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n    return finishToken(_num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  function readNumber(startsWithDot) {\n    var start = tokPos,\n        isFloat = false,\n        octal = input.charCodeAt(tokPos) === 48;\n    if (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n    if (input.charCodeAt(tokPos) === 46) {\n      ++tokPos;\n      readInt(10);\n      isFloat = true;\n    }\n    var next = input.charCodeAt(tokPos);\n    if (next === 69 || next === 101) {\n      // 'eE'\n      next = input.charCodeAt(++tokPos);\n      if (next === 43 || next === 45) ++tokPos; // '+-'\n      if (readInt(10) === null) raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n    var str = input.slice(start, tokPos),\n        val;\n    if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");else val = parseInt(str, 8);\n    return finishToken(_num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  function readString(quote) {\n    tokPos++;\n    var out = \"\";\n    for (;;) {\n      if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n      var ch = input.charCodeAt(tokPos);\n      if (ch === quote) {\n        ++tokPos;\n        return finishToken(_string, out);\n      }\n      if (ch === 92) {\n        // '\\'\n        ch = input.charCodeAt(++tokPos);\n        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n        if (octal) octal = octal[0];\n        while (octal && parseInt(octal, 8) > 255) {\n          octal = octal.slice(0, -1);\n        }if (octal === \"0\") octal = null;\n        ++tokPos;\n        if (octal) {\n          if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n          out += String.fromCharCode(parseInt(octal, 8));\n          tokPos += octal.length - 1;\n        } else {\n          switch (ch) {\n            case 110:\n              out += \"\\n\";break; // 'n' -> '\\n'\n            case 114:\n              out += \"\\r\";break; // 'r' -> '\\r'\n            case 120:\n              out += String.fromCharCode(readHexChar(2));break; // 'x'\n            case 117:\n              out += String.fromCharCode(readHexChar(4));break; // 'u'\n            case 85:\n              out += String.fromCharCode(readHexChar(8));break; // 'U'\n            case 116:\n              out += \"\\t\";break; // 't' -> '\\t'\n            case 98:\n              out += \"\\b\";break; // 'b' -> '\\b'\n            case 118:\n              out += \"\\x0B\";break; // 'v' -> '\\u000b'\n            case 102:\n              out += \"\\f\";break; // 'f' -> '\\f'\n            case 48:\n              out += \"\\0\";break; // 0 -> '\\0'\n            case 13:\n              if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\\r\\n'\n            case 10:\n              // ' \\n'\n              if (options.locations) {\n                tokLineStart = tokPos;++tokCurLine;\n              }\n              break;\n            default:\n              out += String.fromCharCode(ch);break;\n          }\n        }\n      } else {\n        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n        out += String.fromCharCode(ch); // '\\'\n        ++tokPos;\n      }\n    }\n  }\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  function readHexChar(len) {\n    var n = readInt(16, len);\n    if (n === null) raise(tokStart, \"Bad character escape sequence\");\n    return n;\n  }\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n  var containsEsc;\n\n  // Read an identifier, and return it as a string. Sets `containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Only builds up the word character-by-character when it actually\n  // containeds an escape, as a micro-optimization.\n\n  function readWord1() {\n    containsEsc = false;\n    var word,\n        first = true,\n        start = tokPos;\n    for (;;) {\n      var ch = input.charCodeAt(tokPos);\n      if (isIdentifierChar(ch)) {\n        if (containsEsc) word += input.charAt(tokPos);\n        ++tokPos;\n      } else if (ch === 92) {\n        // \"\\\"\n        if (!containsEsc) word = input.slice(start, tokPos);\n        containsEsc = true;\n        if (input.charCodeAt(++tokPos) != 117) // \"u\"\n          raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        ++tokPos;\n        var esc = readHexChar(4);\n        var escStr = String.fromCharCode(esc);\n        if (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, \"Invalid Unicode escape\");\n        word += escStr;\n      } else {\n        break;\n      }\n      first = false;\n    }\n    return containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  function readWord() {\n    var word = readWord1();\n    var type = _name;\n    if (!containsEsc) {\n      if (isKeyword(word)) type = keywordTypes[word];else if (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) || strict && isStrictReservedWord(word)) raise(tokStart, \"The keyword '\" + word + \"' is reserved\");\n    }\n    return finishToken(type, word);\n  }\n\n  // ## Parser\n\n  // A recursive descent parser operates by defining functions for all\n  // syntactic elements, and recursively calling those, each function\n  // advancing the input stream and returning an AST node. Precedence\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n  // instead of `(!x)[1]` is handled by the fact that the parser\n  // function that parses unary prefix operators is called first, and\n  // in turn calls the function that parses `[]` subscripts — that\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\n  // *that* in the unary operator node.\n  //\n  // Acorn uses an [operator precedence parser][opp] to handle binary\n  // operator precedence, because it is much more compact than using\n  // the technique outlined above, which uses different, nesting\n  // functions to specify precedence, for all of the ten binary\n  // precedence levels that JavaScript defines.\n  //\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n  // ### Parser utilities\n\n  // Continue to the next token.\n\n  function next() {\n    lastStart = tokStart;\n    lastEnd = tokEnd;\n    lastEndLoc = tokEndLoc;\n    readToken();\n  }\n\n  // Enter strict mode. Re-reads the next token to please pedantic\n  // tests (\"use strict\"; 010; -- should fail).\n\n  function setStrict(strct) {\n    strict = strct;\n    tokPos = lastEnd;\n    if (options.locations) {\n      while (tokPos < tokLineStart) {\n        tokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n        --tokCurLine;\n      }\n    }\n    skipSpace();\n    readToken();\n  }\n\n  // Start an AST node, attaching a start offset.\n\n  function node_t() {\n    this.type = null;\n    this.start = tokStart;\n    this.end = null;\n  }\n\n  function node_loc_t() {\n    this.start = tokStartLoc;\n    this.end = null;\n    if (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n    var node = new node_t();\n    if (options.locations) node.loc = new node_loc_t();\n    if (options.directSourceFile) node.sourceFile = options.directSourceFile;\n    if (options.ranges) node.range = [tokStart, 0];\n    return node;\n  }\n\n  // Start a node whose start offset information should be based on\n  // the start of another node. For example, a binary operator node is\n  // only started after its left-hand side has already been parsed.\n\n  function startNodeFrom(other) {\n    var node = new node_t();\n    node.start = other.start;\n    if (options.locations) {\n      node.loc = new node_loc_t();\n      node.loc.start = other.loc.start;\n    }\n    if (options.ranges) node.range = [other.range[0], 0];\n\n    return node;\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNode(node, type) {\n    node.type = type;\n    node.end = lastEnd;\n    if (options.locations) node.loc.end = lastEndLoc;\n    if (options.ranges) node.range[1] = lastEnd;\n    return node;\n  }\n\n  // Test whether a statement node is the string literal `\"use strict\"`.\n\n  function isUseStrict(stmt) {\n    return options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  function eat(type) {\n    if (tokType === type) {\n      next();\n      return true;\n    }\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  function canInsertSemicolon() {\n    return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  function semicolon() {\n    if (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  function expect(type) {\n    if (tokType === type) next();else unexpected();\n  }\n\n  // Raise an unexpected token error.\n\n  function unexpected() {\n    raise(tokStart, \"Unexpected token\");\n  }\n\n  // Verify that a node is an lval — something that can be assigned\n  // to.\n\n  function checkLVal(expr) {\n    if (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\") raise(expr.start, \"Assigning to rvalue\");\n    if (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name)) raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  function parseTopLevel(program) {\n    lastStart = lastEnd = tokPos;\n    if (options.locations) lastEndLoc = new line_loc_t();\n    inFunction = strict = null;\n    labels = [];\n    readToken();\n\n    var node = program || startNode(),\n        first = true;\n    if (!program) node.body = [];\n    while (tokType !== _eof) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && isUseStrict(stmt)) setStrict(true);\n      first = false;\n    }\n    return finishNode(node, \"Program\");\n  }\n\n  var loopLabel = { kind: \"loop\" },\n      switchLabel = { kind: \"switch\" };\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo);`, where looking at the previous token\n  // does not help.\n\n  function parseStatement() {\n    if (tokType === _slash || tokType === _assign && tokVal == \"/=\") readToken(true);\n\n    var starttype = tokType,\n        node = startNode();\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n      case _break:case _continue:\n        next();\n        var isBreak = starttype === _break;\n        if (eat(_semi) || canInsertSemicolon()) node.label = null;else if (tokType !== _name) unexpected();else {\n          node.label = parseIdent();\n          semicolon();\n        }\n\n        // Verify that there is an actual destination to break or\n        // continue to.\n        for (var i = 0; i < labels.length; ++i) {\n          var lab = labels[i];\n          if (node.label == null || lab.name === node.label.name) {\n            if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n            if (node.label && isBreak) break;\n          }\n        }\n        if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n        return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n      case _debugger:\n        next();\n        semicolon();\n        return finishNode(node, \"DebuggerStatement\");\n\n      case _do:\n        next();\n        labels.push(loopLabel);\n        node.body = parseStatement();\n        labels.pop();\n        expect(_while);\n        node.test = parseParenExpression();\n        semicolon();\n        return finishNode(node, \"DoWhileStatement\");\n\n      // Disambiguating between a `for` and a `for`/`in` loop is\n      // non-trivial. Basically, we have to parse the init `var`\n      // statement or expression, disallowing the `in` operator (see\n      // the second parameter to `parseExpression`), and then check\n      // whether the next token is `in`. When there is no init part\n      // (semicolon immediately after the opening parenthesis), it is\n      // a regular `for` loop.\n\n      case _for:\n        next();\n        labels.push(loopLabel);\n        expect(_parenL);\n        if (tokType === _semi) return parseFor(node, null);\n        if (tokType === _var) {\n          var init = startNode();\n          next();\n          parseVar(init, true);\n          finishNode(init, \"VariableDeclaration\");\n          if (init.declarations.length === 1 && eat(_in)) return parseForIn(node, init);\n          return parseFor(node, init);\n        }\n        var init = parseExpression(false, true);\n        if (eat(_in)) {\n          checkLVal(init);return parseForIn(node, init);\n        }\n        return parseFor(node, init);\n\n      case _function:\n        next();\n        return parseFunction(node, true);\n\n      case _if:\n        next();\n        node.test = parseParenExpression();\n        node.consequent = parseStatement();\n        node.alternate = eat(_else) ? parseStatement() : null;\n        return finishNode(node, \"IfStatement\");\n\n      case _return:\n        if (!inFunction) raise(tokStart, \"'return' outside of function\");\n        next();\n\n        // In `return` (and `break`/`continue`), the keywords with\n        // optional arguments, we eagerly look for a semicolon or the\n        // possibility to insert one.\n\n        if (eat(_semi) || canInsertSemicolon()) node.argument = null;else {\n          node.argument = parseExpression();semicolon();\n        }\n        return finishNode(node, \"ReturnStatement\");\n\n      case _switch:\n        next();\n        node.discriminant = parseParenExpression();\n        node.cases = [];\n        expect(_braceL);\n        labels.push(switchLabel);\n\n        // Statements under must be grouped (by label) in SwitchCase\n        // nodes. `cur` is used to keep the node that we are currently\n        // adding statements to.\n\n        for (var cur, sawDefault; tokType != _braceR;) {\n          if (tokType === _case || tokType === _default) {\n            var isCase = tokType === _case;\n            if (cur) finishNode(cur, \"SwitchCase\");\n            node.cases.push(cur = startNode());\n            cur.consequent = [];\n            next();\n            if (isCase) cur.test = parseExpression();else {\n              if (sawDefault) raise(lastStart, \"Multiple default clauses\");sawDefault = true;\n              cur.test = null;\n            }\n            expect(_colon);\n          } else {\n            if (!cur) unexpected();\n            cur.consequent.push(parseStatement());\n          }\n        }\n        if (cur) finishNode(cur, \"SwitchCase\");\n        next(); // Closing brace\n        labels.pop();\n        return finishNode(node, \"SwitchStatement\");\n\n      case _throw:\n        next();\n        if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, \"Illegal newline after throw\");\n        node.argument = parseExpression();\n        semicolon();\n        return finishNode(node, \"ThrowStatement\");\n\n      case _try:\n        next();\n        node.block = parseBlock();\n        node.handler = null;\n        if (tokType === _catch) {\n          var clause = startNode();\n          next();\n          expect(_parenL);\n          clause.param = parseIdent();\n          if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n          expect(_parenR);\n          clause.guard = null;\n          clause.body = parseBlock();\n          node.handler = finishNode(clause, \"CatchClause\");\n        }\n        node.guardedHandlers = empty;\n        node.finalizer = eat(_finally) ? parseBlock() : null;\n        if (!node.handler && !node.finalizer) raise(node.start, \"Missing catch or finally clause\");\n        return finishNode(node, \"TryStatement\");\n\n      case _var:\n        next();\n        parseVar(node);\n        semicolon();\n        return finishNode(node, \"VariableDeclaration\");\n\n      case _while:\n        next();\n        node.test = parseParenExpression();\n        labels.push(loopLabel);\n        node.body = parseStatement();\n        labels.pop();\n        return finishNode(node, \"WhileStatement\");\n\n      case _with:\n        if (strict) raise(tokStart, \"'with' in strict mode\");\n        next();\n        node.object = parseParenExpression();\n        node.body = parseStatement();\n        return finishNode(node, \"WithStatement\");\n\n      case _braceL:\n        return parseBlock();\n\n      case _semi:\n        next();\n        return finishNode(node, \"EmptyStatement\");\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n\n      default:\n        var maybeName = tokVal,\n            expr = parseExpression();\n        if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n          for (var i = 0; i < labels.length; ++i) {\n            if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n          }var kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n          labels.push({ name: maybeName, kind: kind });\n          node.body = parseStatement();\n          labels.pop();\n          node.label = expr;\n          return finishNode(node, \"LabeledStatement\");\n        } else {\n          node.expression = expr;\n          semicolon();\n          return finishNode(node, \"ExpressionStatement\");\n        }\n    }\n  }\n\n  // Used for constructs like `switch` and `if` that insist on\n  // parentheses around their expression.\n\n  function parseParenExpression() {\n    expect(_parenL);\n    var val = parseExpression();\n    expect(_parenR);\n    return val;\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  function parseBlock(allowStrict) {\n    var node = startNode(),\n        first = true,\n        strict = false,\n        oldStrict;\n    node.body = [];\n    expect(_braceL);\n    while (!eat(_braceR)) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && allowStrict && isUseStrict(stmt)) {\n        oldStrict = strict;\n        setStrict(strict = true);\n      }\n      first = false;\n    }\n    if (strict && !oldStrict) setStrict(false);\n    return finishNode(node, \"BlockStatement\");\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  function parseFor(node, init) {\n    node.init = init;\n    expect(_semi);\n    node.test = tokType === _semi ? null : parseExpression();\n    expect(_semi);\n    node.update = tokType === _parenR ? null : parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` loop.\n\n  function parseForIn(node, init) {\n    node.left = init;\n    node.right = parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForInStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  function parseVar(node, noIn) {\n    node.declarations = [];\n    node.kind = \"var\";\n    for (;;) {\n      var decl = startNode();\n      decl.id = parseIdent();\n      if (strict && isStrictBadIdWord(decl.id.name)) raise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n      decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n      node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n      if (!eat(_comma)) break;\n    }\n    return node;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The arguments are used to forbid comma\n  // sequences (in argument lists, array literals, or object literals)\n  // or the `in` operator (in for loops initalization expressions).\n\n  function parseExpression(noComma, noIn) {\n    var expr = parseMaybeAssign(noIn);\n    if (!noComma && tokType === _comma) {\n      var node = startNodeFrom(expr);\n      node.expressions = [expr];\n      while (eat(_comma)) {\n        node.expressions.push(parseMaybeAssign(noIn));\n      }return finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  function parseMaybeAssign(noIn) {\n    var left = parseMaybeConditional(noIn);\n    if (tokType.isAssign) {\n      var node = startNodeFrom(left);\n      node.operator = tokVal;\n      node.left = left;\n      next();\n      node.right = parseMaybeAssign(noIn);\n      checkLVal(left);\n      return finishNode(node, \"AssignmentExpression\");\n    }\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  function parseMaybeConditional(noIn) {\n    var expr = parseExprOps(noIn);\n    if (eat(_question)) {\n      var node = startNodeFrom(expr);\n      node.test = expr;\n      node.consequent = parseExpression(true);\n      expect(_colon);\n      node.alternate = parseExpression(true, noIn);\n      return finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  // Start the precedence parser.\n\n  function parseExprOps(noIn) {\n    return parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  function parseExprOp(left, minPrec, noIn) {\n    var prec = tokType.binop;\n    if (prec != null && (!noIn || tokType !== _in)) {\n      if (prec > minPrec) {\n        var node = startNodeFrom(left);\n        node.left = left;\n        node.operator = tokVal;\n        var op = tokType;\n        next();\n        node.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n        var exprNode = finishNode(node, op === _logicalOR || op === _logicalAND ? \"LogicalExpression\" : \"BinaryExpression\");\n        return parseExprOp(exprNode, minPrec, noIn);\n      }\n    }\n    return left;\n  }\n\n  // Parse unary operators, both prefix and postfix.\n\n  function parseMaybeUnary() {\n    if (tokType.prefix) {\n      var node = startNode(),\n          update = tokType.isUpdate;\n      node.operator = tokVal;\n      node.prefix = true;\n      tokRegexpAllowed = true;\n      next();\n      node.argument = parseMaybeUnary();\n      if (update) checkLVal(node.argument);else if (strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") raise(node.start, \"Deleting local variable in strict mode\");\n      return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n    var expr = parseExprSubscripts();\n    while (tokType.postfix && !canInsertSemicolon()) {\n      var node = startNodeFrom(expr);\n      node.operator = tokVal;\n      node.prefix = false;\n      node.argument = expr;\n      checkLVal(expr);\n      next();\n      expr = finishNode(node, \"UpdateExpression\");\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  function parseExprSubscripts() {\n    return parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n    if (eat(_dot)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseIdent(true);\n      node.computed = false;\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (eat(_bracketL)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseExpression();\n      node.computed = true;\n      expect(_bracketR);\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (!noCalls && eat(_parenL)) {\n      var node = startNodeFrom(base);\n      node.callee = base;\n      node.arguments = parseExprList(_parenR, false);\n      return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n    } else return base;\n  }\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  function parseExprAtom() {\n    switch (tokType) {\n      case _this:\n        var node = startNode();\n        next();\n        return finishNode(node, \"ThisExpression\");\n      case _name:\n        return parseIdent();\n      case _num:case _string:case _regexp:\n        var node = startNode();\n        node.value = tokVal;\n        node.raw = input.slice(tokStart, tokEnd);\n        next();\n        return finishNode(node, \"Literal\");\n\n      case _null:case _true:case _false:\n        var node = startNode();\n        node.value = tokType.atomValue;\n        node.raw = tokType.keyword;\n        next();\n        return finishNode(node, \"Literal\");\n\n      case _parenL:\n        var tokStartLoc1 = tokStartLoc,\n            tokStart1 = tokStart;\n        next();\n        var val = parseExpression();\n        val.start = tokStart1;\n        val.end = tokEnd;\n        if (options.locations) {\n          val.loc.start = tokStartLoc1;\n          val.loc.end = tokEndLoc;\n        }\n        if (options.ranges) val.range = [tokStart1, tokEnd];\n        expect(_parenR);\n        return val;\n\n      case _bracketL:\n        var node = startNode();\n        next();\n        node.elements = parseExprList(_bracketR, true, true);\n        return finishNode(node, \"ArrayExpression\");\n\n      case _braceL:\n        return parseObj();\n\n      case _function:\n        var node = startNode();\n        next();\n        return parseFunction(node, false);\n\n      case _new:\n        return parseNew();\n\n      default:\n        unexpected();\n    }\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument\n  // to be a `[]` or dot subscript expression, but not a call — at\n  // least, not without wrapping it in parentheses. Thus, it uses the\n\n  function parseNew() {\n    var node = startNode();\n    next();\n    node.callee = parseSubscripts(parseExprAtom(), true);\n    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);else node.arguments = empty;\n    return finishNode(node, \"NewExpression\");\n  }\n\n  // Parse an object literal.\n\n  function parseObj() {\n    var node = startNode(),\n        first = true,\n        sawGetSet = false;\n    node.properties = [];\n    next();\n    while (!eat(_braceR)) {\n      if (!first) {\n        expect(_comma);\n        if (options.allowTrailingCommas && eat(_braceR)) break;\n      } else first = false;\n\n      var prop = { key: parsePropertyName() },\n          isGetSet = false,\n          kind;\n      if (eat(_colon)) {\n        prop.value = parseExpression(true);\n        kind = prop.kind = \"init\";\n      } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n        isGetSet = sawGetSet = true;\n        kind = prop.kind = prop.key.name;\n        prop.key = parsePropertyName();\n        if (tokType !== _parenL) unexpected();\n        prop.value = parseFunction(startNode(), false);\n      } else unexpected();\n\n      // getters and setters are not allowed to clash — either with\n      // each other or with an init property — and in strict mode,\n      // init properties are also not allowed to be repeated.\n\n      if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var other = node.properties[i];\n          if (other.key.name === prop.key.name) {\n            var conflict = kind == other.kind || isGetSet && other.kind === \"init\" || kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n            if (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n            if (conflict) raise(prop.key.start, \"Redefinition of property\");\n          }\n        }\n      }\n      node.properties.push(prop);\n    }\n    return finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n    if (tokType === _num || tokType === _string) return parseExprAtom();\n    return parseIdent(true);\n  }\n\n  // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  function parseFunction(node, isStatement) {\n    if (tokType === _name) node.id = parseIdent();else if (isStatement) unexpected();else node.id = null;\n    node.params = [];\n    var first = true;\n    expect(_parenL);\n    while (!eat(_parenR)) {\n      if (!first) expect(_comma);else first = false;\n      node.params.push(parseIdent());\n    }\n\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldInFunc = inFunction,\n        oldLabels = labels;\n    inFunction = true;labels = [];\n    node.body = parseBlock(true);\n    inFunction = oldInFunc;labels = oldLabels;\n\n    // If this is a strict mode function, verify that argument names\n    // are not repeated, and it does not try to bind the words `eval`\n    // or `arguments`.\n    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n      for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n        var id = i < 0 ? node.id : node.params[i];\n        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name)) raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n        if (i >= 0) for (var j = 0; j < i; ++j) {\n          if (id.name === node.params[j].name) raise(id.start, \"Argument name clash in strict mode\");\n        }\n      }\n    }\n\n    return finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n    var elts = [],\n        first = true;\n    while (!eat(close)) {\n      if (!first) {\n        expect(_comma);\n        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n      } else first = false;\n\n      if (allowEmpty && tokType === _comma) elts.push(null);else elts.push(parseExpression(true));\n    }\n    return elts;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  function parseIdent(liberal) {\n    var node = startNode();\n    node.name = tokType === _name ? tokVal : liberal && !options.forbidReserved && tokType.keyword || unexpected();\n    tokRegexpAllowed = false;\n    next();\n    return finishNode(node, \"Identifier\");\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference path=\"./_estree.d.ts\" />\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\r\n    \"use strict\";\r\n    /**\r\n     * @license\r\n     * JavaScript Interpreter\r\n     *\r\n     * Copyright 2013-2017 Google Inc. and Jun Kato\r\n     *\r\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n     * you may not use this file except in compliance with the License.\r\n     * You may obtain a copy of the License at\r\n     *\r\n     *   http://www.apache.org/licenses/LICENSE-2.0\r\n     *\r\n     * Unless required by applicable law or agreed to in writing, software\r\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n     * See the License for the specific language governing permissions and\r\n     * limitations under the License.\r\n     */\r\n    /**\r\n     * @fileoverview Interpreting JavaScript in JavaScript.\r\n     * @author fraser@google.com (Neil Fraser)\r\n     * @author i@junkato.jp (Jun Kato)\r\n     */\r\n    /**\r\n     * Create a new interpreter.\r\n     * @param {string|!Object} code Raw JavaScript text or AST.\r\n     * @param {Function=} opt_initFunc Optional initialization function.  Used to\r\n     *     define APIs.  When called it is passed the interpreter object and the\r\n     *     global scope object.\r\n     * @constructor\r\n     */\r\n    var Interpreter = (function () {\r\n        function Interpreter(code, opt_initFunc) {\r\n            if (typeof code === 'string') {\r\n                code = Interpreter.acorn.parse(code, Interpreter.PARSE_OPTIONS);\r\n            }\r\n            this.ast = code;\r\n            this.initFunc_ = opt_initFunc;\r\n            this.paused_ = false;\r\n            this.polyfills_ = [];\r\n            // Unique identifier for native functions.  Used in serialization.\r\n            this.functionCounter_ = 0;\r\n            // Map node types to our step function names; a property lookup is faster\r\n            // than string concatenation with \"step\" prefix.\r\n            this.stepFunctions_ = Object.create(null);\r\n            var stepMatch = /^step([A-Z]\\w*)$/;\r\n            var m;\r\n            var props = Object.getOwnPropertyNames(Interpreter.prototype);\r\n            for (var i = 0; i < props.length; i++) {\r\n                var methodName = props[i];\r\n                if ((typeof Interpreter.prototype[methodName] === 'function') &&\r\n                    (m = methodName.match(stepMatch))) {\r\n                    this.stepFunctions_[m[1]] = Interpreter.prototype[methodName].bind(this);\r\n                }\r\n            }\r\n            // Create and initialize the global scope.\r\n            this.global = this.createScope(this.ast, null);\r\n            // Run the polyfills.\r\n            this.ast = Interpreter.acorn.parse(this.polyfills_.join('\\n'), Interpreter.PARSE_OPTIONS);\r\n            this.polyfills_ = undefined; // Allow polyfill strings to garbage collect.\r\n            this.stripLocations_(this.ast, undefined, undefined);\r\n            var state = new Interpreter.MyState(this.ast, this.global);\r\n            state.done = false;\r\n            this.stateStack = [state];\r\n            this.run();\r\n            this.value = undefined;\r\n            // Point at the main program.\r\n            this.ast = code;\r\n            var state = new Interpreter.MyState(this.ast, this.global);\r\n            state.done = false;\r\n            this.stateStack.length = 0;\r\n            this.stateStack[0] = state;\r\n            // Get a handle on Acorn's node_t object.  It's tricky to access.\r\n            this.nodeConstructor = state.node.constructor;\r\n            // Preserve publicly properties from being pruned/renamed by JS compilers.\r\n            // Add others as needed.\r\n            this['stateStack'] = this.stateStack;\r\n            this['OBJECT'] = this.OBJECT;\r\n            this['OBJECT_PROTO'] = this.OBJECT_PROTO;\r\n            this['FUNCTION'] = this.FUNCTION;\r\n            this['FUNCTION_PROTO'] = this.FUNCTION_PROTO;\r\n            this['ARRAY'] = this.ARRAY;\r\n            this['ARRAY_PROTO'] = this.ARRAY_PROTO;\r\n            this['REGEXP'] = this.REGEXP;\r\n            this['REGEXP_PROTO'] = this.REGEXP_PROTO;\r\n            // The following properties are obsolete.  Do not use.\r\n            this['UNDEFINED'] = undefined;\r\n            this['NULL'] = null;\r\n            this['NAN'] = NaN;\r\n            this['TRUE'] = true;\r\n            this['FALSE'] = false;\r\n            this['STRING_EMPTY'] = '';\r\n            this['NUMBER_ZERO'] = 0;\r\n            this['NUMBER_ONE'] = 1;\r\n        }\r\n        ;\r\n        /**\r\n         * Add more code to the interpreter.\r\n         * @param {string|!Object} code Raw JavaScript text or AST.\r\n         */\r\n        Interpreter.prototype.appendCode = function (code) {\r\n            var state = this.stateStack[0];\r\n            if (!state || state.node['type'] !== 'Program') {\r\n                throw Error('Expecting original AST to start with a Program node.');\r\n            }\r\n            if (typeof code === 'string') {\r\n                code = Interpreter.acorn.parse(code, Interpreter.PARSE_OPTIONS);\r\n            }\r\n            if (!code || code['type'] !== 'Program') {\r\n                throw Error('Expecting new AST to start with a Program node.');\r\n            }\r\n            this.populateScope_(code, state.scope);\r\n            // Append the new program to the old one.\r\n            for (var i = 0, node; (node = code['body'][i]); i++) {\r\n                state.node['body'].push(node);\r\n            }\r\n            state.done = false;\r\n        };\r\n        ;\r\n        /**\r\n         * Execute one step of the interpreter.\r\n         * @return {boolean} True if a step was executed, false if no more instructions.\r\n         */\r\n        Interpreter.prototype.step = function () {\r\n            var stack = this.stateStack;\r\n            var state = stack[stack.length - 1];\r\n            if (!state) {\r\n                return false;\r\n            }\r\n            var node = state.node, type = node['type'];\r\n            if (type === 'Program' && state.done) {\r\n                return false;\r\n            }\r\n            else if (this.paused_) {\r\n                return true;\r\n            }\r\n            try {\r\n                var nextState = this.stepFunctions_[type](stack, state, node);\r\n            }\r\n            catch (e) {\r\n                // Eat any step errors.  They have been thrown on the stack.\r\n                if (e !== Interpreter.STEP_ERROR) {\r\n                    // Uh oh.  This is a real error in the JS-Interpreter.  Rethrow.\r\n                    throw e;\r\n                }\r\n            }\r\n            if (nextState) {\r\n                stack.push(nextState);\r\n            }\r\n            if (!node['end']) {\r\n                // This is polyfill code.  Keep executing until we arrive at user code.\r\n                return this.step();\r\n            }\r\n            return true;\r\n        };\r\n        ;\r\n        /**\r\n         * Execute the interpreter to program completion.  Vulnerable to infinite loops.\r\n         * @return {boolean} True if a execution is asynchronously blocked,\r\n         *     false if no more instructions.\r\n         */\r\n        Interpreter.prototype.run = function () {\r\n            while (!this.paused_ && this.step()) { }\r\n            return this.paused_;\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the global scope with buitin properties and functions.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initGlobalScope = function (scope) {\r\n            // Initialize uneditable global properties.\r\n            this.setProperty(scope, 'NaN', NaN, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'Infinity', Infinity, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'undefined', undefined, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'window', scope, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'this', scope, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'self', scope); // Editable.\r\n            // Create the objects which will become Object.prototype and\r\n            // Function.prototype, which are needed to bootstrap everything else.\r\n            this.OBJECT_PROTO = new Interpreter.MyObject(null);\r\n            this.FUNCTION_PROTO = new Interpreter.MyObject(this.OBJECT_PROTO);\r\n            // Initialize global objects.\r\n            this.initFunction(scope);\r\n            this.initObject(scope);\r\n            // Unable to set scope's parent prior (OBJECT did not exist).\r\n            // Note that in a browser this would be 'Window', whereas in Node.js it would\r\n            // be 'Object'.  This interpreter is closer to Node in that it has no DOM.\r\n            scope.proto = this.OBJECT_PROTO;\r\n            this.setProperty(scope, 'constructor', this.OBJECT);\r\n            this.initArray(scope);\r\n            this.initString(scope);\r\n            this.initBoolean(scope);\r\n            this.initNumber(scope);\r\n            this.initDate(scope);\r\n            this.initRegExp(scope);\r\n            this.initError(scope);\r\n            this.initMath(scope);\r\n            this.initJSON(scope);\r\n            // Initialize global functions.\r\n            var thisInterpreter = this;\r\n            var func = this.createNativeFunction(function (x) { throw EvalError(\"Can't happen\"); }, false);\r\n            func.eval = true;\r\n            this.setProperty(scope, 'eval', func);\r\n            this.setProperty(scope, 'parseInt', this.createNativeFunction(parseInt, false));\r\n            this.setProperty(scope, 'parseFloat', this.createNativeFunction(parseFloat, false));\r\n            this.setProperty(scope, 'isNaN', this.createNativeFunction(isNaN, false));\r\n            this.setProperty(scope, 'isFinite', this.createNativeFunction(isFinite, false));\r\n            var strFunctions = [\r\n                [escape, 'escape'], [unescape, 'unescape'],\r\n                [decodeURI, 'decodeURI'], [decodeURIComponent, 'decodeURIComponent'],\r\n                [encodeURI, 'encodeURI'], [encodeURIComponent, 'encodeURIComponent']\r\n            ];\r\n            for (var i = 0; i < strFunctions.length; i++) {\r\n                var wrapper = (function (nativeFunc) {\r\n                    return function (str) {\r\n                        try {\r\n                            return nativeFunc(str);\r\n                        }\r\n                        catch (e) {\r\n                            // decodeURI('%xy') will throw an error.  Catch and rethrow.\r\n                            thisInterpreter.throwException(thisInterpreter.URI_ERROR, e.message);\r\n                        }\r\n                    };\r\n                })(strFunctions[i][0]);\r\n                this.setProperty(scope, strFunctions[i][1], this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            // Run any user-provided initialization.\r\n            if (this.initFunc_) {\r\n                this.initFunc_(this, scope);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Function class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initFunction = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            var identifierRegexp = /^[A-Za-z_$][\\w$]*$/;\r\n            // Function constructor.\r\n            wrapper = function (var_args) {\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Function().\r\n                    var newFunc = this;\r\n                }\r\n                else {\r\n                    // Called as Function().\r\n                    var newFunc = thisInterpreter.createObjectProto(thisInterpreter.FUNCTION_PROTO);\r\n                }\r\n                if (arguments.length) {\r\n                    var code = String(arguments[arguments.length - 1]);\r\n                }\r\n                else {\r\n                    var code = '';\r\n                }\r\n                var args = [];\r\n                for (var i = 0; i < arguments.length - 1; i++) {\r\n                    var name = String(arguments[i]);\r\n                    if (!name.match(identifierRegexp)) {\r\n                        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid function argument: ' + name);\r\n                    }\r\n                    args.push(name);\r\n                }\r\n                args = args.join(', ');\r\n                // Interestingly, the scope for constructed functions is the global scope,\r\n                // even if they were constructed in some other scope.\r\n                newFunc.parentScope = thisInterpreter.global;\r\n                // Acorn needs to parse code in the context of a function or else 'return'\r\n                // statements will be syntax errors.\r\n                try {\r\n                    var ast = Interpreter.acorn.parse('$ = function(' + args + ') {' + code + '};', Interpreter.PARSE_OPTIONS);\r\n                }\r\n                catch (e) {\r\n                    // Acorn threw a SyntaxError.  Rethrow as a trappable error.\r\n                    thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid code: ' + e.message);\r\n                }\r\n                if (ast['body'].length !== 1) {\r\n                    // Function('a', 'return a + 6;}; {alert(1);');\r\n                    thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid code in function body.');\r\n                }\r\n                newFunc.node = ast['body'][0]['expression']['right'];\r\n                thisInterpreter.setProperty(newFunc, 'length', newFunc.node['length'], Interpreter.READONLY_DESCRIPTOR);\r\n                return newFunc;\r\n            };\r\n            wrapper.id = this.functionCounter_++;\r\n            this.FUNCTION = this.createObjectProto(this.FUNCTION_PROTO);\r\n            this.setProperty(scope, 'Function', this.FUNCTION);\r\n            // Manually setup type and prototype because createObj doesn't recognize\r\n            // this object as a function (this.FUNCTION did not exist).\r\n            this.setProperty(this.FUNCTION, 'prototype', this.FUNCTION_PROTO);\r\n            this.FUNCTION.nativeFunc = wrapper;\r\n            // Configure Function.prototype.\r\n            this.setProperty(this.FUNCTION_PROTO, 'constructor', this.FUNCTION, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.FUNCTION_PROTO.nativeFunc = function () { };\r\n            this.FUNCTION_PROTO.nativeFunc.id = this.functionCounter_++;\r\n            this.setProperty(this.FUNCTION_PROTO, 'length', 0, Interpreter.READONLY_DESCRIPTOR);\r\n            var boxThis = function (value) {\r\n                // In non-strict mode 'this' must be an object.\r\n                if ((!value || !value.isObject) && !thisInterpreter.getScope().strict) {\r\n                    if (value === undefined || value === null) {\r\n                        // 'Undefined' and 'null' are changed to global object.\r\n                        value = thisInterpreter.global;\r\n                    }\r\n                    else {\r\n                        // Primitives must be boxed in non-strict mode.\r\n                        var box = thisInterpreter.createObjectProto(thisInterpreter.getPrototype(value));\r\n                        box.data = value;\r\n                        value = box;\r\n                    }\r\n                }\r\n                return value;\r\n            };\r\n            wrapper = function (thisArg, args) {\r\n                var state = thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\r\n                // Rewrite the current 'CallExpression' to apply a different function.\r\n                state.func_ = this;\r\n                // Assign the 'this' object.\r\n                state.funcThis_ = boxThis(thisArg);\r\n                // Bind any provided arguments.\r\n                state.arguments_ = [];\r\n                if (args !== null && args !== undefined) {\r\n                    if (args.isObject) {\r\n                        state.arguments_ = thisInterpreter.pseudoToNative(args);\r\n                    }\r\n                    else {\r\n                        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'CreateListFromArrayLike called on non-object');\r\n                    }\r\n                }\r\n                state.doneExec_ = false;\r\n            };\r\n            this.setNativeFunctionPrototype(this.FUNCTION, 'apply', wrapper);\r\n            wrapper = function (thisArg, var_args) {\r\n                var state = thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\r\n                // Rewrite the current 'CallExpression' to call a different function.\r\n                state.func_ = this;\r\n                // Assign the 'this' object.\r\n                state.funcThis_ = boxThis(thisArg);\r\n                // Bind any provided arguments.\r\n                state.arguments_ = [];\r\n                for (var i = 1; i < arguments.length; i++) {\r\n                    state.arguments_.push(arguments[i]);\r\n                }\r\n                state.doneExec_ = false;\r\n            };\r\n            this.setNativeFunctionPrototype(this.FUNCTION, 'call', wrapper);\r\n            this.polyfills_.push(\r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\r\n            \"Object.defineProperty(Function.prototype, 'bind',\", \"{configurable: true, writable: true, value:\", \"function(oThis) {\", \"if (typeof this !== 'function') {\", \"throw TypeError('What is trying to be bound is not callable');\", \"}\", \"var aArgs   = Array.prototype.slice.call(arguments, 1),\", \"fToBind = this,\", \"fNOP    = function() {},\", \"fBound  = function() {\", \"return fToBind.apply(this instanceof fNOP\", \"? this\", \": oThis,\", \"aArgs.concat(Array.prototype.slice.call(arguments)));\", \"};\", \"if (this.prototype) {\", \"fNOP.prototype = this.prototype;\", \"}\", \"fBound.prototype = new fNOP();\", \"return fBound;\", \"}\", \"});\", \"\");\r\n            // Function has no parent to inherit from, so it needs its own mandatory\r\n            // toString and valueOf functions.\r\n            wrapper = function () {\r\n                return this.toString();\r\n            };\r\n            this.setNativeFunctionPrototype(this.FUNCTION, 'toString', wrapper);\r\n            this.setProperty(this.FUNCTION, 'toString', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function () {\r\n                return this.valueOf();\r\n            };\r\n            this.setNativeFunctionPrototype(this.FUNCTION, 'valueOf', wrapper);\r\n            this.setProperty(this.FUNCTION, 'valueOf', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Object class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initObject = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // Object constructor.\r\n            wrapper = function (value) {\r\n                if (value === undefined || value === null) {\r\n                    // Create a new object.\r\n                    if (thisInterpreter.calledWithNew()) {\r\n                        // Called as new Object().\r\n                        return this;\r\n                    }\r\n                    else {\r\n                        // Called as Object().\r\n                        return thisInterpreter.createObjectProto(thisInterpreter.OBJECT_PROTO);\r\n                    }\r\n                }\r\n                if (!value.isObject) {\r\n                    // Wrap the value as an object.\r\n                    var box = thisInterpreter.createObjectProto(thisInterpreter.getPrototype(value));\r\n                    box.data = value;\r\n                    return box;\r\n                }\r\n                // Return the provided object.\r\n                return value;\r\n            };\r\n            this.OBJECT = this.createNativeFunction(wrapper, true);\r\n            // Throw away the created prototype and use the root prototype.\r\n            this.setProperty(this.OBJECT, 'prototype', this.OBJECT_PROTO);\r\n            this.setProperty(this.OBJECT_PROTO, 'constructor', this.OBJECT);\r\n            this.setProperty(scope, 'Object', this.OBJECT);\r\n            /**\r\n             * Checks if the provided value is null or undefined.\r\n             * If so, then throw an error in the call stack.\r\n             * @param {Interpreter.MyValue} value Value to check.\r\n             */\r\n            var throwIfNullUndefined = function (value) {\r\n                if (value === undefined || value === null) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, \"Cannot convert '\" + value + \"' to object\");\r\n                }\r\n            };\r\n            // Static methods on Object.\r\n            wrapper = function (obj) {\r\n                throwIfNullUndefined(obj);\r\n                var props = obj.isObject ? obj.properties : obj;\r\n                return thisInterpreter.nativeToPseudo(Object.getOwnPropertyNames(props));\r\n            };\r\n            this.setProperty(this.OBJECT, 'getOwnPropertyNames', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (obj) {\r\n                throwIfNullUndefined(obj);\r\n                if (!obj.isObject) {\r\n                    return thisInterpreter.nativeToPseudo(Object.keys(obj));\r\n                }\r\n                return thisInterpreter.nativeToPseudo(Object.keys(obj.properties));\r\n            };\r\n            this.setProperty(this.OBJECT, 'keys', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (proto) {\r\n                // Support for the second argument is the responsibility of a polyfill.\r\n                if (proto === null) {\r\n                    return thisInterpreter.createObjectProto(null);\r\n                }\r\n                if (proto === undefined || !proto.isObject) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Object prototype may only be an Object or null');\r\n                }\r\n                return thisInterpreter.createObjectProto(proto);\r\n            };\r\n            this.setProperty(this.OBJECT, 'create', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Add a polyfill to handle create's second argument.\r\n            this.polyfills_.push(\"(function() {\", \"var create_ = Object.create;\", \"Object.create = function(proto, props) {\", \"var obj = create_(proto);\", \"props && Object.defineProperties(obj, props);\", \"return obj;\", \"};\", \"})();\", \"\");\r\n            wrapper = function (obj, prop, descriptor) {\r\n                prop = String(prop);\r\n                if (!obj || !obj.isObject) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Object.defineProperty called on non-object');\r\n                }\r\n                if (!descriptor || !descriptor.isObject) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Property description must be an object');\r\n                }\r\n                if (!obj.properties[prop] && obj.preventExtensions) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, \"Can't define property '\" + prop + \"', object is not extensible\");\r\n                }\r\n                // The polyfill guarantees no inheritance and no getter functions.\r\n                // Therefore the descriptor properties map is the native object needed.\r\n                thisInterpreter.setProperty(obj, prop, ReferenceError, descriptor.properties);\r\n                return obj;\r\n            };\r\n            this.setProperty(this.OBJECT, 'defineProperty', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.polyfills_.push(\r\n            // Flatten the descriptor to remove any inheritance or getter functions.\r\n            \"(function() {\", \"var defineProperty_ = Object.defineProperty;\", \"Object.defineProperty = function(obj, prop, d1) {\", \"var d2 = {};\", \"if ('configurable' in d1) d2.configurable = d1.configurable;\", \"if ('enumerable' in d1) d2.enumerable = d1.enumerable;\", \"if ('writable' in d1) d2.writable = d1.writable;\", \"if ('value' in d1) d2.value = d1.value;\", \"if ('get' in d1) d2.get = d1.get;\", \"if ('set' in d1) d2.set = d1.set;\", \"return defineProperty_(obj, prop, d2);\", \"};\", \"})();\", \"Object.defineProperty(Object, 'defineProperties',\", \"{configurable: true, writable: true, value:\", \"function(obj, props) {\", \"var keys = Object.keys(props);\", \"for (var i = 0; i < keys.length; i++) {\", \"Object.defineProperty(obj, keys[i], props[keys[i]]);\", \"}\", \"return obj;\", \"}\", \"});\", \"\");\r\n            wrapper = function (obj, prop) {\r\n                if (!obj || !obj.isObject) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Object.getOwnPropertyDescriptor called on non-object');\r\n                }\r\n                prop = String(prop);\r\n                if (!(prop in obj.properties)) {\r\n                    return undefined;\r\n                }\r\n                var descriptor = Object.getOwnPropertyDescriptor(obj.properties, prop);\r\n                var getter = obj.getter[prop];\r\n                var setter = obj.setter[prop];\r\n                if (getter || setter) {\r\n                    descriptor.get = getter;\r\n                    descriptor.set = setter;\r\n                    delete descriptor.value;\r\n                    delete descriptor.writable;\r\n                }\r\n                var pseudoDescriptor = thisInterpreter.nativeToPseudo(descriptor);\r\n                if ('value' in descriptor) {\r\n                    thisInterpreter.setProperty(pseudoDescriptor, 'value', descriptor.value);\r\n                }\r\n                return pseudoDescriptor;\r\n            };\r\n            this.setProperty(this.OBJECT, 'getOwnPropertyDescriptor', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (obj) {\r\n                throwIfNullUndefined(obj);\r\n                return thisInterpreter.getPrototype(obj);\r\n            };\r\n            this.setProperty(this.OBJECT, 'getPrototypeOf', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (obj) {\r\n                return Boolean(obj) && !obj.preventExtensions;\r\n            };\r\n            this.setProperty(this.OBJECT, 'isExtensible', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (obj) {\r\n                if (obj && obj.isObject) {\r\n                    obj.preventExtensions = true;\r\n                }\r\n                return obj;\r\n            };\r\n            this.setProperty(this.OBJECT, 'preventExtensions', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Instance methods on Object.\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'toString', Interpreter.MyObject.prototype.toString);\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'toLocaleString', Interpreter.MyObject.prototype.toString);\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'valueOf', Interpreter.MyObject.prototype.valueOf);\r\n            wrapper = function (prop) {\r\n                throwIfNullUndefined(this);\r\n                if (!this.isObject) {\r\n                    return this.hasOwnProperty(prop);\r\n                }\r\n                return String(prop) in this.properties;\r\n            };\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'hasOwnProperty', wrapper);\r\n            wrapper = function (prop) {\r\n                throwIfNullUndefined(this);\r\n                return Object.prototype.propertyIsEnumerable.call(this.properties, prop);\r\n            };\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'propertyIsEnumerable', wrapper);\r\n            wrapper = function (obj) {\r\n                while (true) {\r\n                    // Note, circular loops shouldn't be possible.\r\n                    obj = thisInterpreter.getPrototype(obj);\r\n                    if (!obj) {\r\n                        // No parent; reached the top.\r\n                        return false;\r\n                    }\r\n                    if (obj === this) {\r\n                        return true;\r\n                    }\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'isPrototypeOf', wrapper);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Array class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initArray = function (scope) {\r\n            var thisInterpreter = this;\r\n            var getInt = function (obj, def) {\r\n                // Return an integer, or the default.\r\n                var n = obj ? Math.floor(obj) : def;\r\n                if (isNaN(n)) {\r\n                    n = def;\r\n                }\r\n                return n;\r\n            };\r\n            var wrapper;\r\n            // Array constructor.\r\n            wrapper = function (var_args) {\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Array().\r\n                    var newArray = this;\r\n                }\r\n                else {\r\n                    // Called as Array().\r\n                    var newArray = thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\r\n                }\r\n                var first = arguments[0];\r\n                if (arguments.length === 1 && typeof first === 'number') {\r\n                    if (isNaN(Interpreter.legalArrayLength(first))) {\r\n                        thisInterpreter.throwException(thisInterpreter.RANGE_ERROR, 'Invalid array length');\r\n                    }\r\n                    newArray.properties.length = first;\r\n                }\r\n                else {\r\n                    for (var i = 0; i < arguments.length; i++) {\r\n                        newArray.properties[i] = arguments[i];\r\n                    }\r\n                    newArray.properties.length = i;\r\n                }\r\n                return newArray;\r\n            };\r\n            this.ARRAY = this.createNativeFunction(wrapper, true);\r\n            this.ARRAY_PROTO = this.ARRAY.properties['prototype'];\r\n            this.setProperty(scope, 'Array', this.ARRAY);\r\n            // Static methods on Array.\r\n            wrapper = function (obj) {\r\n                return obj && obj.class === 'Array';\r\n            };\r\n            this.setProperty(this.ARRAY, 'isArray', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Instance methods on Array.\r\n            wrapper = function () {\r\n                return Array.prototype.pop.call(this.properties);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'pop', wrapper);\r\n            wrapper = function (var_args) {\r\n                return Array.prototype.push.apply(this.properties, arguments);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'push', wrapper);\r\n            wrapper = function () {\r\n                return Array.prototype.shift.call(this.properties);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'shift', wrapper);\r\n            wrapper = function (var_args) {\r\n                return Array.prototype.unshift.apply(this.properties, arguments);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'unshift', wrapper);\r\n            wrapper = function () {\r\n                Array.prototype.reverse.call(this.properties);\r\n                return this;\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'reverse', wrapper);\r\n            wrapper = function (index, howmany /*, var_args*/) {\r\n                var list = Array.prototype.splice.apply(this.properties, arguments);\r\n                return thisInterpreter.nativeToPseudo(list);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'splice', wrapper);\r\n            wrapper = function (opt_begin, opt_end) {\r\n                var list = Array.prototype.slice.call(this.properties, opt_begin, opt_end);\r\n                return thisInterpreter.nativeToPseudo(list);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'slice', wrapper);\r\n            wrapper = function (opt_separator) {\r\n                return Array.prototype.join.call(this.properties, opt_separator);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'join', wrapper);\r\n            wrapper = function (var_args) {\r\n                var list = [];\r\n                var length = 0;\r\n                // Start by copying the current array.\r\n                var iLength = thisInterpreter.getProperty(this, 'length');\r\n                for (var i = 0; i < iLength; i++) {\r\n                    if (thisInterpreter.hasProperty(this, i)) {\r\n                        var element = thisInterpreter.getProperty(this, i);\r\n                        list[length] = element;\r\n                    }\r\n                    length++;\r\n                }\r\n                // Loop through all arguments and copy them in.\r\n                for (var i = 0; i < arguments.length; i++) {\r\n                    var value = arguments[i];\r\n                    if (thisInterpreter.isa(value, thisInterpreter.ARRAY)) {\r\n                        var jLength = thisInterpreter.getProperty(value, 'length');\r\n                        for (var j = 0; j < jLength; j++) {\r\n                            if (thisInterpreter.hasProperty(value, j)) {\r\n                                list[length] = thisInterpreter.getProperty(value, j);\r\n                            }\r\n                            length++;\r\n                        }\r\n                    }\r\n                    else {\r\n                        list[length] = value;\r\n                    }\r\n                }\r\n                return thisInterpreter.nativeToPseudo(list);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'concat', wrapper);\r\n            wrapper = function (searchElement, opt_fromIndex) {\r\n                return Array.prototype.indexOf.apply(this.properties, arguments);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'indexOf', wrapper);\r\n            wrapper = function (searchElement, opt_fromIndex) {\r\n                return Array.prototype.lastIndexOf.apply(this.properties, arguments);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'lastIndexOf', wrapper);\r\n            wrapper = function () {\r\n                Array.prototype.sort.call(this.properties);\r\n                return this;\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'sort', wrapper);\r\n            this.polyfills_.push(\r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/every\r\n            \"Object.defineProperty(Array.prototype, 'every',\", \"{configurable: true, writable: true, value:\", \"function(callbackfn, thisArg) {\", \"if (!this || typeof callbackfn !== 'function') throw TypeError();\", \"var T, k;\", \"var O = Object(this);\", \"var len = O.length >>> 0;\", \"if (arguments.length > 1) T = thisArg;\", \"k = 0;\", \"while (k < len) {\", \"if (k in O && !callbackfn.call(T, O[k], k, O)) return false;\", \"k++;\", \"}\", \"return true;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\r\n            \"Object.defineProperty(Array.prototype, 'filter',\", \"{configurable: true, writable: true, value:\", \"function(fun/*, thisArg*/) {\", \"if (this === void 0 || this === null || typeof fun !== 'function') throw TypeError();\", \"var t = Object(this);\", \"var len = t.length >>> 0;\", \"var res = [];\", \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\", \"for (var i = 0; i < len; i++) {\", \"if (i in t) {\", \"var val = t[i];\", \"if (fun.call(thisArg, val, i, t)) res.push(val);\", \"}\", \"}\", \"return res;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n            \"Object.defineProperty(Array.prototype, 'forEach',\", \"{configurable: true, writable: true, value:\", \"function(callback, thisArg) {\", \"if (!this || typeof callback !== 'function') throw TypeError();\", \"var T, k;\", \"var O = Object(this);\", \"var len = O.length >>> 0;\", \"if (arguments.length > 1) T = thisArg;\", \"k = 0;\", \"while (k < len) {\", \"if (k in O) callback.call(T, O[k], k, O);\", \"k++;\", \"}\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map\r\n            \"Object.defineProperty(Array.prototype, 'map',\", \"{configurable: true, writable: true, value:\", \"function(callback, thisArg) {\", \"if (!this || typeof callback !== 'function') new TypeError;\", \"var T, A, k;\", \"var O = Object(this);\", \"var len = O.length >>> 0;\", \"if (arguments.length > 1) T = thisArg;\", \"A = new Array(len);\", \"k = 0;\", \"while (k < len) {\", \"if (k in O) A[k] = callback.call(T, O[k], k, O);\", \"k++;\", \"}\", \"return A;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\r\n            \"Object.defineProperty(Array.prototype, 'reduce',\", \"{configurable: true, writable: true, value:\", \"function(callback /*, initialValue*/) {\", \"if (!this || typeof callback !== 'function') throw TypeError();\", \"var t = Object(this), len = t.length >>> 0, k = 0, value;\", \"if (arguments.length === 2) {\", \"value = arguments[1];\", \"} else {\", \"while (k < len && !(k in t)) k++;\", \"if (k >= len) {\", \"throw TypeError('Reduce of empty array with no initial value');\", \"}\", \"value = t[k++];\", \"}\", \"for (; k < len; k++) {\", \"if (k in t) value = callback(value, t[k], k, t);\", \"}\", \"return value;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\r\n            \"Object.defineProperty(Array.prototype, 'reduceRight',\", \"{configurable: true, writable: true, value:\", \"function(callback /*, initialValue*/) {\", \"if (null === this || 'undefined' === typeof this || 'function' !== typeof callback) throw TypeError();\", \"var t = Object(this), len = t.length >>> 0, k = len - 1, value;\", \"if (arguments.length >= 2) {\", \"value = arguments[1];\", \"} else {\", \"while (k >= 0 && !(k in t)) k--;\", \"if (k < 0) {\", \"throw TypeError('Reduce of empty array with no initial value');\", \"}\", \"value = t[k--];\", \"}\", \"for (; k >= 0; k--) {\", \"if (k in t) value = callback(value, t[k], k, t);\", \"}\", \"return value;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/some\r\n            \"Object.defineProperty(Array.prototype, 'some',\", \"{configurable: true, writable: true, value:\", \"function(fun/*, thisArg*/) {\", \"if (!this || typeof fun !== 'function') throw TypeError();\", \"var t = Object(this);\", \"var len = t.length >>> 0;\", \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\", \"for (var i = 0; i < len; i++) {\", \"if (i in t && fun.call(thisArg, t[i], i, t)) {\", \"return true;\", \"}\", \"}\", \"return false;\", \"}\", \"});\", \"(function() {\", \"var sort_ = Array.prototype.sort;\", \"Array.prototype.sort = function(opt_comp) {\", \r\n            // Fast native sort.\r\n            \"if (typeof opt_comp !== 'function') {\", \"return sort_.call(this);\", \"}\", \r\n            // Slow bubble sort.\r\n            \"for (var i = 0; i < this.length; i++) {\", \"var changes = 0;\", \"for (var j = 0; j < this.length - i - 1; j++) {\", \"if (opt_comp(this[j], this[j + 1]) > 0) {\", \"var swap = this[j];\", \"this[j] = this[j + 1];\", \"this[j + 1] = swap;\", \"changes++;\", \"}\", \"}\", \"if (!changes) break;\", \"}\", \"return this;\", \"};\", \"})();\", \"Object.defineProperty(Array.prototype, 'toLocaleString',\", \"{configurable: true, writable: true, value:\", \"function() {\", \"var out = [];\", \"for (var i = 0; i < this.length; i++) {\", \"out[i] = (this[i] === null || this[i] === undefined) ? '' : this[i].toLocaleString();\", \"}\", \"return out.join(',');\", \"}\", \"});\", \"\");\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the String class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initString = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // String constructor.\r\n            wrapper = function (value) {\r\n                value = String(value);\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new String().\r\n                    this.data = value;\r\n                    return this;\r\n                }\r\n                else {\r\n                    // Called as String().\r\n                    return value;\r\n                }\r\n            };\r\n            this.STRING = this.createNativeFunction(wrapper, true);\r\n            this.setProperty(scope, 'String', this.STRING);\r\n            // Static methods on String.\r\n            this.setProperty(this.STRING, 'fromCharCode', this.createNativeFunction(String.fromCharCode, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Instance methods on String.\r\n            // Methods with exclusively primitive arguments.\r\n            var functions = ['trim', 'toLowerCase', 'toUpperCase',\r\n                'toLocaleLowerCase', 'toLocaleUpperCase', 'charAt', 'charCodeAt',\r\n                'substring', 'slice', 'substr', 'indexOf', 'lastIndexOf', 'concat'];\r\n            for (var i = 0; i < functions.length; i++) {\r\n                this.setNativeFunctionPrototype(this.STRING, functions[i], String.prototype[functions[i]]);\r\n            }\r\n            wrapper = function (compareString, locales, options) {\r\n                locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\r\n                options = options ? thisInterpreter.pseudoToNative(options) : undefined;\r\n                return String(this).localeCompare(compareString, locales, options);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'localeCompare', wrapper);\r\n            wrapper = function (separator, limit) {\r\n                if (thisInterpreter.isa(separator, thisInterpreter.REGEXP)) {\r\n                    separator = separator.data;\r\n                }\r\n                var jsList = String(this).split(separator, limit);\r\n                return thisInterpreter.nativeToPseudo(jsList);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'split', wrapper);\r\n            wrapper = function (regexp) {\r\n                regexp = regexp ? regexp.data : undefined;\r\n                var match = String(this).match(regexp);\r\n                if (!match) {\r\n                    return null;\r\n                }\r\n                return thisInterpreter.nativeToPseudo(match);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'match', wrapper);\r\n            wrapper = function (regexp) {\r\n                if (thisInterpreter.isa(regexp, thisInterpreter.REGEXP)) {\r\n                    regexp = regexp.data;\r\n                }\r\n                return String(this).search(regexp);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'search', wrapper);\r\n            wrapper = function (substr, newSubstr) {\r\n                // Support for function replacements is the responsibility of a polyfill.\r\n                return String(this).replace(substr.data || substr, newSubstr);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'replace', wrapper);\r\n            // Add a polyfill to handle replace's second argument being a function.\r\n            this.polyfills_.push(\"(function() {\", \"var replace_ = String.prototype.replace;\", \"String.prototype.replace = function(substr, newSubstr) {\", \"if (typeof newSubstr !== 'function') {\", \r\n            // string.replace(string|regexp, string)\r\n            \"return replace_.call(this, substr, newSubstr);\", \"}\", \"var str = this;\", \"if (substr instanceof RegExp) {\", // string.replace(regexp, function)\r\n            \"var subs = [];\", \"var m = substr.exec(str);\", \"while (m) {\", \"m.push(m.index, str);\", \"var inject = newSubstr.apply(null, m);\", \"subs.push([m.index, m[0].length, inject]);\", \"m = substr.global ? substr.exec(str) : null;\", \"}\", \"for (var i = subs.length - 1; i >= 0; i--) {\", \"str = str.substring(0, subs[i][0]) + subs[i][2] + \" +\r\n                \"str.substring(subs[i][0] + subs[i][1]);\", \"}\", \"} else {\", // string.replace(string, function)\r\n            \"var i = str.indexOf(substr);\", \"if (i !== -1) {\", \"var inject = newSubstr(str.substr(i, substr.length), i, str);\", \"str = str.substring(0, i) + inject + \" +\r\n                \"str.substring(i + substr.length);\", \"}\", \"}\", \"return str;\", \"};\", \"})();\", \"\");\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Boolean class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initBoolean = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // Boolean constructor.\r\n            wrapper = function (value) {\r\n                value = Boolean(value);\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Boolean().\r\n                    this.data = value;\r\n                    return this;\r\n                }\r\n                else {\r\n                    // Called as Boolean().\r\n                    return value;\r\n                }\r\n            };\r\n            this.BOOLEAN = this.createNativeFunction(wrapper, true);\r\n            this.setProperty(scope, 'Boolean', this.BOOLEAN);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Number class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initNumber = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // Number constructor.\r\n            wrapper = function (value) {\r\n                value = Number(value);\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Number().\r\n                    this.data = value;\r\n                    return this;\r\n                }\r\n                else {\r\n                    // Called as Number().\r\n                    return value;\r\n                }\r\n            };\r\n            this.NUMBER = this.createNativeFunction(wrapper, true);\r\n            this.setProperty(scope, 'Number', this.NUMBER);\r\n            var numConsts = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY',\r\n                'POSITIVE_INFINITY'];\r\n            for (var i = 0; i < numConsts.length; i++) {\r\n                this.setProperty(this.NUMBER, numConsts[i], Number[numConsts[i]], Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            // Instance methods on Number.\r\n            wrapper = function (fractionDigits) {\r\n                try {\r\n                    return Number(this).toExponential(fractionDigits);\r\n                }\r\n                catch (e) {\r\n                    // Throws if fractionDigits isn't within 0-20.\r\n                    thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toExponential', wrapper);\r\n            wrapper = function (digits) {\r\n                try {\r\n                    return Number(this).toFixed(digits);\r\n                }\r\n                catch (e) {\r\n                    // Throws if digits isn't within 0-20.\r\n                    thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toFixed', wrapper);\r\n            wrapper = function (precision) {\r\n                try {\r\n                    return Number(this).toPrecision(precision);\r\n                }\r\n                catch (e) {\r\n                    // Throws if precision isn't within range (depends on implementation).\r\n                    thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toPrecision', wrapper);\r\n            wrapper = function (radix) {\r\n                try {\r\n                    return Number(this).toString(radix);\r\n                }\r\n                catch (e) {\r\n                    // Throws if radix isn't within 2-36.\r\n                    thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toString', wrapper);\r\n            wrapper = function (locales, options) {\r\n                locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\r\n                options = options ? thisInterpreter.pseudoToNative(options) : undefined;\r\n                return Number(this).toLocaleString(locales, options);\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toLocaleString', wrapper);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Date class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initDate = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // Date constructor.\r\n            wrapper = function (value, var_args) {\r\n                if (!thisInterpreter.calledWithNew()) {\r\n                    // Called as Date().\r\n                    // Calling Date() as a function returns a string, no arguments are heeded.\r\n                    return Date();\r\n                }\r\n                // Called as new Date().\r\n                var args = [null].concat([].slice.call(arguments));\r\n                this.data = new (Function.prototype.bind.apply(Date, args));\r\n                return this;\r\n            };\r\n            this.DATE = this.createNativeFunction(wrapper, true);\r\n            this.setProperty(scope, 'Date', this.DATE);\r\n            // Static methods on Date.\r\n            this.setProperty(this.DATE, 'now', this.createNativeFunction(Date.now, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.DATE, 'parse', this.createNativeFunction(Date.parse, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.DATE, 'UTC', this.createNativeFunction(Date.UTC, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Instance methods on Date.\r\n            var functions = ['getDate', 'getDay', 'getFullYear', 'getHours',\r\n                'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTime',\r\n                'getTimezoneOffset', 'getUTCDate', 'getUTCDay', 'getUTCFullYear',\r\n                'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth',\r\n                'getUTCSeconds', 'getYear',\r\n                'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\r\n                'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate',\r\n                'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes',\r\n                'setUTCMonth', 'setUTCSeconds', 'setYear',\r\n                'toDateString', 'toISOString', 'toJSON', 'toGMTString',\r\n                'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString',\r\n                'toTimeString', 'toUTCString'];\r\n            for (var i = 0; i < functions.length; i++) {\r\n                wrapper = (function (nativeFunc) {\r\n                    return function (var_args) {\r\n                        var args = [];\r\n                        for (var i = 0; i < arguments.length; i++) {\r\n                            args[i] = thisInterpreter.pseudoToNative(arguments[i]);\r\n                        }\r\n                        return this.data[nativeFunc].apply(this.data, args);\r\n                    };\r\n                })(functions[i]);\r\n                this.setNativeFunctionPrototype(this.DATE, functions[i], wrapper);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize Regular Expression object.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initRegExp = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // RegExp constructor.\r\n            wrapper = function (pattern, flags) {\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new RegExp().\r\n                    var rgx = this;\r\n                }\r\n                else {\r\n                    // Called as RegExp().\r\n                    var rgx = thisInterpreter.createObjectProto(thisInterpreter.REGEXP_PROTO);\r\n                }\r\n                pattern = pattern ? pattern.toString() : '';\r\n                flags = flags ? flags.toString() : '';\r\n                thisInterpreter.populateRegExp(rgx, new RegExp(pattern, flags));\r\n                return rgx;\r\n            };\r\n            this.REGEXP = this.createNativeFunction(wrapper, true);\r\n            this.REGEXP_PROTO = this.REGEXP.properties['prototype'];\r\n            this.setProperty(scope, 'RegExp', this.REGEXP);\r\n            this.setProperty(this.REGEXP.properties['prototype'], 'global', undefined, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.REGEXP.properties['prototype'], 'ignoreCase', undefined, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.REGEXP.properties['prototype'], 'multiline', undefined, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.REGEXP.properties['prototype'], 'source', '(?:)', Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (str) {\r\n                return this.data.test(str);\r\n            };\r\n            this.setNativeFunctionPrototype(this.REGEXP, 'test', wrapper);\r\n            wrapper = function (str) {\r\n                str = str.toString();\r\n                // Get lastIndex from wrapped regex, since this is settable.\r\n                this.data.lastIndex =\r\n                    Number(thisInterpreter.getProperty(this, 'lastIndex'));\r\n                var match = this.data.exec(str);\r\n                thisInterpreter.setProperty(this, 'lastIndex', this.data.lastIndex);\r\n                if (match) {\r\n                    var result = thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\r\n                    for (var i = 0; i < match.length; i++) {\r\n                        thisInterpreter.setProperty(result, i, match[i]);\r\n                    }\r\n                    // match has additional properties.\r\n                    thisInterpreter.setProperty(result, 'index', match.index);\r\n                    thisInterpreter.setProperty(result, 'input', match.input);\r\n                    return result;\r\n                }\r\n                return null;\r\n            };\r\n            this.setNativeFunctionPrototype(this.REGEXP, 'exec', wrapper);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Error class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initError = function (scope) {\r\n            var thisInterpreter = this;\r\n            // Error constructor.\r\n            this.ERROR = this.createNativeFunction(function (opt_message) {\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Error().\r\n                    var newError = this;\r\n                }\r\n                else {\r\n                    // Called as Error().\r\n                    var newError = thisInterpreter.createObject(thisInterpreter.ERROR);\r\n                }\r\n                if (opt_message) {\r\n                    thisInterpreter.setProperty(newError, 'message', String(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n                }\r\n                return newError;\r\n            }, true);\r\n            this.setProperty(scope, 'Error', this.ERROR);\r\n            this.setProperty(this.ERROR.properties['prototype'], 'message', '', Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.ERROR.properties['prototype'], 'name', 'Error', Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            var createErrorSubclass = function (name) {\r\n                var constructor = thisInterpreter.createNativeFunction(function (opt_message) {\r\n                    if (thisInterpreter.calledWithNew()) {\r\n                        // Called as new XyzError().\r\n                        var newError = this;\r\n                    }\r\n                    else {\r\n                        // Called as XyzError().\r\n                        var newError = thisInterpreter.createObject(constructor);\r\n                    }\r\n                    if (opt_message) {\r\n                        thisInterpreter.setProperty(newError, 'message', String(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n                    }\r\n                    return newError;\r\n                }, true);\r\n                thisInterpreter.setProperty(constructor, 'prototype', thisInterpreter.createObject(thisInterpreter.ERROR));\r\n                thisInterpreter.setProperty(constructor.properties['prototype'], 'name', name, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n                thisInterpreter.setProperty(scope, name, constructor);\r\n                return constructor;\r\n            };\r\n            this.EVAL_ERROR = createErrorSubclass('EvalError');\r\n            this.RANGE_ERROR = createErrorSubclass('RangeError');\r\n            this.REFERENCE_ERROR = createErrorSubclass('ReferenceError');\r\n            this.SYNTAX_ERROR = createErrorSubclass('SyntaxError');\r\n            this.TYPE_ERROR = createErrorSubclass('TypeError');\r\n            this.URI_ERROR = createErrorSubclass('URIError');\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize Math object.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initMath = function (scope) {\r\n            var thisInterpreter = this;\r\n            var myMath = this.createObjectProto(this.OBJECT_PROTO);\r\n            this.setProperty(scope, 'Math', myMath);\r\n            var mathConsts = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI',\r\n                'SQRT1_2', 'SQRT2'];\r\n            for (var i = 0; i < mathConsts.length; i++) {\r\n                this.setProperty(myMath, mathConsts[i], Math[mathConsts[i]], Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            var numFunctions = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos',\r\n                'exp', 'floor', 'log', 'max', 'min', 'pow', 'random',\r\n                'round', 'sin', 'sqrt', 'tan'];\r\n            for (var i = 0; i < numFunctions.length; i++) {\r\n                this.setProperty(myMath, numFunctions[i], this.createNativeFunction(Math[numFunctions[i]], false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize JSON object.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initJSON = function (scope) {\r\n            var thisInterpreter = this;\r\n            var myJSON = thisInterpreter.createObjectProto(this.OBJECT_PROTO);\r\n            this.setProperty(scope, 'JSON', myJSON);\r\n            var wrapper = function (text) {\r\n                try {\r\n                    var nativeObj = JSON.parse(text.toString());\r\n                }\r\n                catch (e) {\r\n                    thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, e.message);\r\n                }\r\n                return thisInterpreter.nativeToPseudo(nativeObj);\r\n            };\r\n            this.setProperty(myJSON, 'parse', this.createNativeFunction(wrapper, false));\r\n            wrapper = function (value) {\r\n                var nativeObj = thisInterpreter.pseudoToNative(value);\r\n                try {\r\n                    var str = JSON.stringify(nativeObj);\r\n                }\r\n                catch (e) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, e.message);\r\n                }\r\n                return str;\r\n            };\r\n            this.setProperty(myJSON, 'stringify', this.createNativeFunction(wrapper, false));\r\n        };\r\n        ;\r\n        /**\r\n         * Is an object of a certain class?\r\n         * @param {Interpreter.MyValue} child Object to check.\r\n         * @param {Interpreter.MyObject} constructor Constructor of object.\r\n         * @return {boolean} True if object is the class or inherits from it.\r\n         *     False otherwise.\r\n         */\r\n        Interpreter.prototype.isa = function (child, constructor) {\r\n            if (child === null || child === undefined || !constructor) {\r\n                return false;\r\n            }\r\n            var proto = constructor.properties['prototype'];\r\n            if (child === proto) {\r\n                return true;\r\n            }\r\n            // The first step up the prototype chain is harder since the child might be\r\n            // a primitive value.  Subsequent steps can just follow the .proto property.\r\n            var childObj = this.getPrototype(child);\r\n            while (childObj) {\r\n                if (childObj === proto) {\r\n                    return true;\r\n                }\r\n                childObj = childObj.proto;\r\n            }\r\n            return false;\r\n        };\r\n        ;\r\n        /**\r\n         * Is a value a legal integer for an array length?\r\n         * @param {Interpreter.MyValue} x Value to check.\r\n         * @return {number} Zero, or a positive integer if the value can be\r\n         *     converted to such.  NaN otherwise.\r\n         */\r\n        Interpreter.legalArrayLength = function (x) {\r\n            var n = x >>> 0;\r\n            // Array length must be between 0 and 2^32-1 (inclusive).\r\n            return (n === Number(x)) ? n : NaN;\r\n        };\r\n        ;\r\n        /**\r\n         * Is a value a legal integer for an array index?\r\n         * @param {Interpreter.MyValue} x Value to check.\r\n         * @return {number} Zero, or a positive integer if the value can be\r\n         *     converted to such.  NaN otherwise.\r\n         */\r\n        Interpreter.legalArrayIndex = function (x) {\r\n            var n = x >>> 0;\r\n            // Array index cannot be 2^32-1, otherwise length would be 2^32.\r\n            // 0xffffffff is 2^32-1.\r\n            return (String(n) === String(x) && n !== 0xffffffff) ? n : NaN;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new data object based on a constructor's prototype.\r\n         * @param {Interpreter.MyObject} constructor Parent constructor function,\r\n         *     or null if scope object.\r\n         * @return {!Interpreter.MyObject} New data object.\r\n         */\r\n        Interpreter.prototype.createObject = function (constructor) {\r\n            return this.createObjectProto(constructor &&\r\n                constructor.properties['prototype']);\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new data object based on a prototype.\r\n         * @param {Interpreter.MyObject} proto Prototype object.\r\n         * @return {!Interpreter.MyObject} New data object.\r\n         */\r\n        Interpreter.prototype.createObjectProto = function (proto) {\r\n            var obj = new Interpreter.MyObject(proto);\r\n            // Functions have prototype objects.\r\n            if (this.isa(obj, this.FUNCTION)) {\r\n                this.setProperty(obj, 'prototype', this.createObjectProto(this.OBJECT_PROTO || null));\r\n                obj.class = 'Function';\r\n            }\r\n            // Arrays have length.\r\n            if (this.isa(obj, this.ARRAY)) {\r\n                this.setProperty(obj, 'length', 0, { configurable: false, enumerable: false, writable: true });\r\n                obj.class = 'Array';\r\n            }\r\n            if (this.isa(obj, this.ERROR)) {\r\n                obj.class = 'Error';\r\n            }\r\n            return obj;\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize a pseudo regular expression object based on a native regular\r\n         * expression object.\r\n         * @param {!Interpreter.MyObject} pseudoRegexp The existing object to set.\r\n         * @param {!RegExp} nativeRegexp The native regular expression.\r\n         */\r\n        Interpreter.prototype.populateRegExp = function (pseudoRegexp, nativeRegexp) {\r\n            pseudoRegexp.data = nativeRegexp;\r\n            // lastIndex is settable, all others are read-only attributes\r\n            this.setProperty(pseudoRegexp, 'lastIndex', nativeRegexp.lastIndex, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(pseudoRegexp, 'source', nativeRegexp.source, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(pseudoRegexp, 'global', nativeRegexp.global, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(pseudoRegexp, 'ignoreCase', nativeRegexp.ignoreCase, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(pseudoRegexp, 'multiline', nativeRegexp.multiline, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new function.\r\n         * @param {!Object} node AST node defining the function.\r\n         * @param {!Object} scope Parent scope.\r\n         * @return {!Interpreter.MyObject} New function.\r\n         */\r\n        Interpreter.prototype.createFunction = function (node, scope) {\r\n            var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n            func.parentScope = scope;\r\n            func.node = node;\r\n            this.setProperty(func, 'length', func.node['params'].length, Interpreter.READONLY_DESCRIPTOR);\r\n            return func;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new native function.\r\n         * @param {!Function} nativeFunc JavaScript function.\r\n         * @param {boolean=} opt_constructor If true, the function's\r\n         * prototype will have its constructor property set to the function.\r\n         * If false, the function cannot be called as a constructor (e.g. escape).\r\n         * Defaults to undefined.\r\n         * @return {!Interpreter.MyObject} New function.\r\n         */\r\n        Interpreter.prototype.createNativeFunction = function (nativeFunc, opt_constructor) {\r\n            var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n            func.nativeFunc = nativeFunc;\r\n            nativeFunc.id = this.functionCounter_++;\r\n            this.setProperty(func, 'length', nativeFunc.length, Interpreter.READONLY_DESCRIPTOR);\r\n            if (opt_constructor) {\r\n                this.setProperty(func.properties['prototype'], 'constructor', func, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            else if (opt_constructor === false) {\r\n                func.illegalConstructor = true;\r\n                this.setProperty(func, 'prototype', undefined);\r\n            }\r\n            return func;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new native asynchronous function.\r\n         * @param {!Function} asyncFunc JavaScript function.\r\n         * @return {!Interpreter.MyObject} New function.\r\n         */\r\n        Interpreter.prototype.createAsyncFunction = function (asyncFunc) {\r\n            var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n            func.asyncFunc = asyncFunc;\r\n            asyncFunc.id = this.functionCounter_++;\r\n            this.setProperty(func, 'length', asyncFunc.length, Interpreter.READONLY_DESCRIPTOR);\r\n            return func;\r\n        };\r\n        ;\r\n        /**\r\n         * Converts from a native JS object or value to a JS interpreter object.\r\n         * Can handle JSON-style values.\r\n         * @param {*} nativeObj The native JS object to be converted.\r\n         * @return {Interpreter.MyValue} The equivalent JS interpreter object.\r\n         */\r\n        Interpreter.prototype.nativeToPseudo = function (nativeObj) {\r\n            if (typeof nativeObj === 'boolean' ||\r\n                typeof nativeObj === 'number' ||\r\n                typeof nativeObj === 'string' ||\r\n                nativeObj === null || nativeObj === undefined) {\r\n                return nativeObj;\r\n            }\r\n            if (nativeObj instanceof RegExp) {\r\n                var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\r\n                this.populateRegExp(pseudoRegexp, nativeObj);\r\n                return pseudoRegexp;\r\n            }\r\n            if (nativeObj instanceof Function) {\r\n                var interpreter = this;\r\n                var wrapper = function () {\r\n                    return interpreter.nativeToPseudo(nativeObj.apply(interpreter, Array.prototype.slice.call(arguments)\r\n                        .map(function (i) {\r\n                        return interpreter.pseudoToNative(i);\r\n                    })));\r\n                };\r\n                return this.createNativeFunction(wrapper, undefined);\r\n            }\r\n            var pseudoObj;\r\n            if (Array.isArray(nativeObj)) {\r\n                pseudoObj = this.createObjectProto(this.ARRAY_PROTO);\r\n                for (var i = 0; i < nativeObj.length; i++) {\r\n                    if (i in nativeObj) {\r\n                        this.setProperty(pseudoObj, i, this.nativeToPseudo(nativeObj[i]));\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                pseudoObj = this.createObjectProto(this.OBJECT_PROTO);\r\n                for (var key in nativeObj) {\r\n                    this.setProperty(pseudoObj, key, this.nativeToPseudo(nativeObj[key]));\r\n                }\r\n            }\r\n            return pseudoObj;\r\n        };\r\n        ;\r\n        /**\r\n         * Converts from a JS interpreter object to native JS object.\r\n         * Can handle JSON-style values, plus cycles.\r\n         * @param {Interpreter.MyValue} pseudoObj The JS interpreter object to be\r\n         * converted.\r\n         * @param {Object=} opt_cycles Cycle detection (used in recursive calls).\r\n         * @return {*} The equivalent native JS object or value.\r\n         */\r\n        Interpreter.prototype.pseudoToNative = function (pseudoObj, opt_cycles) {\r\n            if (typeof pseudoObj === 'boolean' ||\r\n                typeof pseudoObj === 'number' ||\r\n                typeof pseudoObj === 'string' ||\r\n                pseudoObj === null || pseudoObj === undefined) {\r\n                return pseudoObj;\r\n            }\r\n            if (this.isa(pseudoObj, this.REGEXP)) {\r\n                return pseudoObj.data;\r\n            }\r\n            var cycles = opt_cycles || {\r\n                pseudo: [],\r\n                native: []\r\n            };\r\n            var i = cycles.pseudo.indexOf(pseudoObj);\r\n            if (i !== -1) {\r\n                return cycles.native[i];\r\n            }\r\n            cycles.pseudo.push(pseudoObj);\r\n            var nativeObj;\r\n            if (this.isa(pseudoObj, this.ARRAY)) {\r\n                nativeObj = [];\r\n                cycles.native.push(nativeObj);\r\n                var length = this.getProperty(pseudoObj, 'length');\r\n                for (var i = 0; i < length; i++) {\r\n                    if (this.hasProperty(pseudoObj, i)) {\r\n                        nativeObj[i] =\r\n                            this.pseudoToNative(this.getProperty(pseudoObj, i), cycles);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                nativeObj = {};\r\n                cycles.native.push(nativeObj);\r\n                var val;\r\n                for (var key in pseudoObj.properties) {\r\n                    val = pseudoObj.properties[key];\r\n                    nativeObj[key] = this.pseudoToNative(val, cycles);\r\n                }\r\n            }\r\n            cycles.pseudo.pop();\r\n            cycles.native.pop();\r\n            return nativeObj;\r\n        };\r\n        ;\r\n        /**\r\n         * Look up the prototype for this value.\r\n         * @param {Interpreter.MyValue} value Data object.\r\n         * @return {Interpreter.MyObject} Prototype object, null if none.\r\n         */\r\n        Interpreter.prototype.getPrototype = function (value) {\r\n            switch (typeof value) {\r\n                case 'number':\r\n                    return this.NUMBER.properties['prototype'];\r\n                case 'boolean':\r\n                    return this.BOOLEAN.properties['prototype'];\r\n                case 'string':\r\n                    return this.STRING.properties['prototype'];\r\n            }\r\n            if (value) {\r\n                return value.proto;\r\n            }\r\n            return null;\r\n        };\r\n        ;\r\n        /**\r\n         * Fetch a property value from a data object.\r\n         * @param {Interpreter.MyValue} obj Data object.\r\n         * @param {Interpreter.MyValue} name Name of property.\r\n         * @return {Interpreter.MyValue} Property value (may be undefined).\r\n         */\r\n        Interpreter.prototype.getProperty = function (obj, name) {\r\n            name = String(name);\r\n            if (obj === undefined || obj === null) {\r\n                this.throwException(this.TYPE_ERROR, \"Cannot read property '\" + name + \"' of \" + obj);\r\n            }\r\n            if (name === 'length') {\r\n                // Special cases for magic length property.\r\n                if (this.isa(obj, this.STRING)) {\r\n                    return String(obj).length;\r\n                }\r\n            }\r\n            else if (name.charCodeAt(0) < 0x40) {\r\n                // Might have numbers in there?\r\n                // Special cases for string array indexing\r\n                if (this.isa(obj, this.STRING)) {\r\n                    var n = Interpreter.legalArrayIndex(name);\r\n                    if (!isNaN(n) && n < String(obj).length) {\r\n                        return String(obj)[n];\r\n                    }\r\n                }\r\n            }\r\n            do {\r\n                var myObj = obj;\r\n                if (myObj.properties && name in myObj.properties) {\r\n                    var getter = myObj.getter[name];\r\n                    if (getter) {\r\n                        // Flag this function as being a getter and thus needing immediate\r\n                        // execution (rather than being the value of the property).\r\n                        getter.isGetter = true;\r\n                        return getter;\r\n                    }\r\n                    return myObj.properties[name];\r\n                }\r\n            } while ((obj = this.getPrototype(obj)));\r\n            return undefined;\r\n        };\r\n        ;\r\n        /**\r\n         * Does the named property exist on a data object.\r\n         * @param {Interpreter.MyValue} obj Data object.\r\n         * @param {Interpreter.MyValue} name Name of property.\r\n         * @return {boolean} True if property exists.\r\n         */\r\n        Interpreter.prototype.hasProperty = function (obj, name) {\r\n            if (!obj['isObject']) {\r\n                throw TypeError('Primitive data type has no properties');\r\n            }\r\n            name = String(name);\r\n            if (name === 'length' && this.isa(obj, this.STRING)) {\r\n                return true;\r\n            }\r\n            if (this.isa(obj, this.STRING)) {\r\n                var n = Interpreter.legalArrayIndex(name);\r\n                if (!isNaN(n) && n < String(obj).length) {\r\n                    return true;\r\n                }\r\n            }\r\n            do {\r\n                var myObj = obj;\r\n                if (myObj.properties && name in myObj.properties) {\r\n                    return true;\r\n                }\r\n            } while ((obj = this.getPrototype(obj)));\r\n            return false;\r\n        };\r\n        ;\r\n        /**\r\n         * Set a property value on a data object.\r\n         * @param {!Interpreter.MyObject} obj Data object.\r\n         * @param {Interpreter.MyValue} name Name of property.\r\n         * @param {Interpreter.MyValue|ReferenceError} value New property value.\r\n         *   Use ReferenceError if value is handled by descriptor instead.\r\n         * @param {Object=} opt_descriptor Optional descriptor object.\r\n         * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n         *     needs to be called, otherwise undefined.\r\n         */\r\n        Interpreter.prototype.setProperty = function (obj, name, value, opt_descriptor) {\r\n            name = String(name);\r\n            if (obj === undefined || obj === null) {\r\n                this.throwException(this.TYPE_ERROR, \"Cannot set property '\" + name + \"' of \" + obj);\r\n            }\r\n            if (opt_descriptor && ('get' in opt_descriptor || 'set' in opt_descriptor) &&\r\n                ('value' in opt_descriptor || 'writable' in opt_descriptor)) {\r\n                this.throwException(this.TYPE_ERROR, 'Invalid property descriptor. ' +\r\n                    'Cannot both specify accessors and a value or writable attribute');\r\n            }\r\n            var strict = !this.stateStack || this.getScope().strict;\r\n            if (!obj.isObject) {\r\n                if (strict) {\r\n                    this.throwException(this.TYPE_ERROR, \"Can't create property '\" + name +\r\n                        \"' on '\" + obj + \"'\");\r\n                }\r\n                return;\r\n            }\r\n            if (this.isa(obj, this.STRING)) {\r\n                var n = Interpreter.legalArrayIndex(name);\r\n                if (name === 'length' || (!isNaN(n) && n < String(obj).length)) {\r\n                    // Can't set length or letters on String objects.\r\n                    if (strict) {\r\n                        this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\r\n                            \"property '\" + name + \"' of String '\" + obj.data + \"'\");\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            if (obj.class === 'Array') {\r\n                // Arrays have a magic length variable that is bound to the elements.\r\n                var length = obj.properties.length;\r\n                var i;\r\n                if (name === 'length') {\r\n                    // Delete elements if length is smaller.\r\n                    value = Interpreter.legalArrayLength(value);\r\n                    if (isNaN(value)) {\r\n                        this.throwException(this.RANGE_ERROR, 'Invalid array length');\r\n                    }\r\n                    if (value < length) {\r\n                        for (i in obj.properties) {\r\n                            i = Interpreter.legalArrayIndex(i);\r\n                            if (!isNaN(i) && value <= i) {\r\n                                delete obj.properties[i];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else if (!isNaN(i = Interpreter.legalArrayIndex(name))) {\r\n                    // Increase length if this index is larger.\r\n                    obj.properties.length = Math.max(length, i + 1);\r\n                }\r\n            }\r\n            if (obj.preventExtensions && !(name in obj.properties)) {\r\n                if (strict) {\r\n                    this.throwException(this.TYPE_ERROR, \"Can't add property '\" + name +\r\n                        \"', object is not extensible\");\r\n                }\r\n                return;\r\n            }\r\n            if (opt_descriptor) {\r\n                // Define the property.\r\n                if ('get' in opt_descriptor) {\r\n                    if (opt_descriptor.get) {\r\n                        obj.getter[name] = opt_descriptor.get;\r\n                    }\r\n                    else {\r\n                        delete obj.getter[name];\r\n                    }\r\n                }\r\n                if ('set' in opt_descriptor) {\r\n                    if (opt_descriptor.set) {\r\n                        obj.setter[name] = opt_descriptor.set;\r\n                    }\r\n                    else {\r\n                        delete obj.setter[name];\r\n                    }\r\n                }\r\n                var descriptor = {};\r\n                if ('configurable' in opt_descriptor) {\r\n                    descriptor.configurable = opt_descriptor.configurable;\r\n                }\r\n                if ('enumerable' in opt_descriptor) {\r\n                    descriptor.enumerable = opt_descriptor.enumerable;\r\n                }\r\n                if ('writable' in opt_descriptor) {\r\n                    descriptor.writable = opt_descriptor.writable;\r\n                    delete obj.getter[name];\r\n                    delete obj.setter[name];\r\n                }\r\n                if ('value' in opt_descriptor) {\r\n                    descriptor.value = opt_descriptor.value;\r\n                    delete obj.getter[name];\r\n                    delete obj.setter[name];\r\n                }\r\n                else if (value !== ReferenceError) {\r\n                    descriptor.value = value;\r\n                    delete obj.getter[name];\r\n                    delete obj.setter[name];\r\n                }\r\n                try {\r\n                    Object.defineProperty(obj.properties, name, descriptor);\r\n                }\r\n                catch (e) {\r\n                    this.throwException(this.TYPE_ERROR, 'Cannot redefine property: ' + name);\r\n                }\r\n            }\r\n            else {\r\n                // Set the property.\r\n                if (value === ReferenceError) {\r\n                    throw ReferenceError('Value not specified.');\r\n                }\r\n                // Determine the parent (possibly self) where the property is defined.\r\n                var defObj = obj;\r\n                while (!(name in defObj.properties)) {\r\n                    defObj = this.getPrototype(defObj);\r\n                    if (!defObj) {\r\n                        // This is a new property.\r\n                        defObj = obj;\r\n                        break;\r\n                    }\r\n                }\r\n                if (defObj.setter && defObj.setter[name]) {\r\n                    return defObj.setter[name];\r\n                }\r\n                if (defObj.getter && defObj.getter[name]) {\r\n                    if (strict) {\r\n                        this.throwException(this.TYPE_ERROR, \"Cannot set property '\" + name +\r\n                            \"' of object '\" + obj + \"' which only has a getter\");\r\n                    }\r\n                }\r\n                else {\r\n                    // No setter, simple assignment.\r\n                    try {\r\n                        obj.properties[name] = value;\r\n                    }\r\n                    catch (e) {\r\n                        if (strict) {\r\n                            this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\r\n                                \"property '\" + name + \"' of object '\" + obj + \"'\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Convenience method for adding a native function as a non-enumerable property\r\n         * onto an object's prototype.\r\n         * @param {!Interpreter.MyObject} obj Data object.\r\n         * @param {Interpreter.MyValue} name Name of property.\r\n         * @param {!Function} wrapper Function object.\r\n         */\r\n        Interpreter.prototype.setNativeFunctionPrototype = function (obj, name, wrapper) {\r\n            this.setProperty(obj.properties['prototype'], name, this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n        };\r\n        ;\r\n        /**\r\n         * Returns the current scope from the stateStack.\r\n         * @return {!Interpreter.MyObject} Current scope dictionary.\r\n         */\r\n        Interpreter.prototype.getScope = function () {\r\n            var scope = this.stateStack[this.stateStack.length - 1].scope;\r\n            if (!scope) {\r\n                throw Error('No scope found.');\r\n            }\r\n            return scope;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new scope dictionary.\r\n         * @param {!Object} node AST node defining the scope container\r\n         *     (e.g. a function).\r\n         * @param {Interpreter.MyObject} parentScope Scope to link to.\r\n         * @return {!Interpreter.MyObject} New scope.\r\n         */\r\n        Interpreter.prototype.createScope = function (node, parentScope) {\r\n            var scope = this.createObjectProto(null);\r\n            scope.parentScope = parentScope;\r\n            if (!parentScope) {\r\n                this.initGlobalScope(scope);\r\n            }\r\n            this.populateScope_(node, scope);\r\n            // Determine if this scope starts with 'use strict'.\r\n            scope.strict = false;\r\n            if (parentScope && parentScope.strict) {\r\n                scope.strict = true;\r\n            }\r\n            else {\r\n                var firstNode = node['body'] && node['body'][0];\r\n                if (firstNode && firstNode.expression &&\r\n                    firstNode.expression['type'] === 'Literal' &&\r\n                    firstNode.expression.value === 'use strict') {\r\n                    scope.strict = true;\r\n                }\r\n            }\r\n            return scope;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new special scope dictionary. Similar to createScope(), but\r\n         * doesn't assume that the scope is for a function body.\r\n         * This is used for 'catch' clauses and 'with' statements.\r\n         * @param {!Interpreter.MyObject} parentScope Scope to link to.\r\n         * @param {Interpreter.MyObject=} opt_scope Optional object to transform into\r\n         *     scope.\r\n         * @return {!Interpreter.MyObject} New scope.\r\n         */\r\n        Interpreter.prototype.createSpecialScope = function (parentScope, opt_scope) {\r\n            if (!parentScope) {\r\n                throw Error('parentScope required');\r\n            }\r\n            var scope = opt_scope || this.createObjectProto(null);\r\n            scope.parentScope = parentScope;\r\n            scope.strict = parentScope.strict;\r\n            return scope;\r\n        };\r\n        ;\r\n        /**\r\n         * Retrieves a value from the scope chain.\r\n         * @param {string} name Name of variable.\r\n         * @return {Interpreter.MyValue} Any value.\r\n         *   May be flagged as being a getter and thus needing immediate execution\r\n         *   (rather than being the value of the property).\r\n         */\r\n        Interpreter.prototype.getValueFromScope = function (name) {\r\n            var scope = this.getScope();\r\n            while (scope && scope !== this.global) {\r\n                if (name in scope.properties) {\r\n                    return scope.properties[name];\r\n                }\r\n                scope = scope.parentScope;\r\n            }\r\n            // The root scope is also an object which has inherited properties and\r\n            // could also have getters.\r\n            if (scope === this.global && this.hasProperty(scope, name)) {\r\n                return this.getProperty(scope, name);\r\n            }\r\n            // Typeof operator is unique: it can safely look at non-defined variables.\r\n            var prevNode = this.stateStack[this.stateStack.length - 1].node;\r\n            if (prevNode['type'] === 'UnaryExpression' &&\r\n                prevNode['operator'] === 'typeof') {\r\n                return undefined;\r\n            }\r\n            this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\r\n        };\r\n        ;\r\n        /**\r\n         * Sets a value to the current scope.\r\n         * @param {string} name Name of variable.\r\n         * @param {Interpreter.MyValue} value Value.\r\n         * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n         *     needs to be called, otherwise undefined.\r\n         */\r\n        Interpreter.prototype.setValueToScope = function (name, value) {\r\n            var scope = this.getScope();\r\n            var strict = scope.strict;\r\n            while (scope && scope !== this.global) {\r\n                if (name in scope.properties) {\r\n                    scope.properties[name] = value;\r\n                    return undefined;\r\n                }\r\n                scope = scope.parentScope;\r\n            }\r\n            // The root scope is also an object which has readonly properties and\r\n            // could also have setters.\r\n            if (scope === this.global && (!strict || this.hasProperty(scope, name))) {\r\n                return this.setProperty(scope, name, value);\r\n            }\r\n            this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new scope for the given node.\r\n         * @param {!Object} node AST node (program or function).\r\n         * @param {!Interpreter.MyObject} scope Scope dictionary to populate.\r\n         * @private\r\n         */\r\n        Interpreter.prototype.populateScope_ = function (node, scope) {\r\n            if (node['type'] === 'VariableDeclaration') {\r\n                for (var i = 0; i < node['declarations'].length; i++) {\r\n                    this.setProperty(scope, node['declarations'][i]['id']['name'], undefined, Interpreter.VARIABLE_DESCRIPTOR);\r\n                }\r\n            }\r\n            else if (node['type'] === 'FunctionDeclaration') {\r\n                this.setProperty(scope, node['id']['name'], this.createFunction(node, scope), Interpreter.VARIABLE_DESCRIPTOR);\r\n                return; // Do not recurse into function.\r\n            }\r\n            else if (node['type'] === 'FunctionExpression') {\r\n                return; // Do not recurse into function.\r\n            }\r\n            else if (node['type'] === 'ExpressionStatement') {\r\n                return; // Expressions can't contain variable/function declarations.\r\n            }\r\n            var nodeClass = node['constructor'];\r\n            for (var name in node) {\r\n                var prop = node[name];\r\n                if (prop && typeof prop === 'object') {\r\n                    if (Array.isArray(prop)) {\r\n                        for (var i = 0; i < prop.length; i++) {\r\n                            if (prop[i] && prop[i].constructor === nodeClass) {\r\n                                this.populateScope_(prop[i], scope);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (prop.constructor === nodeClass) {\r\n                            this.populateScope_(prop, scope);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Remove start and end values from AST, or set start and end values to a\r\n         * constant value.  Used to remove highlighting from polyfills and to set\r\n         * highlighting in an eval to cover the entire eval expression.\r\n         * @param {!Object} node AST node.\r\n         * @param {number=} start Starting character of all nodes, or undefined.\r\n         * @param {number=} end Ending character of all nodes, or undefined.\r\n         * @private\r\n         */\r\n        Interpreter.prototype.stripLocations_ = function (node, start, end) {\r\n            if (start) {\r\n                node['start'] = start;\r\n            }\r\n            else {\r\n                delete node['start'];\r\n            }\r\n            if (end) {\r\n                node['end'] = end;\r\n            }\r\n            else {\r\n                delete node['end'];\r\n            }\r\n            for (var name in node) {\r\n                if (node.hasOwnProperty(name)) {\r\n                    var prop = node[name];\r\n                    if (prop && typeof prop === 'object') {\r\n                        this.stripLocations_(prop, start, end);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Is the current state directly being called with as a construction with 'new'.\r\n         * @return {boolean} True if 'new foo()', false if 'foo()'.\r\n         */\r\n        Interpreter.prototype.calledWithNew = function () {\r\n            return this.stateStack[this.stateStack.length - 1].isConstructor;\r\n        };\r\n        ;\r\n        /**\r\n         * Gets a value from the scope chain or from an object property.\r\n         * @param {!Array} ref Name of variable or object/propname tuple.\r\n         * @return {Interpreter.MyValue} Any value.\r\n         *   May be flagged as being a getter and thus needing immediate execution\r\n         *   (rather than being the value of the property).\r\n         */\r\n        Interpreter.prototype.getValue = function (ref) {\r\n            if (ref[0] === Interpreter.SCOPE_REFERENCE) {\r\n                // A null/varname variable lookup.\r\n                return this.getValueFromScope(ref[1]);\r\n            }\r\n            else {\r\n                // An obj/prop components tuple (foo.bar).\r\n                return this.getProperty(ref[0], ref[1]);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Sets a value to the scope chain or to an object property.\r\n         * @param {!Array} ref Name of variable or object/propname tuple.\r\n         * @param {Interpreter.MyValue} value Value.\r\n         * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n         *     needs to be called, otherwise undefined.\r\n         */\r\n        Interpreter.prototype.setValue = function (ref, value) {\r\n            if (ref[0] === Interpreter.SCOPE_REFERENCE) {\r\n                // A null/varname variable lookup.\r\n                return this.setValueToScope(ref[1], value);\r\n            }\r\n            else {\r\n                // An obj/prop components tuple (foo.bar).\r\n                return this.setProperty(ref[0], ref[1], value);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Throw an exception in the interpreter that can be handled by an\r\n         * interpreter try/catch statement.  If unhandled, a real exception will\r\n         * be thrown.  Can be called with either an error class and a message, or\r\n         * with an actual object to be thrown.\r\n         * @param {!Interpreter.MyObject} errorClass Type of error (if message is\r\n         *   provided) or the value to throw (if no message).\r\n         * @param {string=} opt_message Message being thrown.\r\n         */\r\n        Interpreter.prototype.throwException = function (errorClass, opt_message) {\r\n            if (opt_message === undefined) {\r\n                var error = errorClass; // This is a value to throw, not an error class.\r\n            }\r\n            else {\r\n                var error = this.createObject(errorClass);\r\n                this.setProperty(error, 'message', opt_message, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            this.executeException(error);\r\n            // Abort anything related to the current step.\r\n            throw Interpreter.STEP_ERROR;\r\n        };\r\n        ;\r\n        /**\r\n         * Throw an exception in the interpreter that can be handled by a\r\n         * interpreter try/catch statement.  If unhandled, a real exception will\r\n         * be thrown.\r\n         * @param {!Interpreter.MyObject} error Error object to execute.\r\n         */\r\n        Interpreter.prototype.executeException = function (error) {\r\n            // Search for a try statement.\r\n            var stateStack = this.stateStack.slice();\r\n            do {\r\n                this.stateStack.pop();\r\n                var state = this.stateStack[this.stateStack.length - 1];\r\n                if (state.node['type'] === 'TryStatement') {\r\n                    state.throwValue = error;\r\n                    return;\r\n                }\r\n            } while (state && state.node['type'] !== 'Program');\r\n            // Throw a real error.\r\n            var realError;\r\n            if (this.isa(error, this.ERROR)) {\r\n                var errorTable = {\r\n                    'EvalError': EvalError,\r\n                    'RangeError': RangeError,\r\n                    'ReferenceError': ReferenceError,\r\n                    'SyntaxError': SyntaxError,\r\n                    'TypeError': TypeError,\r\n                    'URIError': URIError\r\n                };\r\n                var name = this.getProperty(error, 'name').toString();\r\n                var message = this.getProperty(error, 'message').valueOf();\r\n                var type = errorTable[name] || Error;\r\n                realError = type(message);\r\n            }\r\n            else {\r\n                realError = String(error);\r\n            }\r\n            this.stateStack = stateStack; // recover the original state stack\r\n            throw realError;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a call to a getter function.\r\n         * @param {!Interpreter.MyObject} func Function to execute.\r\n         * @param {!Interpreter.MyObject|!Array} left\r\n         *     Name of variable or object/propname tuple.\r\n         * @private\r\n         */\r\n        Interpreter.prototype.createGetter_ = function (func, left) {\r\n            // Normally 'this' will be specified as the object component (o.x).\r\n            // Sometimes 'this' is explicitly provided (o).\r\n            var funcThis = Array.isArray(left) ? left[0] : left;\r\n            var node = new this.nodeConstructor();\r\n            node['type'] = 'CallExpression';\r\n            var state = new Interpreter.MyState(node, this.stateStack[this.stateStack.length - 1].scope);\r\n            state.doneCallee_ = true;\r\n            state.funcThis_ = funcThis;\r\n            state.func_ = func;\r\n            state.doneArgs_ = true;\r\n            state.arguments_ = [];\r\n            return state;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a call to a setter function.\r\n         * @param {!Interpreter.MyObject} func Function to execute.\r\n         * @param {!Interpreter.MyObject|!Array} left\r\n         *     Name of variable or object/propname tuple.\r\n         * @param {Interpreter.MyValue} value Value to set.\r\n         * @private\r\n         */\r\n        Interpreter.prototype.createSetter_ = function (func, left, value) {\r\n            // Normally 'this' will be specified as the object component (o.x).\r\n            // Sometimes 'this' is implicitly the global object (x).\r\n            var funcThis = Array.isArray(left) ? left[0] : this.global;\r\n            var node = new this.nodeConstructor();\r\n            node['type'] = 'CallExpression';\r\n            var state = new Interpreter.MyState(node, this.stateStack[this.stateStack.length - 1].scope);\r\n            state.doneCallee_ = true;\r\n            state.funcThis_ = funcThis;\r\n            state.func_ = func;\r\n            state.doneArgs_ = true;\r\n            state.arguments_ = [value];\r\n            return state;\r\n        };\r\n        ;\r\n        ///////////////////////////////////////////////////////////////////////////////\r\n        // Functions to handle each node type.\r\n        ///////////////////////////////////////////////////////////////////////////////\r\n        Interpreter.prototype.stepArrayExpression = function (stack, state, node) {\r\n            var elements = node['elements'];\r\n            var n = state.n_ || 0;\r\n            if (!state.array_) {\r\n                state.array_ = this.createObjectProto(this.ARRAY_PROTO);\r\n                state.array_.properties.length = elements.length;\r\n            }\r\n            else {\r\n                this.setProperty(state.array_, n, state.value);\r\n                n++;\r\n            }\r\n            while (n < elements.length) {\r\n                // Skip missing elements - they're not defined, not undefined.\r\n                if (elements[n]) {\r\n                    state.n_ = n;\r\n                    return new Interpreter.MyState(elements[n], state.scope);\r\n                }\r\n                n++;\r\n            }\r\n            stack.pop();\r\n            stack[stack.length - 1].value = state.array_;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepAssignmentExpression = function (stack, state, node) {\r\n            if (!state.doneLeft_) {\r\n                state.doneLeft_ = true;\r\n                var nextState = new Interpreter.MyState(node['left'], state.scope);\r\n                nextState.components = true;\r\n                return nextState;\r\n            }\r\n            if (!state.doneRight_) {\r\n                if (!state.leftReference_) {\r\n                    state.leftReference_ = state.value;\r\n                }\r\n                if (state.doneGetter_) {\r\n                    state.leftValue_ = state.value;\r\n                }\r\n                if (!state.doneGetter_ && node['operator'] !== '=') {\r\n                    var leftValue = this.getValue(state.leftReference_);\r\n                    state.leftValue_ = leftValue;\r\n                    if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\r\n                        // Clear the getter flag and call the getter function.\r\n                        leftValue.isGetter = false;\r\n                        state.doneGetter_ = true;\r\n                        var func = (leftValue);\r\n                        return this.createGetter_(func, state.leftReference_);\r\n                    }\r\n                }\r\n                state.doneRight_ = true;\r\n                return new Interpreter.MyState(node['right'], state.scope);\r\n            }\r\n            if (state.doneSetter_) {\r\n                // Return if setter function.\r\n                // Setter method on property has completed.\r\n                // Ignore its return value, and use the original set value instead.\r\n                stack.pop();\r\n                stack[stack.length - 1].value = state.doneSetter_;\r\n                return;\r\n            }\r\n            var value = state.leftValue_;\r\n            var rightValue = state.value;\r\n            switch (node['operator']) {\r\n                case '=':\r\n                    value = rightValue;\r\n                    break;\r\n                case '+=':\r\n                    value += rightValue;\r\n                    break;\r\n                case '-=':\r\n                    value -= rightValue;\r\n                    break;\r\n                case '*=':\r\n                    value *= rightValue;\r\n                    break;\r\n                case '/=':\r\n                    value /= rightValue;\r\n                    break;\r\n                case '%=':\r\n                    value %= rightValue;\r\n                    break;\r\n                case '<<=':\r\n                    value <<= rightValue;\r\n                    break;\r\n                case '>>=':\r\n                    value >>= rightValue;\r\n                    break;\r\n                case '>>>=':\r\n                    value >>>= rightValue;\r\n                    break;\r\n                case '&=':\r\n                    value &= rightValue;\r\n                    break;\r\n                case '^=':\r\n                    value ^= rightValue;\r\n                    break;\r\n                case '|=':\r\n                    value |= rightValue;\r\n                    break;\r\n                default:\r\n                    throw SyntaxError('Unknown assignment expression: ' + node['operator']);\r\n            }\r\n            var setter = this.setValue(state.leftReference_, value);\r\n            if (setter) {\r\n                state.doneSetter_ = value;\r\n                return this.createSetter_(setter, state.leftReference_, value);\r\n            }\r\n            // Return if no setter function.\r\n            stack.pop();\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepBinaryExpression = function (stack, state, node) {\r\n            if (!state.doneLeft_) {\r\n                state.doneLeft_ = true;\r\n                return new Interpreter.MyState(node['left'], state.scope);\r\n            }\r\n            if (!state.doneRight_) {\r\n                state.doneRight_ = true;\r\n                state.leftValue_ = state.value;\r\n                return new Interpreter.MyState(node['right'], state.scope);\r\n            }\r\n            stack.pop();\r\n            var leftValue = state.leftValue_;\r\n            var rightValue = state.value;\r\n            var value;\r\n            switch (node['operator']) {\r\n                case '==':\r\n                    value = leftValue == rightValue;\r\n                    break;\r\n                case '!=':\r\n                    value = leftValue != rightValue;\r\n                    break;\r\n                case '===':\r\n                    value = leftValue === rightValue;\r\n                    break;\r\n                case '!==':\r\n                    value = leftValue !== rightValue;\r\n                    break;\r\n                case '>':\r\n                    value = leftValue > rightValue;\r\n                    break;\r\n                case '>=':\r\n                    value = leftValue >= rightValue;\r\n                    break;\r\n                case '<':\r\n                    value = leftValue < rightValue;\r\n                    break;\r\n                case '<=':\r\n                    value = leftValue <= rightValue;\r\n                    break;\r\n                case '+':\r\n                    value = leftValue + rightValue;\r\n                    break;\r\n                case '-':\r\n                    value = leftValue - rightValue;\r\n                    break;\r\n                case '*':\r\n                    value = leftValue * rightValue;\r\n                    break;\r\n                case '/':\r\n                    value = leftValue / rightValue;\r\n                    break;\r\n                case '%':\r\n                    value = leftValue % rightValue;\r\n                    break;\r\n                case '&':\r\n                    value = leftValue & rightValue;\r\n                    break;\r\n                case '|':\r\n                    value = leftValue | rightValue;\r\n                    break;\r\n                case '^':\r\n                    value = leftValue ^ rightValue;\r\n                    break;\r\n                case '<<':\r\n                    value = leftValue << rightValue;\r\n                    break;\r\n                case '>>':\r\n                    value = leftValue >> rightValue;\r\n                    break;\r\n                case '>>>':\r\n                    value = leftValue >>> rightValue;\r\n                    break;\r\n                case 'in':\r\n                    if (!rightValue || !rightValue.isObject) {\r\n                        this.throwException(this.TYPE_ERROR, \"'in' expects an object, not '\" + rightValue + \"'\");\r\n                    }\r\n                    value = this.hasProperty(rightValue, leftValue);\r\n                    break;\r\n                case 'instanceof':\r\n                    if (!this.isa(rightValue, this.FUNCTION)) {\r\n                        this.throwException(this.TYPE_ERROR, 'Right-hand side of instanceof is not an object');\r\n                    }\r\n                    value = leftValue.isObject ? this.isa(leftValue, rightValue) : false;\r\n                    break;\r\n                default:\r\n                    throw SyntaxError('Unknown binary operator: ' + node['operator']);\r\n            }\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepBlockStatement = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var expression = node['body'][n];\r\n            if (expression) {\r\n                state.n_ = n + 1;\r\n                return new Interpreter.MyState(expression, state.scope);\r\n            }\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepBreakStatement = function (stack, state, node) {\r\n            stack.pop();\r\n            var label = null;\r\n            if (node['label']) {\r\n                label = node['label']['name'];\r\n            }\r\n            while (state &&\r\n                state.node['type'] !== 'CallExpression' &&\r\n                state.node['type'] !== 'NewExpression') {\r\n                if (label) {\r\n                    if (state.labels && state.labels.indexOf(label) !== -1) {\r\n                        return;\r\n                    }\r\n                }\r\n                else if (state.isLoop || state.isSwitch) {\r\n                    return;\r\n                }\r\n                state = stack.pop();\r\n            }\r\n            // Syntax error, do not allow this error to be trapped.\r\n            throw SyntaxError('Illegal break statement');\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepCallExpression = function (stack, state, node) {\r\n            if (!state.doneCallee_) {\r\n                state.doneCallee_ = 1;\r\n                // Components needed to determine value of 'this'.\r\n                var nextState = new Interpreter.MyState(node['callee'], state.scope);\r\n                nextState.components = true;\r\n                return nextState;\r\n            }\r\n            if (state.doneCallee_ === 1) {\r\n                // Determine value of the function.\r\n                state.doneCallee_ = 2;\r\n                var func = state.value;\r\n                if (Array.isArray(func)) {\r\n                    state.func_ = this.getValue(func);\r\n                    if (func[0] !== Interpreter.SCOPE_REFERENCE) {\r\n                        // Method function, 'this' is object (ignored if invoked as 'new').\r\n                        state.funcThis_ = func[0];\r\n                    }\r\n                    func = state.func_;\r\n                    if (func && typeof func === 'object' && func.isGetter) {\r\n                        // Clear the getter flag and call the getter function.\r\n                        func.isGetter = false;\r\n                        state.doneCallee_ = 1;\r\n                        return this.createGetter_(/** @type {!Interpreter.Object} */ (func), state.value);\r\n                    }\r\n                }\r\n                else {\r\n                    // Already evaluated function: (function(){...})();\r\n                    state.func_ = func;\r\n                }\r\n                state.arguments_ = [];\r\n                state.n_ = 0;\r\n            }\r\n            var func = state.func_;\r\n            if (!state.doneArgs_) {\r\n                if (state.n_ !== 0) {\r\n                    state.arguments_.push(state.value);\r\n                }\r\n                if (node['arguments'][state.n_]) {\r\n                    return new Interpreter.MyState(node['arguments'][state.n_++], state.scope);\r\n                }\r\n                // Determine value of 'this' in function.\r\n                if (node['type'] === 'NewExpression') {\r\n                    if (func.illegalConstructor) {\r\n                        // Illegal: new escape();\r\n                        this.throwException(this.TYPE_ERROR, func + ' is not a constructor');\r\n                    }\r\n                    // Constructor, 'this' is new object.\r\n                    state.funcThis_ = this.createObject(func);\r\n                    state.isConstructor = true;\r\n                }\r\n                else if (state.funcThis_ === undefined) {\r\n                    // Global function, 'this' is global object (or 'undefined' if strict).\r\n                    state.funcThis_ = state.scope.strict ? undefined : this.global;\r\n                }\r\n                state.doneArgs_ = true;\r\n            }\r\n            if (!state.doneExec_) {\r\n                state.doneExec_ = true;\r\n                if (!func || !func.isObject) {\r\n                    this.throwException(this.TYPE_ERROR, func + ' is not a function');\r\n                }\r\n                var funcNode = func.node;\r\n                if (funcNode) {\r\n                    var scope = this.createScope(funcNode['body'], func.parentScope);\r\n                    // Add all arguments.\r\n                    for (var i = 0; i < funcNode['params'].length; i++) {\r\n                        var paramName = funcNode['params'][i]['name'];\r\n                        var paramValue = state.arguments_.length > i ? state.arguments_[i] :\r\n                            undefined;\r\n                        this.setProperty(scope, paramName, paramValue);\r\n                    }\r\n                    // Build arguments variable.\r\n                    var argsList = this.createObjectProto(this.ARRAY_PROTO);\r\n                    for (var i = 0; i < state.arguments_.length; i++) {\r\n                        this.setProperty(argsList, i, state.arguments_[i]);\r\n                    }\r\n                    this.setProperty(scope, 'arguments', argsList);\r\n                    // Add the function's name (var x = function foo(){};)\r\n                    var name = funcNode['id'] && funcNode['id']['name'];\r\n                    if (name) {\r\n                        this.setProperty(scope, name, func);\r\n                    }\r\n                    this.setProperty(scope, 'this', state.funcThis_, Interpreter.READONLY_DESCRIPTOR);\r\n                    state.value = undefined; // Default value if no explicit return.\r\n                    return new Interpreter.MyState(funcNode['body'], scope);\r\n                }\r\n                else if (func.eval) {\r\n                    var code = state.arguments_[0];\r\n                    if (typeof code !== 'string') {\r\n                        // JS does not parse String objects:\r\n                        // eval(new String('1 + 1')) -> '1 + 1'\r\n                        state.value = code;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            var ast = Interpreter.acorn.parse(code.toString(), Interpreter.PARSE_OPTIONS);\r\n                        }\r\n                        catch (e) {\r\n                            // Acorn threw a SyntaxError.  Rethrow as a trappable error.\r\n                            this.throwException(this.SYNTAX_ERROR, 'Invalid code: ' + e.message);\r\n                        }\r\n                        var evalNode = new this.nodeConstructor();\r\n                        evalNode['type'] = 'EvalProgram_';\r\n                        evalNode['body'] = ast['body'];\r\n                        this.stripLocations_(evalNode, node['start'], node['end']);\r\n                        // Update current scope with definitions in eval().\r\n                        var scope = state.scope;\r\n                        if (scope.strict) {\r\n                            // Strict mode get its own scope in eval.\r\n                            scope = this.createScope(ast, scope);\r\n                        }\r\n                        else {\r\n                            // Non-strict mode pollutes the current scope.\r\n                            this.populateScope_(ast, scope);\r\n                        }\r\n                        this.value = undefined; // Default value if no code.\r\n                        return new Interpreter.MyState(evalNode, scope);\r\n                    }\r\n                }\r\n                else if (func.nativeFunc) {\r\n                    state.value = func.nativeFunc.apply(state.funcThis_, state.arguments_);\r\n                }\r\n                else if (func.asyncFunc) {\r\n                    var thisInterpreter = this;\r\n                    var callback = function (value) {\r\n                        state.value = value;\r\n                        thisInterpreter.paused_ = false;\r\n                    };\r\n                    var argsWithCallback = state.arguments_.concat(callback);\r\n                    this.paused_ = true;\r\n                    func.asyncFunc.apply(state.funcThis_, argsWithCallback);\r\n                    return;\r\n                }\r\n                else {\r\n                    /* A child of a function is a function but is not callable.  For example:\r\n                    var F = function() {};\r\n                    F.prototype = escape;\r\n                    var f = new F();\r\n                    f();\r\n                    */\r\n                    this.throwException(this.TYPE_ERROR, func.class + ' is not a function');\r\n                }\r\n            }\r\n            else {\r\n                // Execution complete.  Put the return value on the stack.\r\n                stack.pop();\r\n                if (state.isConstructor && typeof state.value !== 'object') {\r\n                    stack[stack.length - 1].value = state.funcThis_;\r\n                }\r\n                else {\r\n                    stack[stack.length - 1].value = state.value;\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepCatchClause = function (stack, state, node) {\r\n            if (!state.done_) {\r\n                state.done_ = true;\r\n                // Create an empty scope.\r\n                var scope = this.createSpecialScope(state.scope);\r\n                // Add the argument.\r\n                this.setProperty(scope, node['param']['name'], state.throwValue);\r\n                // Execute catch clause.\r\n                return new Interpreter.MyState(node['body'], scope);\r\n            }\r\n            else {\r\n                stack.pop();\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepConditionalExpression = function (stack, state, node) {\r\n            var mode = state.mode_ || 0;\r\n            if (mode === 0) {\r\n                state.mode_ = 1;\r\n                return new Interpreter.MyState(node['test'], state.scope);\r\n            }\r\n            if (mode === 1) {\r\n                state.mode_ = 2;\r\n                var value = Boolean(state.value);\r\n                if (value && node['consequent']) {\r\n                    // Execute 'if' block.\r\n                    return new Interpreter.MyState(node['consequent'], state.scope);\r\n                }\r\n                else if (!value && node['alternate']) {\r\n                    // Execute 'else' block.\r\n                    return new Interpreter.MyState(node['alternate'], state.scope);\r\n                }\r\n                // eval('1;if(false){2}') -> undefined\r\n                this.value = undefined;\r\n            }\r\n            stack.pop();\r\n            if (node['type'] === 'ConditionalExpression') {\r\n                stack[stack.length - 1].value = state.value;\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepContinueStatement = function (stack, state, node) {\r\n            stack.pop();\r\n            var label = null;\r\n            if (node['label']) {\r\n                label = node['label']['name'];\r\n            }\r\n            state = stack[stack.length - 1];\r\n            while (state &&\r\n                state.node['type'] !== 'CallExpression' &&\r\n                state.node['type'] !== 'NewExpression') {\r\n                if (state.isLoop) {\r\n                    if (!label || (state.labels && state.labels.indexOf(label) !== -1)) {\r\n                        return;\r\n                    }\r\n                }\r\n                stack.pop();\r\n                state = stack[stack.length - 1];\r\n            }\r\n            // Syntax error, do not allow this error to be trapped.\r\n            throw SyntaxError('Illegal continue statement');\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepDebuggerStatement = function (stack, state, node) {\r\n            // Do nothing.  May be overridden by developers.\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepDoWhileStatement = function (stack, state, node) {\r\n            if (node['type'] === 'DoWhileStatement' && state.test_ === undefined) {\r\n                // First iteration of do/while executes without checking test.\r\n                state.value = true;\r\n                state.test_ = true;\r\n            }\r\n            if (!state.test_) {\r\n                state.test_ = true;\r\n                return new Interpreter.MyState(node['test'], state.scope);\r\n            }\r\n            if (!state.value) {\r\n                stack.pop();\r\n            }\r\n            else if (node['body']) {\r\n                state.test_ = false;\r\n                state.isLoop = true;\r\n                return new Interpreter.MyState(node['body'], state.scope);\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepEmptyStatement = function (stack, state, node) {\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepEvalProgram_ = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var expression = node['body'][n];\r\n            if (expression) {\r\n                state.n_ = n + 1;\r\n                return new Interpreter.MyState(expression, state.scope);\r\n            }\r\n            stack.pop();\r\n            stack[stack.length - 1].value = this.value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepExpressionStatement = function (stack, state, node) {\r\n            if (!state.done_) {\r\n                state.done_ = true;\r\n                return new Interpreter.MyState(node['expression'], state.scope);\r\n            }\r\n            stack.pop();\r\n            // Save this value to interpreter.value for use as a return value if\r\n            // this code is inside an eval function.\r\n            this.value = state.value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepForInStatement = function (stack, state, node) {\r\n            // First, initialize a variable if exists.  Only do so once, ever.\r\n            if (!state.doneInit_) {\r\n                state.doneInit_ = true;\r\n                if (node['left']['declarations'] &&\r\n                    node['left']['declarations'][0]['init']) {\r\n                    if (state.scope.strict) {\r\n                        this.throwException(this.SYNTAX_ERROR, 'for-in loop variable declaration may not have an initializer.');\r\n                    }\r\n                    // Variable initialization: for (var x = 4 in y)\r\n                    return new Interpreter.MyState(node['left'], state.scope);\r\n                }\r\n            }\r\n            // Second, look up the object.  Only do so once, ever.\r\n            if (!state.doneObject_) {\r\n                state.doneObject_ = true;\r\n                if (!state.variable_) {\r\n                    state.variable_ = state.value;\r\n                }\r\n                return new Interpreter.MyState(node['right'], state.scope);\r\n            }\r\n            if (!state.isLoop) {\r\n                // First iteration.\r\n                state.isLoop = true;\r\n                state.object_ = state.value;\r\n                state.visited_ = Object.create(null);\r\n            }\r\n            // Third, find the property name for this iteration.\r\n            if (state.name_ === undefined) {\r\n                done: do {\r\n                    if (state.object_ && state.object_.isObject) {\r\n                        if (!state.props_) {\r\n                            state.props_ = Object.getOwnPropertyNames(state.object_.properties);\r\n                        }\r\n                        do {\r\n                            var prop = state.props_.shift();\r\n                        } while (prop && (state.visited_[prop] ||\r\n                            !Object.prototype.hasOwnProperty.call(state.object_.properties, prop)));\r\n                        if (prop) {\r\n                            state.visited_[prop] = true;\r\n                            if (Object.prototype.propertyIsEnumerable.call(state.object_.properties, prop)) {\r\n                                state.name_ = prop;\r\n                                break done;\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (state.object_ !== null) {\r\n                        if (!state.props_) {\r\n                            state.props_ = Object.getOwnPropertyNames(state.object_);\r\n                        }\r\n                        do {\r\n                            var prop = state.props_.shift();\r\n                        } while (prop && state.visited_[prop]);\r\n                        if (prop) {\r\n                            state.visited_[prop] = true;\r\n                            state.name_ = prop;\r\n                            break done;\r\n                        }\r\n                    }\r\n                    state.object_ = this.getPrototype(state.object_);\r\n                    state.props_ = null;\r\n                } while (state.object_ !== null);\r\n                if (state.object_ === null) {\r\n                    // Done, exit loop.\r\n                    stack.pop();\r\n                    return;\r\n                }\r\n            }\r\n            // Fourth, find the variable\r\n            if (!state.doneVariable_) {\r\n                state.doneVariable_ = true;\r\n                var left = node['left'];\r\n                if (left['type'] === 'VariableDeclaration') {\r\n                    // Inline variable declaration: for (var x in y)\r\n                    state.variable_ =\r\n                        [Interpreter.SCOPE_REFERENCE, left['declarations'][0]['id']['name']];\r\n                }\r\n                else {\r\n                    // Arbitrary left side: for (foo().bar in y)\r\n                    state.variable_ = null;\r\n                    var nextState = new Interpreter.MyState(left, state.scope);\r\n                    nextState.components = true;\r\n                    return nextState;\r\n                }\r\n            }\r\n            if (!state.variable_) {\r\n                state.variable_ = state.value;\r\n            }\r\n            // Fifth, set the variable.\r\n            if (!state.doneSetter_) {\r\n                state.doneSetter_ = true;\r\n                var value = state.name_;\r\n                var setter = this.setValue(state.variable_, value);\r\n                if (setter) {\r\n                    return this.createSetter_(setter, state.variable_, value);\r\n                }\r\n            }\r\n            // Next step will be step three.\r\n            state.name_ = undefined;\r\n            // Reevaluate the variable since it could be a setter on the global object.\r\n            state.doneVariable_ = false;\r\n            state.doneSetter_ = false;\r\n            // Sixth and finally, execute the body if there was one.  this.\r\n            if (node['body']) {\r\n                return new Interpreter.MyState(node['body'], state.scope);\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepForStatement = function (stack, state, node) {\r\n            var mode = state.mode_ || 0;\r\n            if (mode === 0) {\r\n                state.mode_ = 1;\r\n                if (node['init']) {\r\n                    return new Interpreter.MyState(node['init'], state.scope);\r\n                }\r\n            }\r\n            else if (mode === 1) {\r\n                state.mode_ = 2;\r\n                if (node['test']) {\r\n                    return new Interpreter.MyState(node['test'], state.scope);\r\n                }\r\n            }\r\n            else if (mode === 2) {\r\n                state.mode_ = 3;\r\n                if (node['test'] && !state.value) {\r\n                    // Done, exit loop.\r\n                    stack.pop();\r\n                }\r\n                else {\r\n                    state.isLoop = true;\r\n                    return new Interpreter.MyState(node['body'], state.scope);\r\n                }\r\n            }\r\n            else if (mode === 3) {\r\n                state.mode_ = 1;\r\n                if (node['update']) {\r\n                    return new Interpreter.MyState(node['update'], state.scope);\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepFunctionDeclaration = function (stack, state, node) {\r\n            // This was found and handled when the scope was populated.\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepFunctionExpression = function (stack, state, node) {\r\n            stack.pop();\r\n            stack[stack.length - 1].value = this.createFunction(node, state.scope);\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepIdentifier = function (stack, state, node) {\r\n            stack.pop();\r\n            if (state.components) {\r\n                stack[stack.length - 1].value = [Interpreter.SCOPE_REFERENCE, node['name']];\r\n                return;\r\n            }\r\n            var value = this.getValueFromScope(node['name']);\r\n            // An identifier could be a getter if it's a property on the global object.\r\n            if (value && typeof value === 'object' && value.isGetter) {\r\n                // Clear the getter flag and call the getter function.\r\n                value.isGetter = false;\r\n                var scope = state.scope;\r\n                while (!this.hasProperty(scope, node['name'])) {\r\n                    scope = scope.parentScope;\r\n                }\r\n                var func = (value);\r\n                return this.createGetter_(func, this.global);\r\n            }\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepIfStatement = function (stack, state, node) {\r\n            return this.stepConditionalExpression(stack, state, node);\r\n        };\r\n        Interpreter.prototype.stepLabeledStatement = function (stack, state, node) {\r\n            // No need to hit this node again on the way back up the stack.\r\n            stack.pop();\r\n            // Note that a statement might have multiple labels.\r\n            var labels = state.labels || [];\r\n            labels.push(node['label']['name']);\r\n            var nextState = new Interpreter.MyState(node['body'], state.scope);\r\n            nextState.labels = labels;\r\n            return nextState;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepLiteral = function (stack, state, node) {\r\n            stack.pop();\r\n            var value = node['value'];\r\n            if (value instanceof RegExp) {\r\n                var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\r\n                this.populateRegExp(pseudoRegexp, value);\r\n                value = pseudoRegexp;\r\n            }\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepLogicalExpression = function (stack, state, node) {\r\n            if (node['operator'] !== '&&' && node['operator'] !== '||') {\r\n                throw SyntaxError('Unknown logical operator: ' + node['operator']);\r\n            }\r\n            if (!state.doneLeft_) {\r\n                state.doneLeft_ = true;\r\n                return new Interpreter.MyState(node['left'], state.scope);\r\n            }\r\n            if (!state.doneRight_) {\r\n                if ((node['operator'] === '&&' && !state.value) ||\r\n                    (node['operator'] === '||' && state.value)) {\r\n                    // Shortcut evaluation.\r\n                    stack.pop();\r\n                    stack[stack.length - 1].value = state.value;\r\n                }\r\n                else {\r\n                    state.doneRight_ = true;\r\n                    return new Interpreter.MyState(node['right'], state.scope);\r\n                }\r\n            }\r\n            else {\r\n                stack.pop();\r\n                stack[stack.length - 1].value = state.value;\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepMemberExpression = function (stack, state, node) {\r\n            if (!state.doneObject_) {\r\n                state.doneObject_ = true;\r\n                return new Interpreter.MyState(node['object'], state.scope);\r\n            }\r\n            var propName;\r\n            if (!node['computed']) {\r\n                state.object_ = state.value;\r\n                // obj.foo -- Just access 'foo' directly.\r\n                propName = node['property']['name'];\r\n            }\r\n            else if (!state.doneProperty_) {\r\n                state.object_ = state.value;\r\n                // obj[foo] -- Compute value of 'foo'.\r\n                state.doneProperty_ = true;\r\n                return new Interpreter.MyState(node['property'], state.scope);\r\n            }\r\n            else {\r\n                propName = state.value;\r\n            }\r\n            stack.pop();\r\n            if (state.components) {\r\n                stack[stack.length - 1].value = [state.object_, propName];\r\n            }\r\n            else {\r\n                var value = this.getProperty(state.object_, propName);\r\n                if (value && typeof value === 'object' && value.isGetter) {\r\n                    // Clear the getter flag and call the getter function.\r\n                    value.isGetter = false;\r\n                    var func = (value);\r\n                    return this.createGetter_(func, state.object_);\r\n                }\r\n                stack[stack.length - 1].value = value;\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepNewExpression = function (stack, state, node) {\r\n            return this.stepCallExpression(stack, state, node);\r\n        };\r\n        Interpreter.prototype.stepObjectExpression = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var property = node['properties'][n];\r\n            if (!state.object_) {\r\n                // First execution.\r\n                state.object_ = this.createObjectProto(this.OBJECT_PROTO);\r\n                state.properties_ = Object.create(null);\r\n            }\r\n            else {\r\n                // Determine property name.\r\n                var key = property['key'];\r\n                if (key['type'] === 'Identifier') {\r\n                    var propName = key['name'];\r\n                }\r\n                else if (key['type'] === 'Literal') {\r\n                    var propName = key['value'];\r\n                }\r\n                else {\r\n                    throw SyntaxError('Unknown object structure: ' + key['type']);\r\n                }\r\n                // Set the property computed in the previous execution.\r\n                if (!state.properties_[propName]) {\r\n                    // Create temp object to collect value, getter, and/or setter.\r\n                    state.properties_[propName] = {};\r\n                }\r\n                state.properties_[propName][property['kind']] = state.value;\r\n                state.n_ = ++n;\r\n                property = node['properties'][n];\r\n            }\r\n            if (property) {\r\n                return new Interpreter.MyState(property['value'], state.scope);\r\n            }\r\n            for (var key in state.properties_) {\r\n                var kinds = state.properties_[key];\r\n                if ('get' in kinds || 'set' in kinds) {\r\n                    // Set a property with a getter or setter.\r\n                    var descriptor = {\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        get: kinds['get'],\r\n                        set: kinds['set']\r\n                    };\r\n                    this.setProperty(state.object_, key, null, descriptor);\r\n                }\r\n                else {\r\n                    // Set a normal property with a value.\r\n                    this.setProperty(state.object_, key, kinds['init']);\r\n                }\r\n            }\r\n            stack.pop();\r\n            stack[stack.length - 1].value = state.object_;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepProgram = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var expression = node['body'][n];\r\n            if (expression) {\r\n                state.done = false;\r\n                state.n_ = n + 1;\r\n                return new Interpreter.MyState(expression, state.scope);\r\n            }\r\n            state.done = true;\r\n            // Don't pop the stateStack.\r\n            // Leave the root scope on the tree in case the program is appended to.\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepReturnStatement = function (stack, state, node) {\r\n            if (node['argument'] && !state.done_) {\r\n                state.done_ = true;\r\n                return new Interpreter.MyState(node['argument'], state.scope);\r\n            }\r\n            var value = state.value;\r\n            var i = stack.length - 1;\r\n            state = stack[i];\r\n            while (state.node['type'] !== 'CallExpression' &&\r\n                state.node['type'] !== 'NewExpression') {\r\n                if (state.node['type'] !== 'TryStatement') {\r\n                    stack.splice(i, 1);\r\n                }\r\n                i--;\r\n                if (i < 0) {\r\n                    // Syntax error, do not allow this error to be trapped.\r\n                    throw SyntaxError('Illegal return statement');\r\n                }\r\n                state = stack[i];\r\n            }\r\n            state.value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepSequenceExpression = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var expression = node['expressions'][n];\r\n            if (expression) {\r\n                state.n_ = n + 1;\r\n                return new Interpreter.MyState(expression, state.scope);\r\n            }\r\n            stack.pop();\r\n            stack[stack.length - 1].value = state.value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepSwitchStatement = function (stack, state, node) {\r\n            if (!state.test_) {\r\n                state.test_ = 1;\r\n                return new Interpreter.MyState(node['discriminant'], state.scope);\r\n            }\r\n            if (state.test_ === 1) {\r\n                state.test_ = 2;\r\n                // Preserve switch value between case tests.\r\n                state.switchValue_ = state.value;\r\n            }\r\n            while (true) {\r\n                var index = state.index_ || 0;\r\n                var switchCase = node['cases'][index];\r\n                if (!state.matched_ && switchCase && !switchCase['test']) {\r\n                    // Test on the default case is null.\r\n                    // Bypass (but store) the default case, and get back to it later.\r\n                    state.defaultCase_ = index;\r\n                    state.index_ = index + 1;\r\n                    continue;\r\n                }\r\n                if (!switchCase && !state.matched_ && state.defaultCase_) {\r\n                    // Ran through all cases, no match.  Jump to the default.\r\n                    state.matched_ = true;\r\n                    state.index_ = state.defaultCase_;\r\n                    continue;\r\n                }\r\n                if (switchCase) {\r\n                    if (!state.matched_ && !state.tested_ && switchCase['test']) {\r\n                        state.tested_ = true;\r\n                        return new Interpreter.MyState(switchCase['test'], state.scope);\r\n                    }\r\n                    if (state.matched_ || state.value === state.switchValue_) {\r\n                        state.matched_ = true;\r\n                        var n = state.n_ || 0;\r\n                        if (switchCase['consequent'][n]) {\r\n                            state.isSwitch = true;\r\n                            state.n_ = n + 1;\r\n                            return new Interpreter.MyState(switchCase['consequent'][n], state.scope);\r\n                        }\r\n                    }\r\n                    // Move on to next case.\r\n                    state.tested_ = false;\r\n                    state.n_ = 0;\r\n                    state.index_ = index + 1;\r\n                }\r\n                else {\r\n                    stack.pop();\r\n                    return;\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepThisExpression = function (stack, state, node) {\r\n            stack.pop();\r\n            stack[stack.length - 1].value = this.getValueFromScope('this');\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepThrowStatement = function (stack, state, node) {\r\n            if (!state.done_) {\r\n                state.done_ = true;\r\n                return new Interpreter.MyState(node['argument'], state.scope);\r\n            }\r\n            else {\r\n                this.throwException(state.value);\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepTryStatement = function (stack, state, node) {\r\n            if (!state.doneBlock_) {\r\n                state.doneBlock_ = true;\r\n                return new Interpreter.MyState(node['block'], state.scope);\r\n            }\r\n            if (state.throwValue && !state.doneHandler_ && node['handler']) {\r\n                state.doneHandler_ = true;\r\n                var nextState = new Interpreter.MyState(node['handler'], state.scope);\r\n                nextState.throwValue = state.throwValue;\r\n                state.throwValue = null; // This error has been handled, don't rethrow.\r\n                return nextState;\r\n            }\r\n            if (!state.doneFinalizer_ && node['finalizer']) {\r\n                state.doneFinalizer_ = true;\r\n                return new Interpreter.MyState(node['finalizer'], state.scope);\r\n            }\r\n            if (state.throwValue) {\r\n                // There was no catch handler, or the catch/finally threw an error.\r\n                // Throw the error up to a higher try.\r\n                this.executeException(state.throwValue);\r\n            }\r\n            else {\r\n                stack.pop();\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepUnaryExpression = function (stack, state, node) {\r\n            if (!state.done_) {\r\n                state.done_ = true;\r\n                var nextState = new Interpreter.MyState(node['argument'], state.scope);\r\n                nextState.components = node['operator'] === 'delete';\r\n                return nextState;\r\n            }\r\n            stack.pop();\r\n            var value = state.value;\r\n            if (node['operator'] === '-') {\r\n                value = -value;\r\n            }\r\n            else if (node['operator'] === '+') {\r\n                value = +value;\r\n            }\r\n            else if (node['operator'] === '!') {\r\n                value = !value;\r\n            }\r\n            else if (node['operator'] === '~') {\r\n                value = ~value;\r\n            }\r\n            else if (node['operator'] === 'delete') {\r\n                var result = true;\r\n                // If value is not an array, then it is a primitive, or some other value.\r\n                // If so, skip the delete and return true.\r\n                if (Array.isArray(value)) {\r\n                    var obj = value[0];\r\n                    if (obj === Interpreter.SCOPE_REFERENCE) {\r\n                        // 'delete foo;' is the same as 'delete window.foo'.\r\n                        obj = state.scope;\r\n                    }\r\n                    var name = String(value[1]);\r\n                    try {\r\n                        delete obj.properties[name];\r\n                    }\r\n                    catch (e) {\r\n                        if (state.scope.strict) {\r\n                            this.throwException(this.TYPE_ERROR, \"Cannot delete property '\" +\r\n                                name + \"' of '\" + obj + \"'\");\r\n                        }\r\n                        else {\r\n                            result = false;\r\n                        }\r\n                    }\r\n                }\r\n                value = result;\r\n            }\r\n            else if (node['operator'] === 'typeof') {\r\n                value = (value && value.class === 'Function') ? 'function' : typeof value;\r\n            }\r\n            else if (node['operator'] === 'void') {\r\n                value = undefined;\r\n            }\r\n            else {\r\n                throw SyntaxError('Unknown unary operator: ' + node['operator']);\r\n            }\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepUpdateExpression = function (stack, state, node) {\r\n            if (!state.doneLeft_) {\r\n                state.doneLeft_ = true;\r\n                var nextState = new Interpreter.MyState(node['argument'], state.scope);\r\n                nextState.components = true;\r\n                return nextState;\r\n            }\r\n            if (!state.leftSide_) {\r\n                state.leftSide_ = state.value;\r\n            }\r\n            if (state.doneGetter_) {\r\n                state.leftValue_ = state.value;\r\n            }\r\n            if (!state.doneGetter_) {\r\n                var leftValue = this.getValue(state.leftSide_);\r\n                state.leftValue_ = leftValue;\r\n                if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\r\n                    // Clear the getter flag and call the getter function.\r\n                    leftValue.isGetter = false;\r\n                    state.doneGetter_ = true;\r\n                    var func = (leftValue);\r\n                    return this.createGetter_(func, state.leftSide_);\r\n                }\r\n            }\r\n            if (state.doneSetter_) {\r\n                // Return if setter function.\r\n                // Setter method on property has completed.\r\n                // Ignore its return value, and use the original set value instead.\r\n                stack.pop();\r\n                stack[stack.length - 1].value = state.doneSetter_;\r\n                return;\r\n            }\r\n            leftValue = Number(state.leftValue_);\r\n            var changeValue;\r\n            if (node['operator'] === '++') {\r\n                changeValue = leftValue + 1;\r\n            }\r\n            else if (node['operator'] === '--') {\r\n                changeValue = leftValue - 1;\r\n            }\r\n            else {\r\n                throw SyntaxError('Unknown update expression: ' + node['operator']);\r\n            }\r\n            var returnValue = node['prefix'] ? changeValue : leftValue;\r\n            var setter = this.setValue(state.leftSide_, changeValue);\r\n            if (setter) {\r\n                state.doneSetter_ = returnValue;\r\n                return this.createSetter_(setter, state.leftSide_, changeValue);\r\n            }\r\n            // Return if no setter function.\r\n            stack.pop();\r\n            stack[stack.length - 1].value = returnValue;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepVariableDeclaration = function (stack, state, node) {\r\n            var declarations = node['declarations'];\r\n            var n = state.n_ || 0;\r\n            var declarationNode = declarations[n];\r\n            if (state.init_ && declarationNode) {\r\n                // This setValue call never needs to deal with calling a setter function.\r\n                // Note that this is setting the init value, not defining the variable.\r\n                // Variable definition is done when scope is populated.\r\n                this.setValueToScope(declarationNode['id']['name'], state.value);\r\n                state.init_ = false;\r\n                declarationNode = declarations[++n];\r\n            }\r\n            while (declarationNode) {\r\n                // Skip any declarations that are not initialized.  They have already\r\n                // been defined as undefined in populateScope_.\r\n                if (declarationNode['init']) {\r\n                    state.n_ = n;\r\n                    state.init_ = true;\r\n                    return new Interpreter.MyState(declarationNode['init'], state.scope);\r\n                }\r\n                declarationNode = declarations[++n];\r\n            }\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepWithStatement = function (stack, state, node) {\r\n            if (!state.doneObject_) {\r\n                state.doneObject_ = true;\r\n                return new Interpreter.MyState(node['object'], state.scope);\r\n            }\r\n            else if (!state.doneBody_) {\r\n                state.doneBody_ = true;\r\n                var scope = this.createSpecialScope(state.scope, state.value);\r\n                return new Interpreter.MyState(node['body'], scope);\r\n            }\r\n            else {\r\n                stack.pop();\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepWhileStatement = function (stack, state, node) {\r\n            return this.stepDoWhileStatement(stack, state, node);\r\n        };\r\n        /**\r\n         * @const {!Object} Configuration used for all Acorn parsing.\r\n         */\r\n        Interpreter.PARSE_OPTIONS = {\r\n            ecmaVersion: 5\r\n        };\r\n        /**\r\n         * Property descriptor of readonly properties.\r\n         */\r\n        Interpreter.READONLY_DESCRIPTOR = {\r\n            configurable: true,\r\n            enumerable: true,\r\n            writable: false\r\n        };\r\n        /**\r\n         * Property descriptor of non-enumerable properties.\r\n         */\r\n        Interpreter.NONENUMERABLE_DESCRIPTOR = {\r\n            configurable: true,\r\n            enumerable: false,\r\n            writable: true\r\n        };\r\n        /**\r\n         * Property descriptor of readonly, non-enumerable properties.\r\n         */\r\n        Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR = {\r\n            configurable: true,\r\n            enumerable: false,\r\n            writable: false\r\n        };\r\n        /**\r\n         * Property descriptor of variables.\r\n         */\r\n        Interpreter.VARIABLE_DESCRIPTOR = {\r\n            configurable: false,\r\n            enumerable: true,\r\n            writable: true\r\n        };\r\n        /**\r\n         * Unique symbol for indicating that a step has encountered an error, has\r\n         * added it to the stack, and will be thrown within the user's program.\r\n         * When STEP_ERROR is thrown in the JS-Interpreter, the error can be ignored.\r\n         */\r\n        Interpreter.STEP_ERROR = {};\r\n        /**\r\n         * Unique symbol for indicating that a reference is a variable on the scope,\r\n         * not an object property.\r\n         */\r\n        Interpreter.SCOPE_REFERENCE = {};\r\n        /**\r\n         * For cycle detection in array to string and error conversion;\r\n         * see spec bug github.com/tc39/ecma262/issues/289\r\n         * Since this is for atomic actions only, it can be a class property.\r\n         */\r\n        Interpreter.toStringCycles_ = [];\r\n        return Interpreter;\r\n    }());\r\n    (function (Interpreter) {\r\n        /**\r\n         * Class for an object.\r\n         * @param {Interpreter.MyObject} proto Prototype object or null.\r\n         * @constructor\r\n         */\r\n        var MyObject = (function () {\r\n            function MyObject(proto) {\r\n                /** @type {Interpreter.MyObject} */\r\n                this.proto = null;\r\n                /** @type {boolean} */\r\n                this.isObject = true;\r\n                /** @type {string} */\r\n                this.class = 'Object';\r\n                /** @type {Date|RegExp|boolean|number|string|undefined|null} */\r\n                this.data = null;\r\n                this.getter = Object.create(null);\r\n                this.setter = Object.create(null);\r\n                this.properties = Object.create(null);\r\n                this.proto = proto;\r\n            }\r\n            /**\r\n             * Convert this object into a string.\r\n             * @return {string} String value.\r\n             * @override\r\n             */\r\n            MyObject.prototype.toString = function () {\r\n                if (this.class === 'Array') {\r\n                    // Array\r\n                    var cycles = Interpreter.toStringCycles_;\r\n                    cycles.push(this);\r\n                    try {\r\n                        var strs = [];\r\n                        for (var i = 0; i < this.properties.length; i++) {\r\n                            var value = this.properties[i];\r\n                            strs[i] = (value && value.isObject && cycles.indexOf(value) !== -1) ?\r\n                                '...' : value;\r\n                        }\r\n                    }\r\n                    finally {\r\n                        cycles.pop();\r\n                    }\r\n                    return strs.join(',');\r\n                }\r\n                if (this.class === 'Error') {\r\n                    var cycles = Interpreter.toStringCycles_;\r\n                    if (cycles.indexOf(this) !== -1) {\r\n                        return '[object Error]';\r\n                    }\r\n                    var name, message;\r\n                    // Bug: Does not support getters and setters for name or message.\r\n                    var obj = this;\r\n                    do {\r\n                        if ('name' in obj.properties) {\r\n                            name = obj.properties['name'];\r\n                            break;\r\n                        }\r\n                    } while ((obj = obj.proto));\r\n                    var obj = this;\r\n                    do {\r\n                        if ('message' in obj.properties) {\r\n                            message = obj.properties['message'];\r\n                            break;\r\n                        }\r\n                    } while ((obj = obj.proto));\r\n                    cycles.push(this);\r\n                    try {\r\n                        name = name && name.toString();\r\n                        message = message && message.toString();\r\n                    }\r\n                    finally {\r\n                        cycles.pop();\r\n                    }\r\n                    return message ? name + ': ' + message : String(name);\r\n                }\r\n                // RegExp, Date, and boxed primitives.\r\n                if (this.data !== null) {\r\n                    return String(this.data);\r\n                }\r\n                return '[object ' + this.class + ']';\r\n            };\r\n            /**\r\n             * Return the object's value.\r\n             * @return {Interpreter.MyValue} Value.\r\n             * @override\r\n             */\r\n            MyObject.prototype.valueOf = function () {\r\n                if (this.data === undefined || this.data === null ||\r\n                    this.data instanceof RegExp) {\r\n                    return this; // An Object.\r\n                }\r\n                if (this.data instanceof Date) {\r\n                    return this.data.valueOf(); // Milliseconds.\r\n                }\r\n                return (this.data); // Boxed primitive.\r\n            };\r\n            return MyObject;\r\n        }());\r\n        Interpreter.MyObject = MyObject;\r\n        /**\r\n         * Class for a state.\r\n         * @param {!MyObject} node AST node for the state.\r\n         * @param {!Interpreter.MyObject} scope Scope object for the state.\r\n         * @constructor\r\n         */\r\n        var MyState = (function () {\r\n            function MyState(node, scope) {\r\n                this.node = node;\r\n                this.scope = scope;\r\n            }\r\n            return MyState;\r\n        }());\r\n        Interpreter.MyState = MyState;\r\n    })(Interpreter || (Interpreter = {}));\r\n    // These lines are added for API compatibility\r\n    Interpreter['Object'] = Interpreter.MyObject;\r\n    Interpreter['State'] = Interpreter.MyState;\r\n    // Look for globally-defined acorn\r\n    try {\r\n        Interpreter.acorn = (self || global)['acorn'];\r\n    }\r\n    catch (e) {\r\n        // do nothing if we fail\r\n    }\r\n    return Interpreter;\r\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/acorn_interpreter.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8ee9dc209b294c66f8d6","import acorn = require('./acorn');\nimport Interpreter = require('./interpreter');\n\n/*!\n * @license\n * JavaScript Interpreter bundled with acorn v0.4.1\n *\n * Copyright 2013-2017 Google Inc. and Jun Kato\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Interpreting JavaScript in JavaScript (concatenated with acorn)\n * @author fraser@google.com (Neil Fraser)\n * @author i@junkato.jp (Jun Kato)\n */\n\nInterpreter.acorn = acorn;\nexport = Interpreter;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/acorn_interpreter.ts","// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke and released under an MIT\n// license. The Unicode regexps (for identifiers and whitespace) were\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/marijnh/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/marijnh/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports); // CommonJS\n  if (typeof define == \"function\" && define.amd) return define([\"exports\"], mod); // AMD\n  mod(root.acorn || (root.acorn = {})); // Plain browser env\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.4.1\";\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api], with the caveat that the SpiderMonkey-specific syntax\n  // (`let`, `yield`, inline XML, etc) is not recognized.\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function(inpt, opts) {\n    input = String(inpt); inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n    return parseTopLevel(options.program);\n  };\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = exports.defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\n    // be either 3 or 5. This\n    // influences support for strict mode, the set of reserved words, and\n    // support for getters and setter.\n    ecmaVersion: 5,\n    // Turn on `strictSemicolons` to prevent the parser from doing\n    // automatic semicolon insertion.\n    strictSemicolons: false,\n    // When `allowTrailingCommas` is false, the parser will not allow\n    // trailing commas in array and object literals.\n    allowTrailingCommas: true,\n    // By default, reserved words are not enforced. Enable\n    // `forbidReserved` to enforce them.\n    forbidReserved: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `location` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `location` is on or off.\n    directSourceFile: null\n  };\n\n  function setOptions(opts) {\n    options = opts || {};\n    for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n      options[opt] = defaultOptions[opt];\n    sourceFile = options.sourceFile || null;\n  }\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreak.lastIndex = cur;\n      var match = lineBreak.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else break;\n    }\n    return {line: line, column: offset - cur};\n  };\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenize` export provides an interface to the tokenizer.\n  // Because the tokenizer is optimized for being efficiently used by\n  // the Acorn parser itself, this interface is somewhat crude and not\n  // very modular. Performing another parse or call to `tokenize` will\n  // reset the internal state, and invalidate existing tokenizers.\n\n  exports.tokenize = function(inpt, opts) {\n    input = String(inpt); inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n\n    var t = {};\n    function getToken(forceRegexp) {\n      readToken(forceRegexp);\n      t.start = tokStart; t.end = tokEnd;\n      t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n      t.type = tokType; t.value = tokVal;\n      return t;\n    }\n    getToken.jumpTo = function(pos, reAllowed) {\n      tokPos = pos;\n      if (options.locations) {\n        tokCurLine = 1;\n        tokLineStart = lineBreak.lastIndex = 0;\n        var match;\n        while ((match = lineBreak.exec(input)) && match.index < pos) {\n          ++tokCurLine;\n          tokLineStart = match.index + match[0].length;\n        }\n      }\n      tokRegexpAllowed = reAllowed;\n      skipSpace();\n    };\n    return getToken;\n  };\n\n  // State is kept in (closure-)global variables. We already saw the\n  // `options`, `input`, and `inputLen` variables above.\n\n  // The current position of the tokenizer in the input.\n\n  var tokPos;\n\n  // The start and end offsets of the current token.\n\n  var tokStart, tokEnd;\n\n  // When `options.locations` is true, these hold objects\n  // containing the tokens start and end line/column pairs.\n\n  var tokStartLoc, tokEndLoc;\n\n  // The type and value of the current token. Token types are objects,\n  // named by variables against which they can be compared, and\n  // holding properties that describe them (indicating, for example,\n  // the precedence of an infix operator, and the original name of a\n  // keyword token). The kind of value that's held in `tokVal` depends\n  // on the type of the token. For literals, it is the literal value,\n  // for operators, the operator name, and so on.\n\n  var tokType, tokVal;\n\n  // Interal state for the tokenizer. To distinguish between division\n  // operators and regular expressions, it remembers whether the last\n  // token was one that is allowed to be followed by an expression.\n  // (If it is, a slash is probably a regexp, if it isn't it's a\n  // division operator. See the `parseStatement` function for a\n  // caveat.)\n\n  var tokRegexpAllowed;\n\n  // When `options.locations` is true, these are used to keep\n  // track of the current line, and know when a new line has been\n  // entered.\n\n  var tokCurLine, tokLineStart;\n\n  // These store the position of the previous token, which is useful\n  // when finishing a node and assigning its `end` position.\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  // This is the parser's state. `inFunction` is used to reject\n  // `return` statements outside of functions, `labels` to verify that\n  // `break` and `continue` have somewhere to jump to, and `strict`\n  // indicates whether strict mode is on.\n\n  var inFunction, labels, strict;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  function raise(pos, message) {\n    var loc = getLineInfo(input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n    throw err;\n  }\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // These are the general types. The `type` property is only used to\n  // make them recognizeable when debugging.\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n\n  // Keyword tokens. The `keyword` property (also used in keyword-like\n  // operators) indicates that the token originated from an\n  // identifier-like word, which is used when parsing property names.\n  //\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\n  var _this = {keyword: \"this\"};\n\n  // The keywords that denote values.\n\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\n  var _false = {keyword: \"false\", atomValue: false};\n\n  // Some keywords are treated as regular operators. `in` sometimes\n  // (when parsing `for`) needs to be tested against specifically, so\n  // we assign a variable name to it for quick comparing.\n\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\n                      \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n                      \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n                      \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n                      \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n                      \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n                      \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\n                      \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\n                      \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\n                      \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\n\n  // Punctuation token types. Again, the `type` property is purely for debugging.\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator. `isUpdate` specifies that the node produced by\n  // the operator should be of type UpdateExpression rather than\n  // simply UnaryExpression (`++` and `--`).\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\n  var _logicalOR = {binop: 1, beforeExpr: true};\n  var _logicalAND = {binop: 2, beforeExpr: true};\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\n  var _equality = {binop: 6, beforeExpr: true};\n  var _relational = {binop: 7, beforeExpr: true};\n  var _bitShift = {binop: 8, beforeExpr: true};\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\n\n  // Provide access to the token types for external users of the\n  // tokenizer.\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n                      dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n                      num: _num, regexp: _regexp, string: _string};\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  // This is a trick taken from Esprima. It turns out that, on\n  // non-Chrome browsers, to check whether a string is in a set, a\n  // predicate containing a big ugly `switch` statement is faster than\n  // a regular expression, and on Chrome the two are about on par.\n  // This function uses `eval` (non-lexical) to produce such a\n  // predicate from a space-separated string of words.\n  //\n  // It starts by sorting the words by length.\n\n  function makePredicate(words) {\n    words = words.split(\" \");\n    var f = \"\", cats = [];\n    out: for (var i = 0; i < words.length; ++i) {\n      for (var j = 0; j < cats.length; ++j)\n        if (cats[j][0].length == words[i].length) {\n          cats[j].push(words[i]);\n          continue out;\n        }\n      cats.push([words[i]]);\n    }\n    function compareTo(arr) {\n      if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n      f += \"switch(str){\";\n      for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n      f += \"return true}return false;\";\n    }\n\n    // When there are more than three length categories, an outer\n    // switch first dispatches on the lengths, to save on comparisons.\n\n    if (cats.length > 3) {\n      cats.sort(function(a, b) {return b.length - a.length;});\n      f += \"switch(str.length){\";\n      for (var i = 0; i < cats.length; ++i) {\n        var cat = cats[i];\n        f += \"case \" + cat[0].length + \":\";\n        compareTo(cat);\n      }\n      f += \"}\";\n\n    // Otherwise, simply generate a flat `switch` statement.\n\n    } else {\n      compareTo(words);\n    }\n    return new Function(\"str\", f);\n  }\n\n  // The ECMAScript 3 reserved word list.\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  // ECMAScript 5 reserved words.\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  // The additional reserved words in strict mode.\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  // The forbidden variable names in strict mode.\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  // And the keywords.\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  // Whether a single character denotes a newline.\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  // Test whether a given character code starts an identifier.\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n    if (code < 65) return code === 36;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123)return true;\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  // Test whether a given character is part of an identifier.\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123)return true;\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  // ## Tokenizer\n\n  // These are used when `options.locations` is on, for the\n  // `tokStartLoc` and `tokEndLoc` properties.\n\n  function line_loc_t() {\n    this.line = tokCurLine;\n    this.column = tokPos - tokLineStart;\n  }\n\n  // Reset the token state. Used at the start of a parse.\n\n  function initTokenState() {\n    tokCurLine = 1;\n    tokPos = tokLineStart = 0;\n    tokRegexpAllowed = true;\n    skipSpace();\n  }\n\n  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and\n  // `tokRegexpAllowed`, and skips the space after the token, so that\n  // the next one's `tokStart` will point at the right position.\n\n  function finishToken(type, val) {\n    tokEnd = tokPos;\n    if (options.locations) tokEndLoc = new line_loc_t;\n    tokType = type;\n    skipSpace();\n    tokVal = val;\n    tokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n    var startLoc = options.onComment && options.locations && new line_loc_t;\n    var start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n    if (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n    tokPos = end + 2;\n    if (options.locations) {\n      lineBreak.lastIndex = start;\n      var match;\n      while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n        ++tokCurLine;\n        tokLineStart = match.index + match[0].length;\n      }\n    }\n    if (options.onComment)\n      options.onComment(true, input.slice(start + 2, end), start, tokPos,\n                        startLoc, options.locations && new line_loc_t);\n  }\n\n  function skipLineComment() {\n    var start = tokPos;\n    var startLoc = options.onComment && options.locations && new line_loc_t;\n    var ch = input.charCodeAt(tokPos+=2);\n    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++tokPos;\n      ch = input.charCodeAt(tokPos);\n    }\n    if (options.onComment)\n      options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\n                        startLoc, options.locations && new line_loc_t);\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  function skipSpace() {\n    while (tokPos < inputLen) {\n      var ch = input.charCodeAt(tokPos);\n      if (ch === 32) { // ' '\n        ++tokPos;\n      } else if (ch === 13) {\n        ++tokPos;\n        var next = input.charCodeAt(tokPos);\n        if (next === 10) {\n          ++tokPos;\n        }\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch === 10 || ch === 8232 || ch === 8233) {\n        ++tokPos;\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch > 8 && ch < 14) {\n        ++tokPos;\n      } else if (ch === 47) { // '/'\n        var next = input.charCodeAt(tokPos + 1);\n        if (next === 42) { // '*'\n          skipBlockComment();\n        } else if (next === 47) { // '/'\n          skipLineComment();\n        } else break;\n      } else if (ch === 160) { // '\\xa0'\n        ++tokPos;\n      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++tokPos;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  // The `forceRegexp` parameter is used in the one case where the\n  // `tokRegexpAllowed` trick does not work. See `parseStatement`.\n\n  function readToken_dot() {\n    var next = input.charCodeAt(tokPos + 1);\n    if (next >= 48 && next <= 57) return readNumber(true);\n    ++tokPos;\n    return finishToken(_dot);\n  }\n\n  function readToken_slash() { // '/'\n    var next = input.charCodeAt(tokPos + 1);\n    if (tokRegexpAllowed) {++tokPos; return readRegexp();}\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() { // '%*'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) { // '|&'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() { // '^'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) { // '+-'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) {\n      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\n          newline.test(input.slice(lastEnd, tokPos))) {\n        // A `-->` line comment\n        tokPos += 3;\n        skipLineComment();\n        skipSpace();\n        return readToken();\n      }\n      return finishOp(_incDec, 2);\n    }\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) { // '<>'\n    var next = input.charCodeAt(tokPos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n      return finishOp(_bitShift, size);\n    }\n    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\n        input.charCodeAt(tokPos + 3) == 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      tokPos += 4;\n      skipLineComment();\n      skipSpace();\n      return readToken();\n    }\n    if (next === 61)\n      size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n    return finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) { // '=!'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n    return finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n    switch(code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit.\n    case 46: // '.'\n      return readToken_dot();\n\n      // Punctuation tokens.\n    case 40: ++tokPos; return finishToken(_parenL);\n    case 41: ++tokPos; return finishToken(_parenR);\n    case 59: ++tokPos; return finishToken(_semi);\n    case 44: ++tokPos; return finishToken(_comma);\n    case 91: ++tokPos; return finishToken(_bracketL);\n    case 93: ++tokPos; return finishToken(_bracketR);\n    case 123: ++tokPos; return finishToken(_braceL);\n    case 125: ++tokPos; return finishToken(_braceR);\n    case 58: ++tokPos; return finishToken(_colon);\n    case 63: ++tokPos; return finishToken(_question);\n\n      // '0x' is a hexadecimal number.\n    case 48: // '0'\n      var next = input.charCodeAt(tokPos + 1);\n      if (next === 120 || next === 88) return readHexNumber();\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return readNumber(false);\n\n      // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return readString(code);\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47: // '/'\n      return readToken_slash(code);\n\n    case 37: case 42: // '%*'\n      return readToken_mult_modulo();\n\n    case 124: case 38: // '|&'\n      return readToken_pipe_amp(code);\n\n    case 94: // '^'\n      return readToken_caret();\n\n    case 43: case 45: // '+-'\n      return readToken_plus_min(code);\n\n    case 60: case 62: // '<>'\n      return readToken_lt_gt(code);\n\n    case 61: case 33: // '=!'\n      return readToken_eq_excl(code);\n\n    case 126: // '~'\n      return finishOp(_prefix, 1);\n    }\n\n    return false;\n  }\n\n  function readToken(forceRegexp) {\n    if (!forceRegexp) tokStart = tokPos;\n    else tokPos = tokStart + 1;\n    if (options.locations) tokStartLoc = new line_loc_t;\n    if (forceRegexp) return readRegexp();\n    if (tokPos >= inputLen) return finishToken(_eof);\n\n    var code = input.charCodeAt(tokPos);\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) return readWord();\n\n    var tok = getTokenFromCode(code);\n\n    if (tok === false) {\n      // If we are here, we either found a non-ASCII identifier\n      // character, or something that's entirely disallowed.\n      var ch = String.fromCharCode(code);\n      if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n      raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n    }\n    return tok;\n  }\n\n  function finishOp(type, size) {\n    var str = input.slice(tokPos, tokPos + size);\n    tokPos += size;\n    finishToken(type, str);\n  }\n\n  // Parse a regular expression. Some context-awareness is necessary,\n  // since a '/' inside a '[]' set does not end the expression.\n\n  function readRegexp() {\n    var content = \"\", escaped, inClass, start = tokPos;\n    for (;;) {\n      if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n      var ch = input.charAt(tokPos);\n      if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n      if (!escaped) {\n        if (ch === \"[\") inClass = true;\n        else if (ch === \"]\" && inClass) inClass = false;\n        else if (ch === \"/\" && !inClass) break;\n        escaped = ch === \"\\\\\";\n      } else escaped = false;\n      ++tokPos;\n    }\n    var content = input.slice(start, tokPos);\n    ++tokPos;\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n    var mods = readWord1();\n    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n    return finishToken(_regexp, new RegExp(content, mods));\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  function readInt(radix, len) {\n    var start = tokPos, total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = input.charCodeAt(tokPos), val;\n      if (code >= 97) val = code - 97 + 10; // a\n      else if (code >= 65) val = code - 65 + 10; // A\n      else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n      else val = Infinity;\n      if (val >= radix) break;\n      ++tokPos;\n      total = total * radix + val;\n    }\n    if (tokPos === start || len != null && tokPos - start !== len) return null;\n\n    return total;\n  }\n\n  function readHexNumber() {\n    tokPos += 2; // 0x\n    var val = readInt(16);\n    if (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n    return finishToken(_num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  function readNumber(startsWithDot) {\n    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n    if (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n    if (input.charCodeAt(tokPos) === 46) {\n      ++tokPos;\n      readInt(10);\n      isFloat = true;\n    }\n    var next = input.charCodeAt(tokPos);\n    if (next === 69 || next === 101) { // 'eE'\n      next = input.charCodeAt(++tokPos);\n      if (next === 43 || next === 45) ++tokPos; // '+-'\n      if (readInt(10) === null) raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n    var str = input.slice(start, tokPos), val;\n    if (isFloat) val = parseFloat(str);\n    else if (!octal || str.length === 1) val = parseInt(str, 10);\n    else if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n    else val = parseInt(str, 8);\n    return finishToken(_num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  function readString(quote) {\n    tokPos++;\n    var out = \"\";\n    for (;;) {\n      if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n      var ch = input.charCodeAt(tokPos);\n      if (ch === quote) {\n        ++tokPos;\n        return finishToken(_string, out);\n      }\n      if (ch === 92) { // '\\'\n        ch = input.charCodeAt(++tokPos);\n        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n        if (octal) octal = octal[0];\n        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n        if (octal === \"0\") octal = null;\n        ++tokPos;\n        if (octal) {\n          if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n          out += String.fromCharCode(parseInt(octal, 8));\n          tokPos += octal.length - 1;\n        } else {\n          switch (ch) {\n          case 110: out += \"\\n\"; break; // 'n' -> '\\n'\n          case 114: out += \"\\r\"; break; // 'r' -> '\\r'\n          case 120: out += String.fromCharCode(readHexChar(2)); break; // 'x'\n          case 117: out += String.fromCharCode(readHexChar(4)); break; // 'u'\n          case 85: out += String.fromCharCode(readHexChar(8)); break; // 'U'\n          case 116: out += \"\\t\"; break; // 't' -> '\\t'\n          case 98: out += \"\\b\"; break; // 'b' -> '\\b'\n          case 118: out += \"\\u000b\"; break; // 'v' -> '\\u000b'\n          case 102: out += \"\\f\"; break; // 'f' -> '\\f'\n          case 48: out += \"\\0\"; break; // 0 -> '\\0'\n          case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\\r\\n'\n          case 10: // ' \\n'\n            if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n            break;\n          default: out += String.fromCharCode(ch); break;\n          }\n        }\n      } else {\n        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n        out += String.fromCharCode(ch); // '\\'\n        ++tokPos;\n      }\n    }\n  }\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  function readHexChar(len) {\n    var n = readInt(16, len);\n    if (n === null) raise(tokStart, \"Bad character escape sequence\");\n    return n;\n  }\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n  var containsEsc;\n\n  // Read an identifier, and return it as a string. Sets `containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Only builds up the word character-by-character when it actually\n  // containeds an escape, as a micro-optimization.\n\n  function readWord1() {\n    containsEsc = false;\n    var word, first = true, start = tokPos;\n    for (;;) {\n      var ch = input.charCodeAt(tokPos);\n      if (isIdentifierChar(ch)) {\n        if (containsEsc) word += input.charAt(tokPos);\n        ++tokPos;\n      } else if (ch === 92) { // \"\\\"\n        if (!containsEsc) word = input.slice(start, tokPos);\n        containsEsc = true;\n        if (input.charCodeAt(++tokPos) != 117) // \"u\"\n          raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        ++tokPos;\n        var esc = readHexChar(4);\n        var escStr = String.fromCharCode(esc);\n        if (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n          raise(tokPos - 4, \"Invalid Unicode escape\");\n        word += escStr;\n      } else {\n        break;\n      }\n      first = false;\n    }\n    return containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  function readWord() {\n    var word = readWord1();\n    var type = _name;\n    if (!containsEsc) {\n      if (isKeyword(word)) type = keywordTypes[word];\n      else if (options.forbidReserved &&\n               (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) ||\n               strict && isStrictReservedWord(word))\n        raise(tokStart, \"The keyword '\" + word + \"' is reserved\");\n    }\n    return finishToken(type, word);\n  }\n\n  // ## Parser\n\n  // A recursive descent parser operates by defining functions for all\n  // syntactic elements, and recursively calling those, each function\n  // advancing the input stream and returning an AST node. Precedence\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n  // instead of `(!x)[1]` is handled by the fact that the parser\n  // function that parses unary prefix operators is called first, and\n  // in turn calls the function that parses `[]` subscripts — that\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\n  // *that* in the unary operator node.\n  //\n  // Acorn uses an [operator precedence parser][opp] to handle binary\n  // operator precedence, because it is much more compact than using\n  // the technique outlined above, which uses different, nesting\n  // functions to specify precedence, for all of the ten binary\n  // precedence levels that JavaScript defines.\n  //\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n  // ### Parser utilities\n\n  // Continue to the next token.\n\n  function next() {\n    lastStart = tokStart;\n    lastEnd = tokEnd;\n    lastEndLoc = tokEndLoc;\n    readToken();\n  }\n\n  // Enter strict mode. Re-reads the next token to please pedantic\n  // tests (\"use strict\"; 010; -- should fail).\n\n  function setStrict(strct) {\n    strict = strct;\n    tokPos = lastEnd;\n    if (options.locations) {\n      while (tokPos < tokLineStart) {\n        tokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n        --tokCurLine;\n      }\n    }\n    skipSpace();\n    readToken();\n  }\n\n  // Start an AST node, attaching a start offset.\n\n  function node_t() {\n    this.type = null;\n    this.start = tokStart;\n    this.end = null;\n  }\n\n  function node_loc_t() {\n    this.start = tokStartLoc;\n    this.end = null;\n    if (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n    var node = new node_t();\n    if (options.locations)\n      node.loc = new node_loc_t();\n    if (options.directSourceFile)\n      node.sourceFile = options.directSourceFile;\n    if (options.ranges)\n      node.range = [tokStart, 0];\n    return node;\n  }\n\n  // Start a node whose start offset information should be based on\n  // the start of another node. For example, a binary operator node is\n  // only started after its left-hand side has already been parsed.\n\n  function startNodeFrom(other) {\n    var node = new node_t();\n    node.start = other.start;\n    if (options.locations) {\n      node.loc = new node_loc_t();\n      node.loc.start = other.loc.start;\n    }\n    if (options.ranges)\n      node.range = [other.range[0], 0];\n\n    return node;\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNode(node, type) {\n    node.type = type;\n    node.end = lastEnd;\n    if (options.locations)\n      node.loc.end = lastEndLoc;\n    if (options.ranges)\n      node.range[1] = lastEnd;\n    return node;\n  }\n\n  // Test whether a statement node is the string literal `\"use strict\"`.\n\n  function isUseStrict(stmt) {\n    return options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  function eat(type) {\n    if (tokType === type) {\n      next();\n      return true;\n    }\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  function canInsertSemicolon() {\n    return !options.strictSemicolons &&\n      (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  function semicolon() {\n    if (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  function expect(type) {\n    if (tokType === type) next();\n    else unexpected();\n  }\n\n  // Raise an unexpected token error.\n\n  function unexpected() {\n    raise(tokStart, \"Unexpected token\");\n  }\n\n  // Verify that a node is an lval — something that can be assigned\n  // to.\n\n  function checkLVal(expr) {\n    if (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n      raise(expr.start, \"Assigning to rvalue\");\n    if (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n      raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  function parseTopLevel(program) {\n    lastStart = lastEnd = tokPos;\n    if (options.locations) lastEndLoc = new line_loc_t;\n    inFunction = strict = null;\n    labels = [];\n    readToken();\n\n    var node = program || startNode(), first = true;\n    if (!program) node.body = [];\n    while (tokType !== _eof) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && isUseStrict(stmt)) setStrict(true);\n      first = false;\n    }\n    return finishNode(node, \"Program\");\n  }\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo);`, where looking at the previous token\n  // does not help.\n\n  function parseStatement() {\n    if (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n      readToken(true);\n\n    var starttype = tokType, node = startNode();\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case _break: case _continue:\n      next();\n      var isBreak = starttype === _break;\n      if (eat(_semi) || canInsertSemicolon()) node.label = null;\n      else if (tokType !== _name) unexpected();\n      else {\n        node.label = parseIdent();\n        semicolon();\n      }\n\n      // Verify that there is an actual destination to break or\n      // continue to.\n      for (var i = 0; i < labels.length; ++i) {\n        var lab = labels[i];\n        if (node.label == null || lab.name === node.label.name) {\n          if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n          if (node.label && isBreak) break;\n        }\n      }\n      if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n      return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n    case _debugger:\n      next();\n      semicolon();\n      return finishNode(node, \"DebuggerStatement\");\n\n    case _do:\n      next();\n      labels.push(loopLabel);\n      node.body = parseStatement();\n      labels.pop();\n      expect(_while);\n      node.test = parseParenExpression();\n      semicolon();\n      return finishNode(node, \"DoWhileStatement\");\n\n      // Disambiguating between a `for` and a `for`/`in` loop is\n      // non-trivial. Basically, we have to parse the init `var`\n      // statement or expression, disallowing the `in` operator (see\n      // the second parameter to `parseExpression`), and then check\n      // whether the next token is `in`. When there is no init part\n      // (semicolon immediately after the opening parenthesis), it is\n      // a regular `for` loop.\n\n    case _for:\n      next();\n      labels.push(loopLabel);\n      expect(_parenL);\n      if (tokType === _semi) return parseFor(node, null);\n      if (tokType === _var) {\n        var init = startNode();\n        next();\n        parseVar(init, true);\n        finishNode(init, \"VariableDeclaration\");\n        if (init.declarations.length === 1 && eat(_in))\n          return parseForIn(node, init);\n        return parseFor(node, init);\n      }\n      var init = parseExpression(false, true);\n      if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\n      return parseFor(node, init);\n\n    case _function:\n      next();\n      return parseFunction(node, true);\n\n    case _if:\n      next();\n      node.test = parseParenExpression();\n      node.consequent = parseStatement();\n      node.alternate = eat(_else) ? parseStatement() : null;\n      return finishNode(node, \"IfStatement\");\n\n    case _return:\n      if (!inFunction) raise(tokStart, \"'return' outside of function\");\n      next();\n\n      // In `return` (and `break`/`continue`), the keywords with\n      // optional arguments, we eagerly look for a semicolon or the\n      // possibility to insert one.\n\n      if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n      else { node.argument = parseExpression(); semicolon(); }\n      return finishNode(node, \"ReturnStatement\");\n\n    case _switch:\n      next();\n      node.discriminant = parseParenExpression();\n      node.cases = [];\n      expect(_braceL);\n      labels.push(switchLabel);\n\n      // Statements under must be grouped (by label) in SwitchCase\n      // nodes. `cur` is used to keep the node that we are currently\n      // adding statements to.\n\n      for (var cur, sawDefault; tokType != _braceR;) {\n        if (tokType === _case || tokType === _default) {\n          var isCase = tokType === _case;\n          if (cur) finishNode(cur, \"SwitchCase\");\n          node.cases.push(cur = startNode());\n          cur.consequent = [];\n          next();\n          if (isCase) cur.test = parseExpression();\n          else {\n            if (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\n            cur.test = null;\n          }\n          expect(_colon);\n        } else {\n          if (!cur) unexpected();\n          cur.consequent.push(parseStatement());\n        }\n      }\n      if (cur) finishNode(cur, \"SwitchCase\");\n      next(); // Closing brace\n      labels.pop();\n      return finishNode(node, \"SwitchStatement\");\n\n    case _throw:\n      next();\n      if (newline.test(input.slice(lastEnd, tokStart)))\n        raise(lastEnd, \"Illegal newline after throw\");\n      node.argument = parseExpression();\n      semicolon();\n      return finishNode(node, \"ThrowStatement\");\n\n    case _try:\n      next();\n      node.block = parseBlock();\n      node.handler = null;\n      if (tokType === _catch) {\n        var clause = startNode();\n        next();\n        expect(_parenL);\n        clause.param = parseIdent();\n        if (strict && isStrictBadIdWord(clause.param.name))\n          raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n        expect(_parenR);\n        clause.guard = null;\n        clause.body = parseBlock();\n        node.handler = finishNode(clause, \"CatchClause\");\n      }\n      node.guardedHandlers = empty;\n      node.finalizer = eat(_finally) ? parseBlock() : null;\n      if (!node.handler && !node.finalizer)\n        raise(node.start, \"Missing catch or finally clause\");\n      return finishNode(node, \"TryStatement\");\n\n    case _var:\n      next();\n      parseVar(node);\n      semicolon();\n      return finishNode(node, \"VariableDeclaration\");\n\n    case _while:\n      next();\n      node.test = parseParenExpression();\n      labels.push(loopLabel);\n      node.body = parseStatement();\n      labels.pop();\n      return finishNode(node, \"WhileStatement\");\n\n    case _with:\n      if (strict) raise(tokStart, \"'with' in strict mode\");\n      next();\n      node.object = parseParenExpression();\n      node.body = parseStatement();\n      return finishNode(node, \"WithStatement\");\n\n    case _braceL:\n      return parseBlock();\n\n    case _semi:\n      next();\n      return finishNode(node, \"EmptyStatement\");\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n\n    default:\n      var maybeName = tokVal, expr = parseExpression();\n      if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n        for (var i = 0; i < labels.length; ++i)\n          if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n        var kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n        labels.push({name: maybeName, kind: kind});\n        node.body = parseStatement();\n        labels.pop();\n        node.label = expr;\n        return finishNode(node, \"LabeledStatement\");\n      } else {\n        node.expression = expr;\n        semicolon();\n        return finishNode(node, \"ExpressionStatement\");\n      }\n    }\n  }\n\n  // Used for constructs like `switch` and `if` that insist on\n  // parentheses around their expression.\n\n  function parseParenExpression() {\n    expect(_parenL);\n    var val = parseExpression();\n    expect(_parenR);\n    return val;\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  function parseBlock(allowStrict) {\n    var node = startNode(), first = true, strict = false, oldStrict;\n    node.body = [];\n    expect(_braceL);\n    while (!eat(_braceR)) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && allowStrict && isUseStrict(stmt)) {\n        oldStrict = strict;\n        setStrict(strict = true);\n      }\n      first = false;\n    }\n    if (strict && !oldStrict) setStrict(false);\n    return finishNode(node, \"BlockStatement\");\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  function parseFor(node, init) {\n    node.init = init;\n    expect(_semi);\n    node.test = tokType === _semi ? null : parseExpression();\n    expect(_semi);\n    node.update = tokType === _parenR ? null : parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` loop.\n\n  function parseForIn(node, init) {\n    node.left = init;\n    node.right = parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForInStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  function parseVar(node, noIn) {\n    node.declarations = [];\n    node.kind = \"var\";\n    for (;;) {\n      var decl = startNode();\n      decl.id = parseIdent();\n      if (strict && isStrictBadIdWord(decl.id.name))\n        raise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n      decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n      node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n      if (!eat(_comma)) break;\n    }\n    return node;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The arguments are used to forbid comma\n  // sequences (in argument lists, array literals, or object literals)\n  // or the `in` operator (in for loops initalization expressions).\n\n  function parseExpression(noComma, noIn) {\n    var expr = parseMaybeAssign(noIn);\n    if (!noComma && tokType === _comma) {\n      var node = startNodeFrom(expr);\n      node.expressions = [expr];\n      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\n      return finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  function parseMaybeAssign(noIn) {\n    var left = parseMaybeConditional(noIn);\n    if (tokType.isAssign) {\n      var node = startNodeFrom(left);\n      node.operator = tokVal;\n      node.left = left;\n      next();\n      node.right = parseMaybeAssign(noIn);\n      checkLVal(left);\n      return finishNode(node, \"AssignmentExpression\");\n    }\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  function parseMaybeConditional(noIn) {\n    var expr = parseExprOps(noIn);\n    if (eat(_question)) {\n      var node = startNodeFrom(expr);\n      node.test = expr;\n      node.consequent = parseExpression(true);\n      expect(_colon);\n      node.alternate = parseExpression(true, noIn);\n      return finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  // Start the precedence parser.\n\n  function parseExprOps(noIn) {\n    return parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  function parseExprOp(left, minPrec, noIn) {\n    var prec = tokType.binop;\n    if (prec != null && (!noIn || tokType !== _in)) {\n      if (prec > minPrec) {\n        var node = startNodeFrom(left);\n        node.left = left;\n        node.operator = tokVal;\n        var op = tokType;\n        next();\n        node.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n        var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\n        return parseExprOp(exprNode, minPrec, noIn);\n      }\n    }\n    return left;\n  }\n\n  // Parse unary operators, both prefix and postfix.\n\n  function parseMaybeUnary() {\n    if (tokType.prefix) {\n      var node = startNode(), update = tokType.isUpdate;\n      node.operator = tokVal;\n      node.prefix = true;\n      tokRegexpAllowed = true;\n      next();\n      node.argument = parseMaybeUnary();\n      if (update) checkLVal(node.argument);\n      else if (strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        raise(node.start, \"Deleting local variable in strict mode\");\n      return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n    var expr = parseExprSubscripts();\n    while (tokType.postfix && !canInsertSemicolon()) {\n      var node = startNodeFrom(expr);\n      node.operator = tokVal;\n      node.prefix = false;\n      node.argument = expr;\n      checkLVal(expr);\n      next();\n      expr = finishNode(node, \"UpdateExpression\");\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  function parseExprSubscripts() {\n    return parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n    if (eat(_dot)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseIdent(true);\n      node.computed = false;\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (eat(_bracketL)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseExpression();\n      node.computed = true;\n      expect(_bracketR);\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (!noCalls && eat(_parenL)) {\n      var node = startNodeFrom(base);\n      node.callee = base;\n      node.arguments = parseExprList(_parenR, false);\n      return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n    } else return base;\n  }\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  function parseExprAtom() {\n    switch (tokType) {\n    case _this:\n      var node = startNode();\n      next();\n      return finishNode(node, \"ThisExpression\");\n    case _name:\n      return parseIdent();\n    case _num: case _string: case _regexp:\n      var node = startNode();\n      node.value = tokVal;\n      node.raw = input.slice(tokStart, tokEnd);\n      next();\n      return finishNode(node, \"Literal\");\n\n    case _null: case _true: case _false:\n      var node = startNode();\n      node.value = tokType.atomValue;\n      node.raw = tokType.keyword;\n      next();\n      return finishNode(node, \"Literal\");\n\n    case _parenL:\n      var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n      next();\n      var val = parseExpression();\n      val.start = tokStart1;\n      val.end = tokEnd;\n      if (options.locations) {\n        val.loc.start = tokStartLoc1;\n        val.loc.end = tokEndLoc;\n      }\n      if (options.ranges)\n        val.range = [tokStart1, tokEnd];\n      expect(_parenR);\n      return val;\n\n    case _bracketL:\n      var node = startNode();\n      next();\n      node.elements = parseExprList(_bracketR, true, true);\n      return finishNode(node, \"ArrayExpression\");\n\n    case _braceL:\n      return parseObj();\n\n    case _function:\n      var node = startNode();\n      next();\n      return parseFunction(node, false);\n\n    case _new:\n      return parseNew();\n\n    default:\n      unexpected();\n    }\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument\n  // to be a `[]` or dot subscript expression, but not a call — at\n  // least, not without wrapping it in parentheses. Thus, it uses the\n\n  function parseNew() {\n    var node = startNode();\n    next();\n    node.callee = parseSubscripts(parseExprAtom(), true);\n    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n    else node.arguments = empty;\n    return finishNode(node, \"NewExpression\");\n  }\n\n  // Parse an object literal.\n\n  function parseObj() {\n    var node = startNode(), first = true, sawGetSet = false;\n    node.properties = [];\n    next();\n    while (!eat(_braceR)) {\n      if (!first) {\n        expect(_comma);\n        if (options.allowTrailingCommas && eat(_braceR)) break;\n      } else first = false;\n\n      var prop = {key: parsePropertyName()}, isGetSet = false, kind;\n      if (eat(_colon)) {\n        prop.value = parseExpression(true);\n        kind = prop.kind = \"init\";\n      } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n                 (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n        isGetSet = sawGetSet = true;\n        kind = prop.kind = prop.key.name;\n        prop.key = parsePropertyName();\n        if (tokType !== _parenL) unexpected();\n        prop.value = parseFunction(startNode(), false);\n      } else unexpected();\n\n      // getters and setters are not allowed to clash — either with\n      // each other or with an init property — and in strict mode,\n      // init properties are also not allowed to be repeated.\n\n      if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var other = node.properties[i];\n          if (other.key.name === prop.key.name) {\n            var conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\n              kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n            if (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n            if (conflict) raise(prop.key.start, \"Redefinition of property\");\n          }\n        }\n      }\n      node.properties.push(prop);\n    }\n    return finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n    if (tokType === _num || tokType === _string) return parseExprAtom();\n    return parseIdent(true);\n  }\n\n  // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  function parseFunction(node, isStatement) {\n    if (tokType === _name) node.id = parseIdent();\n    else if (isStatement) unexpected();\n    else node.id = null;\n    node.params = [];\n    var first = true;\n    expect(_parenL);\n    while (!eat(_parenR)) {\n      if (!first) expect(_comma); else first = false;\n      node.params.push(parseIdent());\n    }\n\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldInFunc = inFunction, oldLabels = labels;\n    inFunction = true; labels = [];\n    node.body = parseBlock(true);\n    inFunction = oldInFunc; labels = oldLabels;\n\n    // If this is a strict mode function, verify that argument names\n    // are not repeated, and it does not try to bind the words `eval`\n    // or `arguments`.\n    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n      for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n        var id = i < 0 ? node.id : node.params[i];\n        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\n          raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n        if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\n          raise(id.start, \"Argument name clash in strict mode\");\n      }\n    }\n\n    return finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n    var elts = [], first = true;\n    while (!eat(close)) {\n      if (!first) {\n        expect(_comma);\n        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n      } else first = false;\n\n      if (allowEmpty && tokType === _comma) elts.push(null);\n      else elts.push(parseExpression(true));\n    }\n    return elts;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  function parseIdent(liberal) {\n    var node = startNode();\n    node.name = tokType === _name ? tokVal : (liberal && !options.forbidReserved && tokType.keyword) || unexpected();\n    tokRegexpAllowed = false;\n    next();\n    return finishNode(node, \"Identifier\");\n  }\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/acorn.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 3\n// module chunks = 0","/// <reference path=\"./_estree.d.ts\" />\n\n// Declare missing functions\ndeclare function escape(s:string): string;\ndeclare function unescape(s:string): string;\n\n/**\n * @license\n * JavaScript Interpreter\n *\n * Copyright 2013-2017 Google Inc. and Jun Kato\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Interpreting JavaScript in JavaScript.\n * @author fraser@google.com (Neil Fraser)\n * @author i@junkato.jp (Jun Kato)\n */\n\n/**\n * Create a new interpreter.\n * @param {string|!Object} code Raw JavaScript text or AST.\n * @param {Function=} opt_initFunc Optional initialization function.  Used to\n *     define APIs.  When called it is passed the interpreter object and the\n *     global scope object.\n * @constructor\n */\nclass Interpreter {\npublic static acorn: Interpreter.Acorn;\n\nprivate nodeConstructor: Interpreter.NodeConstructor;\npublic ast: ESTree.Program;\npublic global: Interpreter.MyObject;\npublic stateStack: Interpreter.MyState[];\npublic value: Interpreter.MyValue;\nprivate initFunc_: (i: Interpreter, scope: Interpreter.MyObject) => void;\nprivate paused_: boolean;\nprivate polyfills_: string[];\nprivate functionCounter_: number;\nprivate stepFunctions_: { [key: string]: Function };\n\npublic OBJECT: Interpreter.MyObject;\npublic OBJECT_PROTO: Interpreter.MyObject;\npublic FUNCTION: Interpreter.MyObject;\npublic FUNCTION_PROTO: Interpreter.MyObject;\npublic ARRAY: Interpreter.MyObject;\npublic ARRAY_PROTO: Interpreter.MyObject;\npublic REGEXP: Interpreter.MyObject;\npublic REGEXP_PROTO: Interpreter.MyObject;\n\npublic ERROR: Interpreter.MyObject;\npublic EVAL_ERROR: Interpreter.MyObject;\npublic RANGE_ERROR: Interpreter.MyObject;\npublic REFERENCE_ERROR: Interpreter.MyObject;\npublic SYNTAX_ERROR: Interpreter.MyObject;\npublic TYPE_ERROR: Interpreter.MyObject;\npublic URI_ERROR: Interpreter.MyObject;\n\npublic STRING: Interpreter.MyObject;\npublic BOOLEAN: Interpreter.MyObject;\npublic NUMBER: Interpreter.MyObject;\npublic DATE: Interpreter.MyObject;\n\n// The following properties are obsolete.  Do not use.\npublic UNDEFINED: Interpreter.MyObject;\npublic NULL: null;\npublic NAN: number;\npublic TRUE: boolean;\npublic FALSE: boolean;\npublic STRING_EMPTY: string;\npublic NUMBER_ZERO: number;\npublic NUMBER_ONE: number;\n\nconstructor(code: string | ESTree.Program\n    , opt_initFunc?: (i: Interpreter, scope: Interpreter.MyObject) => void) {\n  if (typeof code === 'string') {\n    code = Interpreter.acorn.parse(code, Interpreter.PARSE_OPTIONS);\n  }\n  this.ast = code;\n  this.initFunc_ = opt_initFunc;\n  this.paused_ = false;\n  this.polyfills_ = [];\n  // Unique identifier for native functions.  Used in serialization.\n  this.functionCounter_ = 0;\n  // Map node types to our step function names; a property lookup is faster\n  // than string concatenation with \"step\" prefix.\n  this.stepFunctions_ = Object.create(null);\n  var stepMatch = /^step([A-Z]\\w*)$/;\n  var m;\n  var props = Object.getOwnPropertyNames(Interpreter.prototype);\n  for (var i = 0; i < props.length; i ++) {\n    var methodName = props[i];\n    if ((typeof Interpreter.prototype[methodName] === 'function') &&\n        (m = methodName.match(stepMatch))) {\n      this.stepFunctions_[m[1]] = (<Function>Interpreter.prototype[methodName]).bind(this);\n    }\n  }\n  // Create and initialize the global scope.\n  this.global = this.createScope(this.ast, null);\n  // Run the polyfills.\n  this.ast = Interpreter.acorn.parse(this.polyfills_.join('\\n'), Interpreter.PARSE_OPTIONS);\n  this.polyfills_ = undefined;  // Allow polyfill strings to garbage collect.\n  this.stripLocations_(this.ast, undefined, undefined);\n  var state = new Interpreter.MyState(this.ast, this.global);\n  state.done = false;\n  this.stateStack = [state];\n  this.run();\n  this.value = undefined;\n  // Point at the main program.\n  this.ast = code;\n  var state = new Interpreter.MyState(this.ast, this.global);\n  state.done = false;\n  this.stateStack.length = 0;\n  this.stateStack[0] = state;\n  // Get a handle on Acorn's node_t object.  It's tricky to access.\n  this.nodeConstructor = <Interpreter.NodeConstructor>state.node.constructor;\n  // Preserve publicly properties from being pruned/renamed by JS compilers.\n  // Add others as needed.\n  this['stateStack'] = this.stateStack;\n  this['OBJECT'] = this.OBJECT; this['OBJECT_PROTO'] = this.OBJECT_PROTO;\n  this['FUNCTION'] = this.FUNCTION; this['FUNCTION_PROTO'] = this.FUNCTION_PROTO;\n  this['ARRAY'] = this.ARRAY; this['ARRAY_PROTO'] = this.ARRAY_PROTO;\n  this['REGEXP'] = this.REGEXP; this['REGEXP_PROTO'] = this.REGEXP_PROTO;\n  // The following properties are obsolete.  Do not use.\n  this['UNDEFINED'] = undefined; this['NULL'] = null; this['NAN'] = NaN;\n  this['TRUE'] = true; this['FALSE'] = false; this['STRING_EMPTY'] = '';\n  this['NUMBER_ZERO'] = 0; this['NUMBER_ONE'] = 1;\n};\n\n/**\n * @const {!Object} Configuration used for all Acorn parsing.\n */\nstatic PARSE_OPTIONS = {\n  ecmaVersion: 5\n};\n\n/**\n * Property descriptor of readonly properties.\n */\nstatic READONLY_DESCRIPTOR: Interpreter.MyDescriptor = {\n  configurable: true,\n  enumerable: true,\n  writable: false\n};\n\n/**\n * Property descriptor of non-enumerable properties.\n */\nstatic NONENUMERABLE_DESCRIPTOR: Interpreter.MyDescriptor = {\n  configurable: true,\n  enumerable: false,\n  writable: true\n};\n\n/**\n * Property descriptor of readonly, non-enumerable properties.\n */\nstatic READONLY_NONENUMERABLE_DESCRIPTOR: Interpreter.MyDescriptor = {\n  configurable: true,\n  enumerable: false,\n  writable: false\n};\n\n/**\n * Property descriptor of variables.\n */\nstatic VARIABLE_DESCRIPTOR: Interpreter.MyDescriptor = {\n  configurable: false,\n  enumerable: true,\n  writable: true\n};\n\n/**\n * Unique symbol for indicating that a step has encountered an error, has\n * added it to the stack, and will be thrown within the user's program.\n * When STEP_ERROR is thrown in the JS-Interpreter, the error can be ignored.\n */\nstatic STEP_ERROR = {};\n\n/**\n * Unique symbol for indicating that a reference is a variable on the scope,\n * not an object property.\n */\nstatic SCOPE_REFERENCE = {};\n\n/**\n * For cycle detection in array to string and error conversion;\n * see spec bug github.com/tc39/ecma262/issues/289\n * Since this is for atomic actions only, it can be a class property.\n */\nstatic toStringCycles_ = [];\n\n/**\n * Add more code to the interpreter.\n * @param {string|!Object} code Raw JavaScript text or AST.\n */\npublic appendCode(code: string | ESTree.Node) {\n  var state = this.stateStack[0];\n  if (!state || state.node['type'] !== 'Program') {\n    throw Error('Expecting original AST to start with a Program node.');\n  }\n  if (typeof code === 'string') {\n    code = Interpreter.acorn.parse(code, Interpreter.PARSE_OPTIONS);\n  }\n  if (!code || code['type'] !== 'Program') {\n    throw Error('Expecting new AST to start with a Program node.');\n  }\n  this.populateScope_(code, state.scope);\n  // Append the new program to the old one.\n  for (var i = 0, node; (node = code['body'][i]); i++) {\n    state.node['body'].push(node);\n  }\n  state.done = false;\n};\n\n/**\n * Execute one step of the interpreter.\n * @return {boolean} True if a step was executed, false if no more instructions.\n */\npublic step(): boolean {\n  var stack = this.stateStack;\n  var state = stack[stack.length - 1];\n  if (!state) {\n    return false;\n  }\n  var node = state.node, type = node['type'];\n  if (type === 'Program' && state.done) {\n    return false;\n  } else if (this.paused_) {\n    return true;\n  }\n  try {\n    var nextState = this.stepFunctions_[type](stack, state, node);\n  } catch (e) {\n    // Eat any step errors.  They have been thrown on the stack.\n    if (e !== Interpreter.STEP_ERROR) {\n      // Uh oh.  This is a real error in the JS-Interpreter.  Rethrow.\n      throw e;\n    }\n  }\n  if (nextState) {\n    stack.push(nextState);\n  }\n  if (!node['end']) {\n    // This is polyfill code.  Keep executing until we arrive at user code.\n    return this.step();\n  }\n  return true;\n};\n\n/**\n * Execute the interpreter to program completion.  Vulnerable to infinite loops.\n * @return {boolean} True if a execution is asynchronously blocked,\n *     false if no more instructions.\n */\npublic run() {\n  while (!this.paused_ && this.step()) {}\n  return this.paused_;\n};\n\n/**\n * Initialize the global scope with buitin properties and functions.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initGlobalScope(scope: Interpreter.MyObject) {\n  // Initialize uneditable global properties.\n  this.setProperty(scope, 'NaN', NaN,\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'Infinity', Infinity,\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'undefined', undefined,\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'window', scope,\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'this', scope,\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'self', scope); // Editable.\n\n  // Create the objects which will become Object.prototype and\n  // Function.prototype, which are needed to bootstrap everything else.\n  this.OBJECT_PROTO = new Interpreter.MyObject(null);\n  this.FUNCTION_PROTO = new Interpreter.MyObject(this.OBJECT_PROTO);\n  // Initialize global objects.\n  this.initFunction(scope);\n  this.initObject(scope);\n  // Unable to set scope's parent prior (OBJECT did not exist).\n  // Note that in a browser this would be 'Window', whereas in Node.js it would\n  // be 'Object'.  This interpreter is closer to Node in that it has no DOM.\n  scope.proto = this.OBJECT_PROTO;\n  this.setProperty(scope, 'constructor', this.OBJECT);\n  this.initArray(scope);\n  this.initString(scope);\n  this.initBoolean(scope);\n  this.initNumber(scope);\n  this.initDate(scope);\n  this.initRegExp(scope);\n  this.initError(scope);\n  this.initMath(scope);\n  this.initJSON(scope);\n\n  // Initialize global functions.\n  var thisInterpreter = this;\n  var func = this.createNativeFunction(\n      function(x) {throw EvalError(\"Can't happen\");}, false);\n  func.eval = true;\n  this.setProperty(scope, 'eval', func);\n\n  this.setProperty(scope, 'parseInt',\n      this.createNativeFunction(parseInt, false));\n  this.setProperty(scope, 'parseFloat',\n      this.createNativeFunction(parseFloat, false));\n\n  this.setProperty(scope, 'isNaN',\n      this.createNativeFunction(isNaN, false));\n\n  this.setProperty(scope, 'isFinite',\n      this.createNativeFunction(isFinite, false));\n\n  var strFunctions: any[] = [\n    [escape, 'escape'], [unescape, 'unescape'],\n    [decodeURI, 'decodeURI'], [decodeURIComponent, 'decodeURIComponent'],\n    [encodeURI, 'encodeURI'], [encodeURIComponent, 'encodeURIComponent']\n  ];\n  for (var i = 0; i < strFunctions.length; i++) {\n    var wrapper = (function(nativeFunc: (s: string) => string) {\n      return function(str) {\n        try {\n          return nativeFunc(str);\n        } catch (e) {\n          // decodeURI('%xy') will throw an error.  Catch and rethrow.\n          thisInterpreter.throwException(thisInterpreter.URI_ERROR, e.message);\n        }\n      };\n    })(strFunctions[i][0]);\n    this.setProperty(scope, strFunctions[i][1],\n        this.createNativeFunction(wrapper, false),\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\n  }\n\n  // Run any user-provided initialization.\n  if (this.initFunc_) {\n    this.initFunc_(this, scope);\n  }\n};\n\n/**\n * Initialize the Function class.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initFunction(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var wrapper;\n  var identifierRegexp = /^[A-Za-z_$][\\w$]*$/;\n  // Function constructor.\n  wrapper = function(var_args) {\n    if (thisInterpreter.calledWithNew()) {\n      // Called as new Function().\n      var newFunc = <Interpreter.MyObject>this;\n    } else {\n      // Called as Function().\n      var newFunc =\n          thisInterpreter.createObjectProto(thisInterpreter.FUNCTION_PROTO);\n    }\n    if (arguments.length) {\n      var code = String(arguments[arguments.length - 1]);\n    } else {\n      var code = '';\n    }\n    var args: string[] | string = [];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      var name = String(arguments[i]);\n      if (!name.match(identifierRegexp)) {\n        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR,\n            'Invalid function argument: ' + name);\n      }\n      args.push(name);\n    }\n    args = args.join(', ');\n    // Interestingly, the scope for constructed functions is the global scope,\n    // even if they were constructed in some other scope.\n    newFunc.parentScope = thisInterpreter.global;\n    // Acorn needs to parse code in the context of a function or else 'return'\n    // statements will be syntax errors.\n    try {\n    var ast = Interpreter.acorn.parse('$ = function(' + args + ') {' + code + '};',\n        Interpreter.PARSE_OPTIONS);\n    } catch (e) {\n      // Acorn threw a SyntaxError.  Rethrow as a trappable error.\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR,\n          'Invalid code: ' + e.message);\n    }\n    if (ast['body'].length !== 1) {\n      // Function('a', 'return a + 6;}; {alert(1);');\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR,\n          'Invalid code in function body.');\n    }\n    newFunc.node = ast['body'][0]['expression']['right'];\n    thisInterpreter.setProperty(newFunc, 'length', newFunc.node['length'],\n        Interpreter.READONLY_DESCRIPTOR);\n    return newFunc;\n  };\n  wrapper.id = this.functionCounter_++;\n  this.FUNCTION = this.createObjectProto(this.FUNCTION_PROTO);\n\n  this.setProperty(scope, 'Function', this.FUNCTION);\n  // Manually setup type and prototype because createObj doesn't recognize\n  // this object as a function (this.FUNCTION did not exist).\n  this.setProperty(this.FUNCTION, 'prototype', this.FUNCTION_PROTO);\n  this.FUNCTION.nativeFunc = wrapper;\n\n  // Configure Function.prototype.\n  this.setProperty(this.FUNCTION_PROTO, 'constructor', this.FUNCTION,\n                   Interpreter.NONENUMERABLE_DESCRIPTOR);\n  this.FUNCTION_PROTO.nativeFunc = function() {};\n  this.FUNCTION_PROTO.nativeFunc.id = this.functionCounter_++;\n  this.setProperty(this.FUNCTION_PROTO, 'length', 0,\n      Interpreter.READONLY_DESCRIPTOR);\n\n  var boxThis = function(value) {\n    // In non-strict mode 'this' must be an object.\n    if ((!value || !value.isObject) && !thisInterpreter.getScope().strict) {\n      if (value === undefined || value === null) {\n        // 'Undefined' and 'null' are changed to global object.\n        value = thisInterpreter.global;\n      } else {\n        // Primitives must be boxed in non-strict mode.\n        var box = thisInterpreter.createObjectProto(\n            thisInterpreter.getPrototype(value));\n        box.data = value;\n        value = box;\n      }\n    }\n    return value;\n  };\n\n  wrapper = function(thisArg, args) {\n    var state =\n        thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\n    // Rewrite the current 'CallExpression' to apply a different function.\n    state.func_ = this;\n    // Assign the 'this' object.\n    state.funcThis_ = boxThis(thisArg);\n    // Bind any provided arguments.\n    state.arguments_ = [];\n    if (args !== null && args !== undefined) {\n      if (args.isObject) {\n        state.arguments_ = thisInterpreter.pseudoToNative(args);\n      } else {\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n            'CreateListFromArrayLike called on non-object');\n      }\n    }\n    state.doneExec_ = false;\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'apply', wrapper);\n\n  wrapper = function(thisArg, var_args) {\n    var state =\n        thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\n    // Rewrite the current 'CallExpression' to call a different function.\n    state.func_ = this;\n    // Assign the 'this' object.\n    state.funcThis_ = boxThis(thisArg);\n    // Bind any provided arguments.\n    state.arguments_ = [];\n    for (var i = 1; i < arguments.length; i++) {\n      state.arguments_.push(arguments[i]);\n    }\n    state.doneExec_ = false;\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'call', wrapper);\n\n  this.polyfills_.push(\n// Polyfill copied from:\n// developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\n\"Object.defineProperty(Function.prototype, 'bind',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function(oThis) {\",\n    \"if (typeof this !== 'function') {\",\n      \"throw TypeError('What is trying to be bound is not callable');\",\n    \"}\",\n    \"var aArgs   = Array.prototype.slice.call(arguments, 1),\",\n        \"fToBind = this,\",\n        \"fNOP    = function() {},\",\n        \"fBound  = function() {\",\n          \"return fToBind.apply(this instanceof fNOP\",\n                 \"? this\",\n                 \": oThis,\",\n                 \"aArgs.concat(Array.prototype.slice.call(arguments)));\",\n        \"};\",\n    \"if (this.prototype) {\",\n      \"fNOP.prototype = this.prototype;\",\n    \"}\",\n    \"fBound.prototype = new fNOP();\",\n    \"return fBound;\",\n  \"}\",\n\"});\",\n\"\");\n\n  // Function has no parent to inherit from, so it needs its own mandatory\n  // toString and valueOf functions.\n  wrapper = function() {\n    return this.toString();\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'toString', wrapper);\n  this.setProperty(this.FUNCTION, 'toString',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n  wrapper = function() {\n    return this.valueOf();\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'valueOf', wrapper);\n  this.setProperty(this.FUNCTION, 'valueOf',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n};\n\n/**\n * Initialize the Object class.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initObject(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Object constructor.\n  wrapper = function(value) {\n    if (value === undefined || value === null) {\n      // Create a new object.\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new Object().\n        return this;\n      } else {\n        // Called as Object().\n        return thisInterpreter.createObjectProto(thisInterpreter.OBJECT_PROTO);\n      }\n    }\n    if (!value.isObject) {\n      // Wrap the value as an object.\n      var box = thisInterpreter.createObjectProto(\n          thisInterpreter.getPrototype(value));\n      box.data = value;\n      return box;\n    }\n    // Return the provided object.\n    return value;\n  };\n  this.OBJECT = this.createNativeFunction(wrapper, true);\n  // Throw away the created prototype and use the root prototype.\n  this.setProperty(this.OBJECT, 'prototype', this.OBJECT_PROTO);\n  this.setProperty(this.OBJECT_PROTO, 'constructor', this.OBJECT);\n  this.setProperty(scope, 'Object', this.OBJECT);\n\n  /**\n   * Checks if the provided value is null or undefined.\n   * If so, then throw an error in the call stack.\n   * @param {Interpreter.MyValue} value Value to check.\n   */\n  var throwIfNullUndefined = function(value) {\n    if (value === undefined || value === null) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n          \"Cannot convert '\" + value + \"' to object\");\n    }\n  };\n\n  // Static methods on Object.\n  wrapper = function(obj) {\n    throwIfNullUndefined(obj);\n    var props = obj.isObject ? obj.properties : obj;\n    return thisInterpreter.nativeToPseudo(Object.getOwnPropertyNames(props));\n  };\n  this.setProperty(this.OBJECT, 'getOwnPropertyNames',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(obj) {\n    throwIfNullUndefined(obj);\n    if (!obj.isObject) {\n      return thisInterpreter.nativeToPseudo(Object.keys(obj));\n    }\n    return thisInterpreter.nativeToPseudo(Object.keys(obj.properties));\n  };\n  this.setProperty(this.OBJECT, 'keys',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(proto) {\n    // Support for the second argument is the responsibility of a polyfill.\n    if (proto === null) {\n      return thisInterpreter.createObjectProto(null);\n    }\n    if (proto === undefined || !proto.isObject) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n          'Object prototype may only be an Object or null');\n    }\n    return thisInterpreter.createObjectProto(proto);\n  };\n  this.setProperty(this.OBJECT, 'create',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Add a polyfill to handle create's second argument.\n  this.polyfills_.push(\n\"(function() {\",\n  \"var create_ = Object.create;\",\n  \"Object.create = function(proto, props) {\",\n    \"var obj = create_(proto);\",\n    \"props && Object.defineProperties(obj, props);\",\n    \"return obj;\",\n  \"};\",\n\"})();\",\n\"\");\n\n  wrapper = function(obj, prop, descriptor) {\n    prop = String(prop);\n    if (!obj || !obj.isObject) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n          'Object.defineProperty called on non-object');\n    }\n    if (!descriptor || !descriptor.isObject) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n          'Property description must be an object');\n    }\n    if (!obj.properties[prop] && obj.preventExtensions) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n          \"Can't define property '\" + prop + \"', object is not extensible\");\n    }\n    // The polyfill guarantees no inheritance and no getter functions.\n    // Therefore the descriptor properties map is the native object needed.\n    thisInterpreter.setProperty(obj, prop, ReferenceError,\n                                descriptor.properties);\n    return obj;\n  };\n  this.setProperty(this.OBJECT, 'defineProperty',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  this.polyfills_.push(\n// Flatten the descriptor to remove any inheritance or getter functions.\n\"(function() {\",\n  \"var defineProperty_ = Object.defineProperty;\",\n  \"Object.defineProperty = function(obj, prop, d1) {\",\n    \"var d2 = {};\",\n    \"if ('configurable' in d1) d2.configurable = d1.configurable;\",\n    \"if ('enumerable' in d1) d2.enumerable = d1.enumerable;\",\n    \"if ('writable' in d1) d2.writable = d1.writable;\",\n    \"if ('value' in d1) d2.value = d1.value;\",\n    \"if ('get' in d1) d2.get = d1.get;\",\n    \"if ('set' in d1) d2.set = d1.set;\",\n    \"return defineProperty_(obj, prop, d2);\",\n  \"};\",\n\"})();\",\n\n\"Object.defineProperty(Object, 'defineProperties',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function(obj, props) {\",\n    \"var keys = Object.keys(props);\",\n    \"for (var i = 0; i < keys.length; i++) {\",\n      \"Object.defineProperty(obj, keys[i], props[keys[i]]);\",\n    \"}\",\n    \"return obj;\",\n  \"}\",\n\"});\",\n\"\");\n\n  wrapper = function(obj, prop) {\n    if (!obj || !obj.isObject) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n          'Object.getOwnPropertyDescriptor called on non-object');\n    }\n    prop = String(prop);\n    if (!(prop in obj.properties)) {\n      return undefined;\n    }\n    var descriptor = Object.getOwnPropertyDescriptor(obj.properties, prop);\n    var getter = obj.getter[prop];\n    var setter = obj.setter[prop];\n\n    if (getter || setter) {\n      descriptor.get = getter;\n      descriptor.set = setter;\n      delete descriptor.value;\n      delete descriptor.writable;\n    }\n    var pseudoDescriptor = <Interpreter.MyObject>thisInterpreter.nativeToPseudo(descriptor);\n    if ('value' in descriptor) {\n      thisInterpreter.setProperty(pseudoDescriptor, 'value', descriptor.value);\n    }\n    return pseudoDescriptor;\n  };\n  this.setProperty(this.OBJECT, 'getOwnPropertyDescriptor',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(obj) {\n    throwIfNullUndefined(obj);\n    return thisInterpreter.getPrototype(obj);\n  };\n  this.setProperty(this.OBJECT, 'getPrototypeOf',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(obj) {\n    return Boolean(obj) && !obj.preventExtensions;\n  };\n  this.setProperty(this.OBJECT, 'isExtensible',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(obj) {\n    if (obj && obj.isObject) {\n      obj.preventExtensions = true;\n    }\n    return obj;\n  };\n  this.setProperty(this.OBJECT, 'preventExtensions',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on Object.\n  this.setNativeFunctionPrototype(this.OBJECT, 'toString',\n      Interpreter.MyObject.prototype.toString);\n  this.setNativeFunctionPrototype(this.OBJECT, 'toLocaleString',\n      Interpreter.MyObject.prototype.toString);\n  this.setNativeFunctionPrototype(this.OBJECT, 'valueOf',\n      Interpreter.MyObject.prototype.valueOf);\n\n  wrapper = function(prop) {\n    throwIfNullUndefined(this);\n    if (!this.isObject) {\n      return this.hasOwnProperty(prop);\n    }\n    return String(prop) in this.properties;\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'hasOwnProperty', wrapper);\n\n  wrapper = function(prop) {\n    throwIfNullUndefined(this);\n    return Object.prototype.propertyIsEnumerable.call(this.properties, prop);\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'propertyIsEnumerable', wrapper);\n\n  wrapper = function(obj) {\n    while (true) {\n      // Note, circular loops shouldn't be possible.\n      obj = thisInterpreter.getPrototype(obj);\n      if (!obj) {\n        // No parent; reached the top.\n        return false;\n      }\n      if (obj === this) {\n        return true;\n      }\n    }\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'isPrototypeOf',  wrapper);\n};\n\n/**\n * Initialize the Array class.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initArray(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var getInt = function(obj, def) {\n    // Return an integer, or the default.\n    var n = obj ? Math.floor(obj) : def;\n    if (isNaN(n)) {\n      n = def;\n    }\n    return n;\n  };\n  var wrapper;\n  // Array constructor.\n  wrapper = function(var_args) {\n    if (thisInterpreter.calledWithNew()) {\n      // Called as new Array().\n      var newArray = <Interpreter.MyObject>this;\n    } else {\n      // Called as Array().\n      var newArray =\n          thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\n    }\n    var first = arguments[0];\n    if (arguments.length === 1 && typeof first === 'number') {\n      if (isNaN(Interpreter.legalArrayLength(first))) {\n        thisInterpreter.throwException(thisInterpreter.RANGE_ERROR,\n                                       'Invalid array length');\n      }\n      newArray.properties.length = first;\n    } else {\n      for (var i = 0; i < arguments.length; i++) {\n        newArray.properties[i] = arguments[i];\n      }\n      newArray.properties.length = i;\n    }\n    return newArray;\n  };\n  this.ARRAY = this.createNativeFunction(wrapper, true);\n  this.ARRAY_PROTO = this.ARRAY.properties['prototype'];\n  this.setProperty(scope, 'Array', this.ARRAY);\n\n  // Static methods on Array.\n  wrapper = function(obj) {\n    return obj && obj.class === 'Array';\n  };\n  this.setProperty(this.ARRAY, 'isArray',\n                   this.createNativeFunction(wrapper, false),\n                   Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on Array.\n  wrapper = function() {\n    return Array.prototype.pop.call(this.properties);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'pop', wrapper);\n\n  wrapper = function(var_args) {\n    return Array.prototype.push.apply(this.properties, arguments);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'push', wrapper);\n\n  wrapper = function() {\n    return Array.prototype.shift.call(this.properties);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'shift', wrapper);\n\n  wrapper = function(var_args) {\n    return Array.prototype.unshift.apply(this.properties, arguments);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'unshift', wrapper);\n\n  wrapper = function() {\n    Array.prototype.reverse.call(this.properties);\n    return this;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'reverse', wrapper);\n\n  wrapper = function(index, howmany /*, var_args*/) {\n    var list = Array.prototype.splice.apply(this.properties, arguments);\n    return thisInterpreter.nativeToPseudo(list);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'splice', wrapper);\n\n  wrapper = function(opt_begin, opt_end) {\n    var list = Array.prototype.slice.call(this.properties, opt_begin, opt_end);\n    return thisInterpreter.nativeToPseudo(list);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'slice', wrapper);\n\n  wrapper = function(opt_separator) {\n    return Array.prototype.join.call(this.properties, opt_separator);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'join', wrapper);\n\n  wrapper = function(var_args) {\n    var list = [];\n    var length = 0;\n    // Start by copying the current array.\n    var iLength = thisInterpreter.getProperty(this, 'length');\n    for (var i = 0; i < iLength; i++) {\n      if (thisInterpreter.hasProperty(this, i)) {\n        var element = thisInterpreter.getProperty(this, i);\n        list[length] = element;\n      }\n      length++;\n    }\n    // Loop through all arguments and copy them in.\n    for (var i = 0; i < arguments.length; i++) {\n      var value = arguments[i];\n      if (thisInterpreter.isa(value, thisInterpreter.ARRAY)) {\n        var jLength = thisInterpreter.getProperty(value, 'length');\n        for (var j = 0; j < jLength; j++) {\n          if (thisInterpreter.hasProperty(value, j)) {\n            list[length] = thisInterpreter.getProperty(value, j);\n          }\n          length++;\n        }\n      } else {\n        list[length] = value;\n      }\n    }\n    return thisInterpreter.nativeToPseudo(list);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'concat', wrapper);\n\n  wrapper = function(searchElement, opt_fromIndex) {\n    return Array.prototype.indexOf.apply(this.properties, arguments);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'indexOf', wrapper);\n\n  wrapper = function(searchElement, opt_fromIndex) {\n    return Array.prototype.lastIndexOf.apply(this.properties, arguments);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'lastIndexOf', wrapper);\n\n  wrapper = function() {\n    Array.prototype.sort.call(this.properties);\n    return this;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'sort', wrapper);\n\n  this.polyfills_.push(\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/every\n\"Object.defineProperty(Array.prototype, 'every',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function(callbackfn, thisArg) {\",\n    \"if (!this || typeof callbackfn !== 'function') throw TypeError();\",\n    \"var T, k;\",\n    \"var O = Object(this);\",\n    \"var len = O.length >>> 0;\",\n    \"if (arguments.length > 1) T = thisArg;\",\n    \"k = 0;\",\n    \"while (k < len) {\",\n      \"if (k in O && !callbackfn.call(T, O[k], k, O)) return false;\",\n      \"k++;\",\n    \"}\",\n    \"return true;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\n\"Object.defineProperty(Array.prototype, 'filter',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function(fun/*, thisArg*/) {\",\n    \"if (this === void 0 || this === null || typeof fun !== 'function') throw TypeError();\",\n    \"var t = Object(this);\",\n    \"var len = t.length >>> 0;\",\n    \"var res = [];\",\n    \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\",\n    \"for (var i = 0; i < len; i++) {\",\n      \"if (i in t) {\",\n        \"var val = t[i];\",\n        \"if (fun.call(thisArg, val, i, t)) res.push(val);\",\n      \"}\",\n    \"}\",\n    \"return res;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n\"Object.defineProperty(Array.prototype, 'forEach',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function(callback, thisArg) {\",\n    \"if (!this || typeof callback !== 'function') throw TypeError();\",\n    \"var T, k;\",\n    \"var O = Object(this);\",\n    \"var len = O.length >>> 0;\",\n    \"if (arguments.length > 1) T = thisArg;\",\n    \"k = 0;\",\n    \"while (k < len) {\",\n      \"if (k in O) callback.call(T, O[k], k, O);\",\n      \"k++;\",\n    \"}\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map\n\"Object.defineProperty(Array.prototype, 'map',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function(callback, thisArg) {\",\n    \"if (!this || typeof callback !== 'function') new TypeError;\",\n    \"var T, A, k;\",\n    \"var O = Object(this);\",\n    \"var len = O.length >>> 0;\",\n    \"if (arguments.length > 1) T = thisArg;\",\n    \"A = new Array(len);\",\n    \"k = 0;\",\n    \"while (k < len) {\",\n      \"if (k in O) A[k] = callback.call(T, O[k], k, O);\",\n      \"k++;\",\n    \"}\",\n    \"return A;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\n\"Object.defineProperty(Array.prototype, 'reduce',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function(callback /*, initialValue*/) {\",\n    \"if (!this || typeof callback !== 'function') throw TypeError();\",\n    \"var t = Object(this), len = t.length >>> 0, k = 0, value;\",\n    \"if (arguments.length === 2) {\",\n      \"value = arguments[1];\",\n    \"} else {\",\n      \"while (k < len && !(k in t)) k++;\",\n      \"if (k >= len) {\",\n        \"throw TypeError('Reduce of empty array with no initial value');\",\n      \"}\",\n      \"value = t[k++];\",\n    \"}\",\n    \"for (; k < len; k++) {\",\n      \"if (k in t) value = callback(value, t[k], k, t);\",\n    \"}\",\n    \"return value;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\n\"Object.defineProperty(Array.prototype, 'reduceRight',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function(callback /*, initialValue*/) {\",\n    \"if (null === this || 'undefined' === typeof this || 'function' !== typeof callback) throw TypeError();\",\n    \"var t = Object(this), len = t.length >>> 0, k = len - 1, value;\",\n    \"if (arguments.length >= 2) {\",\n      \"value = arguments[1];\",\n    \"} else {\",\n      \"while (k >= 0 && !(k in t)) k--;\",\n      \"if (k < 0) {\",\n        \"throw TypeError('Reduce of empty array with no initial value');\",\n      \"}\",\n      \"value = t[k--];\",\n    \"}\",\n    \"for (; k >= 0; k--) {\",\n      \"if (k in t) value = callback(value, t[k], k, t);\",\n    \"}\",\n    \"return value;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/some\n\"Object.defineProperty(Array.prototype, 'some',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function(fun/*, thisArg*/) {\",\n    \"if (!this || typeof fun !== 'function') throw TypeError();\",\n    \"var t = Object(this);\",\n    \"var len = t.length >>> 0;\",\n    \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\",\n    \"for (var i = 0; i < len; i++) {\",\n      \"if (i in t && fun.call(thisArg, t[i], i, t)) {\",\n        \"return true;\",\n      \"}\",\n    \"}\",\n    \"return false;\",\n  \"}\",\n\"});\",\n\n\n\"(function() {\",\n  \"var sort_ = Array.prototype.sort;\",\n  \"Array.prototype.sort = function(opt_comp) {\",\n    // Fast native sort.\n    \"if (typeof opt_comp !== 'function') {\",\n      \"return sort_.call(this);\",\n    \"}\",\n    // Slow bubble sort.\n    \"for (var i = 0; i < this.length; i++) {\",\n      \"var changes = 0;\",\n      \"for (var j = 0; j < this.length - i - 1; j++) {\",\n        \"if (opt_comp(this[j], this[j + 1]) > 0) {\",\n          \"var swap = this[j];\",\n          \"this[j] = this[j + 1];\",\n          \"this[j + 1] = swap;\",\n          \"changes++;\",\n        \"}\",\n      \"}\",\n      \"if (!changes) break;\",\n    \"}\",\n    \"return this;\",\n  \"};\",\n\"})();\",\n\n\"Object.defineProperty(Array.prototype, 'toLocaleString',\",\n    \"{configurable: true, writable: true, value:\",\n  \"function() {\",\n    \"var out = [];\",\n    \"for (var i = 0; i < this.length; i++) {\",\n      \"out[i] = (this[i] === null || this[i] === undefined) ? '' : this[i].toLocaleString();\",\n    \"}\",\n    \"return out.join(',');\",\n  \"}\",\n\"});\",\n\"\");\n};\n\n/**\n * Initialize the String class.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initString(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var wrapper;\n  // String constructor.\n  wrapper = function(value) {\n    value = String(value);\n    if (thisInterpreter.calledWithNew()) {\n      // Called as new String().\n      this.data = value;\n      return this;\n    } else {\n      // Called as String().\n      return value;\n    }\n  };\n  this.STRING = this.createNativeFunction(wrapper, true);\n  this.setProperty(scope, 'String', this.STRING);\n\n  // Static methods on String.\n  this.setProperty(this.STRING, 'fromCharCode',\n      this.createNativeFunction(String.fromCharCode, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on String.\n  // Methods with exclusively primitive arguments.\n  var functions = ['trim', 'toLowerCase', 'toUpperCase',\n      'toLocaleLowerCase', 'toLocaleUpperCase', 'charAt', 'charCodeAt',\n      'substring', 'slice', 'substr', 'indexOf', 'lastIndexOf', 'concat'];\n  for (var i = 0; i < functions.length; i++) {\n    this.setNativeFunctionPrototype(this.STRING, functions[i],\n                                    String.prototype[functions[i]]);\n  }\n\n  wrapper = function(compareString, locales, options) {\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\n    return String(this).localeCompare(compareString, locales, options);\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'localeCompare', wrapper);\n\n  wrapper = function(separator, limit) {\n    if (thisInterpreter.isa(separator, thisInterpreter.REGEXP)) {\n      separator = separator.data;\n    }\n    var jsList = String(this).split(separator, limit);\n    return thisInterpreter.nativeToPseudo(jsList);\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'split', wrapper);\n\n  wrapper = function(regexp) {\n    regexp = regexp ? regexp.data : undefined;\n    var match = String(this).match(regexp);\n    if (!match) {\n      return null;\n    }\n    return thisInterpreter.nativeToPseudo(match);\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'match', wrapper);\n\n  wrapper = function(regexp) {\n    if (thisInterpreter.isa(regexp, thisInterpreter.REGEXP)) {\n      regexp = regexp.data;\n    }\n    return String(this).search(regexp);\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'search', wrapper);\n\n  wrapper = function(substr, newSubstr) {\n    // Support for function replacements is the responsibility of a polyfill.\n    return String(this).replace(substr.data || substr, newSubstr);\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'replace', wrapper);\n  // Add a polyfill to handle replace's second argument being a function.\n  this.polyfills_.push(\n\"(function() {\",\n  \"var replace_ = String.prototype.replace;\",\n  \"String.prototype.replace = function(substr, newSubstr) {\",\n    \"if (typeof newSubstr !== 'function') {\",\n      // string.replace(string|regexp, string)\n      \"return replace_.call(this, substr, newSubstr);\",\n    \"}\",\n    \"var str = this;\",\n    \"if (substr instanceof RegExp) {\",  // string.replace(regexp, function)\n      \"var subs = [];\",\n      \"var m = substr.exec(str);\",\n      \"while (m) {\",\n        \"m.push(m.index, str);\",\n        \"var inject = newSubstr.apply(null, m);\",\n        \"subs.push([m.index, m[0].length, inject]);\",\n        \"m = substr.global ? substr.exec(str) : null;\",\n      \"}\",\n      \"for (var i = subs.length - 1; i >= 0; i--) {\",\n        \"str = str.substring(0, subs[i][0]) + subs[i][2] + \" +\n            \"str.substring(subs[i][0] + subs[i][1]);\",\n      \"}\",\n    \"} else {\",                         // string.replace(string, function)\n      \"var i = str.indexOf(substr);\",\n      \"if (i !== -1) {\",\n        \"var inject = newSubstr(str.substr(i, substr.length), i, str);\",\n        \"str = str.substring(0, i) + inject + \" +\n            \"str.substring(i + substr.length);\",\n      \"}\",\n    \"}\",\n    \"return str;\",\n  \"};\",\n\"})();\",\n\"\");\n};\n\n/**\n * Initialize the Boolean class.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initBoolean(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Boolean constructor.\n  wrapper = function(value) {\n    value = Boolean(value);\n    if (thisInterpreter.calledWithNew()) {\n      // Called as new Boolean().\n      this.data = value;\n      return this;\n    } else {\n      // Called as Boolean().\n      return value;\n    }\n  };\n  this.BOOLEAN = this.createNativeFunction(wrapper, true);\n  this.setProperty(scope, 'Boolean', this.BOOLEAN);\n};\n\n/**\n * Initialize the Number class.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initNumber(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Number constructor.\n  wrapper = function(value) {\n    value = Number(value);\n    if (thisInterpreter.calledWithNew()) {\n      // Called as new Number().\n      this.data = value;\n      return this;\n    } else {\n      // Called as Number().\n      return value;\n    }\n  };\n  this.NUMBER = this.createNativeFunction(wrapper, true);\n  this.setProperty(scope, 'Number', this.NUMBER);\n\n  var numConsts = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY',\n                   'POSITIVE_INFINITY'];\n  for (var i = 0; i < numConsts.length; i++) {\n    this.setProperty(this.NUMBER, numConsts[i], Number[numConsts[i]],\n        Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  }\n\n  // Instance methods on Number.\n  wrapper = function(fractionDigits) {\n    try {\n      return Number(this).toExponential(fractionDigits);\n    } catch (e) {\n      // Throws if fractionDigits isn't within 0-20.\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\n    }\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toExponential', wrapper);\n\n  wrapper = function(digits) {\n    try {\n      return Number(this).toFixed(digits);\n    } catch (e) {\n      // Throws if digits isn't within 0-20.\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\n    }\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toFixed', wrapper);\n\n  wrapper = function(precision) {\n    try {\n      return Number(this).toPrecision(precision);\n    } catch (e) {\n      // Throws if precision isn't within range (depends on implementation).\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\n    }\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toPrecision', wrapper);\n\n  wrapper = function(radix) {\n    try {\n      return Number(this).toString(radix);\n    } catch (e) {\n      // Throws if radix isn't within 2-36.\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\n    }\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toString', wrapper);\n\n  wrapper = function(locales, options) {\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\n    return Number(this).toLocaleString(locales, options);\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toLocaleString', wrapper);\n};\n\n/**\n * Initialize the Date class.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initDate(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Date constructor.\n  wrapper = function(value, var_args) {\n    if (!thisInterpreter.calledWithNew()) {\n      // Called as Date().\n      // Calling Date() as a function returns a string, no arguments are heeded.\n      return Date();\n    }\n    // Called as new Date().\n    var args = [null].concat([].slice.call(arguments));\n    this.data = new (Function.prototype.bind.apply(Date, args));\n    return this;\n  };\n  this.DATE = this.createNativeFunction(wrapper, true);\n  this.setProperty(scope, 'Date', this.DATE);\n\n  // Static methods on Date.\n  this.setProperty(this.DATE, 'now', this.createNativeFunction(Date.now, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  this.setProperty(this.DATE, 'parse',\n      this.createNativeFunction(Date.parse, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  this.setProperty(this.DATE, 'UTC', this.createNativeFunction(Date.UTC, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on Date.\n  var functions = ['getDate', 'getDay', 'getFullYear', 'getHours',\n      'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTime',\n      'getTimezoneOffset', 'getUTCDate', 'getUTCDay', 'getUTCFullYear',\n      'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth',\n      'getUTCSeconds', 'getYear',\n      'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\n      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate',\n      'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes',\n      'setUTCMonth', 'setUTCSeconds', 'setYear',\n      'toDateString', 'toISOString', 'toJSON', 'toGMTString',\n      'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString',\n      'toTimeString', 'toUTCString'];\n  for (var i = 0; i < functions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function(var_args) {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args[i] = thisInterpreter.pseudoToNative(arguments[i]);\n        }\n        return this.data[nativeFunc].apply(this.data, args);\n      };\n    })(functions[i]);\n    this.setNativeFunctionPrototype(this.DATE, functions[i], wrapper);\n  }\n};\n\n/**\n * Initialize Regular Expression object.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initRegExp(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var wrapper;\n  // RegExp constructor.\n  wrapper = function(pattern, flags) {\n    if (thisInterpreter.calledWithNew()) {\n      // Called as new RegExp().\n      var rgx = <Interpreter.MyObject>this;\n    } else {\n      // Called as RegExp().\n      var rgx = thisInterpreter.createObjectProto(thisInterpreter.REGEXP_PROTO);\n    }\n    pattern = pattern ? pattern.toString() : '';\n    flags = flags ? flags.toString() : '';\n    thisInterpreter.populateRegExp(rgx, new RegExp(pattern, flags));\n    return rgx;\n  };\n  this.REGEXP = this.createNativeFunction(wrapper, true);\n  this.REGEXP_PROTO = this.REGEXP.properties['prototype'];\n  this.setProperty(scope, 'RegExp', this.REGEXP);\n\n  this.setProperty(this.REGEXP.properties['prototype'], 'global', undefined,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.REGEXP.properties['prototype'], 'ignoreCase', undefined,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.REGEXP.properties['prototype'], 'multiline', undefined,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.REGEXP.properties['prototype'], 'source', '(?:)',\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(str) {\n    return this.data.test(str);\n  };\n  this.setNativeFunctionPrototype(this.REGEXP, 'test', wrapper);\n\n  wrapper = function(str) {\n    str = str.toString();\n    // Get lastIndex from wrapped regex, since this is settable.\n    this.data.lastIndex =\n        Number(thisInterpreter.getProperty(this, 'lastIndex'));\n    var match = this.data.exec(str);\n    thisInterpreter.setProperty(this, 'lastIndex', this.data.lastIndex);\n\n    if (match) {\n      var result =\n          thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\n      for (var i = 0; i < match.length; i++) {\n        thisInterpreter.setProperty(result, i, match[i]);\n      }\n      // match has additional properties.\n      thisInterpreter.setProperty(result, 'index', match.index);\n      thisInterpreter.setProperty(result, 'input', match.input);\n      return result;\n    }\n    return null;\n  };\n  this.setNativeFunctionPrototype(this.REGEXP, 'exec', wrapper);\n};\n\n/**\n * Initialize the Error class.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initError(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  // Error constructor.\n  this.ERROR = this.createNativeFunction(function(opt_message) {\n    if (thisInterpreter.calledWithNew()) {\n      // Called as new Error().\n      var newError = <Interpreter.MyObject>this;\n    } else {\n      // Called as Error().\n      var newError = thisInterpreter.createObject(thisInterpreter.ERROR);\n    }\n    if (opt_message) {\n      thisInterpreter.setProperty(newError, 'message', String(opt_message),\n          Interpreter.NONENUMERABLE_DESCRIPTOR);\n    }\n    return newError;\n  }, true);\n  this.setProperty(scope, 'Error', this.ERROR);\n  this.setProperty(this.ERROR.properties['prototype'], 'message', '',\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.ERROR.properties['prototype'], 'name', 'Error',\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  var createErrorSubclass = function(name) {\n    var constructor = thisInterpreter.createNativeFunction(\n        function(opt_message) {\n          if (thisInterpreter.calledWithNew()) {\n            // Called as new XyzError().\n            var newError = <Interpreter.MyObject>this;\n          } else {\n            // Called as XyzError().\n            var newError = thisInterpreter.createObject(constructor);\n          }\n          if (opt_message) {\n            thisInterpreter.setProperty(newError, 'message',\n                String(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\n          }\n          return newError;\n        }, true);\n    thisInterpreter.setProperty(constructor, 'prototype',\n        thisInterpreter.createObject(thisInterpreter.ERROR));\n    thisInterpreter.setProperty(constructor.properties['prototype'], 'name',\n        name, Interpreter.NONENUMERABLE_DESCRIPTOR);\n    thisInterpreter.setProperty(scope, name, constructor);\n\n    return constructor;\n  };\n\n  this.EVAL_ERROR = createErrorSubclass('EvalError');\n  this.RANGE_ERROR = createErrorSubclass('RangeError');\n  this.REFERENCE_ERROR = createErrorSubclass('ReferenceError');\n  this.SYNTAX_ERROR = createErrorSubclass('SyntaxError');\n  this.TYPE_ERROR = createErrorSubclass('TypeError');\n  this.URI_ERROR = createErrorSubclass('URIError');\n};\n\n/**\n * Initialize Math object.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initMath(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var myMath = this.createObjectProto(this.OBJECT_PROTO);\n  this.setProperty(scope, 'Math', myMath);\n  var mathConsts = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI',\n                    'SQRT1_2', 'SQRT2'];\n  for (var i = 0; i < mathConsts.length; i++) {\n    this.setProperty(myMath, mathConsts[i], Math[mathConsts[i]],\n        Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  }\n  var numFunctions = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos',\n                      'exp', 'floor', 'log', 'max', 'min', 'pow', 'random',\n                      'round', 'sin', 'sqrt', 'tan'];\n  for (var i = 0; i < numFunctions.length; i++) {\n    this.setProperty(myMath, numFunctions[i],\n        this.createNativeFunction(Math[numFunctions[i]], false),\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\n  }\n};\n\n/**\n * Initialize JSON object.\n * @param {!Interpreter.MyObject} scope Global scope.\n */\npublic initJSON(scope: Interpreter.MyObject) {\n  var thisInterpreter = this;\n  var myJSON = thisInterpreter.createObjectProto(this.OBJECT_PROTO);\n  this.setProperty(scope, 'JSON', myJSON);\n\n  var wrapper = function(text) {\n    try {\n      var nativeObj = JSON.parse(text.toString());\n    } catch (e) {\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, e.message);\n    }\n    return thisInterpreter.nativeToPseudo(nativeObj);\n  };\n  this.setProperty(myJSON, 'parse', this.createNativeFunction(wrapper, false));\n\n  wrapper = function(value) {\n    var nativeObj = thisInterpreter.pseudoToNative(value);\n    try {\n      var str = JSON.stringify(nativeObj);\n    } catch (e) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, e.message);\n    }\n    return str;\n  };\n  this.setProperty(myJSON, 'stringify',\n      this.createNativeFunction(wrapper, false));\n};\n\n/**\n * Is an object of a certain class?\n * @param {Interpreter.MyValue} child Object to check.\n * @param {Interpreter.MyObject} constructor Constructor of object.\n * @return {boolean} True if object is the class or inherits from it.\n *     False otherwise.\n */\npublic isa(child: Interpreter.MyValue, constructor: Interpreter.MyObject) {\n  if (child === null || child === undefined || !constructor) {\n    return false;\n  }\n  var proto = constructor.properties['prototype'];\n  if (child === proto) {\n    return true;\n  }\n  // The first step up the prototype chain is harder since the child might be\n  // a primitive value.  Subsequent steps can just follow the .proto property.\n  var childObj = this.getPrototype(child);\n  while (childObj) {\n    if (childObj === proto) {\n      return true;\n    }\n    childObj = childObj.proto;\n  }\n  return false;\n};\n\n/**\n * Is a value a legal integer for an array length?\n * @param {Interpreter.MyValue} x Value to check.\n * @return {number} Zero, or a positive integer if the value can be\n *     converted to such.  NaN otherwise.\n */\nstatic legalArrayLength(x: Interpreter.MyValue) {\n  var n = <number>x >>> 0;\n  // Array length must be between 0 and 2^32-1 (inclusive).\n  return (n === Number(x)) ? n : NaN;\n};\n\n/**\n * Is a value a legal integer for an array index?\n * @param {Interpreter.MyValue} x Value to check.\n * @return {number} Zero, or a positive integer if the value can be\n *     converted to such.  NaN otherwise.\n */\nstatic legalArrayIndex(x: Interpreter.MyValue) {\n  var n = <number>x >>> 0;\n  // Array index cannot be 2^32-1, otherwise length would be 2^32.\n  // 0xffffffff is 2^32-1.\n  return (String(n) === String(x) && n !== 0xffffffff) ? n : NaN;\n};\n\n/**\n * Create a new data object based on a constructor's prototype.\n * @param {Interpreter.MyObject} constructor Parent constructor function,\n *     or null if scope object.\n * @return {!Interpreter.MyObject} New data object.\n */\npublic createObject(constructor: Interpreter.MyObject) {\n  return this.createObjectProto(constructor &&\n                                constructor.properties['prototype']);\n};\n\n/**\n * Create a new data object based on a prototype.\n * @param {Interpreter.MyObject} proto Prototype object.\n * @return {!Interpreter.MyObject} New data object.\n */\npublic createObjectProto(proto: Interpreter.MyObject) {\n  var obj = new Interpreter.MyObject(proto);\n  // Functions have prototype objects.\n  if (this.isa(obj, this.FUNCTION)) {\n    this.setProperty(obj, 'prototype',\n                     this.createObjectProto(this.OBJECT_PROTO || null));\n    obj.class = 'Function';\n  }\n  // Arrays have length.\n  if (this.isa(obj, this.ARRAY)) {\n    this.setProperty(obj, 'length', 0,\n        {configurable: false, enumerable: false, writable: true});\n    obj.class = 'Array';\n  }\n  if (this.isa(obj, this.ERROR)) {\n    obj.class = 'Error';\n  }\n  return obj;\n};\n\n/**\n * Initialize a pseudo regular expression object based on a native regular\n * expression object.\n * @param {!Interpreter.MyObject} pseudoRegexp The existing object to set.\n * @param {!RegExp} nativeRegexp The native regular expression.\n */\npublic populateRegExp(pseudoRegexp: Interpreter.MyObject, nativeRegexp: RegExp) {\n  pseudoRegexp.data = nativeRegexp;\n  // lastIndex is settable, all others are read-only attributes\n  this.setProperty(pseudoRegexp, 'lastIndex', nativeRegexp.lastIndex,\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'source', nativeRegexp.source,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'global', nativeRegexp.global,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'ignoreCase', nativeRegexp.ignoreCase,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'multiline', nativeRegexp.multiline,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n};\n\n/**\n * Create a new function.\n * @param {!Object} node AST node defining the function.\n * @param {!Object} scope Parent scope.\n * @return {!Interpreter.MyObject} New function.\n */\npublic createFunction(node: ESTree.FunctionDeclaration, scope: Interpreter.MyObject) {\n  var func = this.createObjectProto(this.FUNCTION_PROTO);\n  func.parentScope = scope;\n  func.node = node;\n  this.setProperty(func, 'length', func.node['params'].length,\n      Interpreter.READONLY_DESCRIPTOR);\n  return func;\n};\n\n/**\n * Create a new native function.\n * @param {!Function} nativeFunc JavaScript function.\n * @param {boolean=} opt_constructor If true, the function's\n * prototype will have its constructor property set to the function.\n * If false, the function cannot be called as a constructor (e.g. escape).\n * Defaults to undefined.\n * @return {!Interpreter.MyObject} New function.\n */\npublic createNativeFunction(nativeFunc: Interpreter.NativeFunction, opt_constructor?: boolean) {\n  var func = this.createObjectProto(this.FUNCTION_PROTO);\n  func.nativeFunc = nativeFunc;\n  nativeFunc.id = this.functionCounter_++;\n  this.setProperty(func, 'length', nativeFunc.length,\n      Interpreter.READONLY_DESCRIPTOR);\n  if (opt_constructor) {\n    this.setProperty(func.properties['prototype'], 'constructor',\n        func, Interpreter.NONENUMERABLE_DESCRIPTOR);\n  } else if (opt_constructor === false) {\n    func.illegalConstructor = true;\n    this.setProperty(func, 'prototype', undefined);\n  }\n  return func;\n};\n\n/**\n * Create a new native asynchronous function.\n * @param {!Function} asyncFunc JavaScript function.\n * @return {!Interpreter.MyObject} New function.\n */\npublic createAsyncFunction(asyncFunc) {\n  var func = this.createObjectProto(this.FUNCTION_PROTO);\n  func.asyncFunc = asyncFunc;\n  asyncFunc.id = this.functionCounter_++;\n  this.setProperty(func, 'length', asyncFunc.length,\n      Interpreter.READONLY_DESCRIPTOR);\n  return func;\n};\n\n/**\n * Converts from a native JS object or value to a JS interpreter object.\n * Can handle JSON-style values.\n * @param {*} nativeObj The native JS object to be converted.\n * @return {Interpreter.MyValue} The equivalent JS interpreter object.\n */\npublic nativeToPseudo(nativeObj: any): Interpreter.MyValue {\n  if (typeof nativeObj === 'boolean' ||\n      typeof nativeObj === 'number' ||\n      typeof nativeObj === 'string' ||\n      nativeObj === null || nativeObj === undefined) {\n    return nativeObj;\n  }\n\n  if (nativeObj instanceof RegExp) {\n    var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\n    this.populateRegExp(pseudoRegexp, nativeObj);\n    return pseudoRegexp;\n  }\n\n  if (nativeObj instanceof Function) {\n    var interpreter = this;\n    var wrapper = function() {\n      return interpreter.nativeToPseudo(\n        nativeObj.apply(interpreter,\n          Array.prototype.slice.call(arguments)\n          .map(function(i) {\n            return interpreter.pseudoToNative(i);\n          })\n        )\n      );\n    };\n    return this.createNativeFunction(wrapper, undefined);\n  }\n\n  var pseudoObj: Interpreter.MyObject;\n  if (Array.isArray(nativeObj)) {  // Array.\n    pseudoObj = this.createObjectProto(this.ARRAY_PROTO);\n    for (var i = 0; i < nativeObj.length; i++) {\n      if (i in nativeObj) {\n        this.setProperty(pseudoObj, i, this.nativeToPseudo(nativeObj[i]));\n      }\n    }\n  } else {  // Object.\n    pseudoObj = this.createObjectProto(this.OBJECT_PROTO);\n    for (var key in nativeObj) {\n      this.setProperty(pseudoObj, key, this.nativeToPseudo(nativeObj[key]));\n    }\n  }\n  return pseudoObj;\n};\n\n/**\n * Converts from a JS interpreter object to native JS object.\n * Can handle JSON-style values, plus cycles.\n * @param {Interpreter.MyValue} pseudoObj The JS interpreter object to be\n * converted.\n * @param {Object=} opt_cycles Cycle detection (used in recursive calls).\n * @return {*} The equivalent native JS object or value.\n */\npublic pseudoToNative(pseudoObj: Interpreter.MyValue, opt_cycles?: Interpreter.MyValueTable) {\n  if (typeof pseudoObj === 'boolean' ||\n      typeof pseudoObj === 'number' ||\n      typeof pseudoObj === 'string' ||\n      pseudoObj === null || pseudoObj === undefined) {\n    return pseudoObj;\n  }\n\n  if (this.isa(pseudoObj, this.REGEXP)) {  // Regular expression.\n    return pseudoObj.data;\n  }\n\n  var cycles = opt_cycles || {\n    pseudo: [],\n    native: []\n  };\n  var i = cycles.pseudo.indexOf(pseudoObj);\n  if (i !== -1) {\n    return cycles.native[i];\n  }\n  cycles.pseudo.push(pseudoObj);\n  var nativeObj;\n  if (this.isa(pseudoObj, this.ARRAY)) {  // Array.\n    nativeObj = [];\n    cycles.native.push(nativeObj);\n    var length = this.getProperty(pseudoObj, 'length');\n    for (var i = 0; i < length; i++) {\n      if (this.hasProperty(pseudoObj, i)) {\n        nativeObj[i] =\n            this.pseudoToNative(this.getProperty(pseudoObj, i), cycles);\n      }\n    }\n  } else {  // Object.\n    nativeObj = {};\n    cycles.native.push(nativeObj);\n    var val;\n    for (var key in pseudoObj.properties) {\n      val = pseudoObj.properties[key];\n      nativeObj[key] = this.pseudoToNative(val, cycles);\n    }\n  }\n  cycles.pseudo.pop();\n  cycles.native.pop();\n  return nativeObj;\n};\n\n/**\n * Look up the prototype for this value.\n * @param {Interpreter.MyValue} value Data object.\n * @return {Interpreter.MyObject} Prototype object, null if none.\n */\npublic getPrototype(value: Interpreter.MyValue): Interpreter.MyObject {\n  switch (typeof value) {\n    case 'number':\n      return this.NUMBER.properties['prototype'];\n    case 'boolean':\n      return this.BOOLEAN.properties['prototype'];\n    case 'string':\n      return this.STRING.properties['prototype'];\n  }\n  if (value) {\n    return (<Interpreter.MyObject>value).proto;\n  }\n  return null;\n};\n\n/**\n * Fetch a property value from a data object.\n * @param {Interpreter.MyValue} obj Data object.\n * @param {Interpreter.MyValue} name Name of property.\n * @return {Interpreter.MyValue} Property value (may be undefined).\n */\npublic getProperty(obj: Interpreter.MyValue, name: Interpreter.MyValue): Interpreter.MyValue {\n  name = String(name);\n  if (obj === undefined || obj === null) {\n    this.throwException(this.TYPE_ERROR,\n                        \"Cannot read property '\" + name + \"' of \" + obj);\n  }\n  if (name === 'length') {\n    // Special cases for magic length property.\n    if (this.isa(obj, this.STRING)) {\n      return String(obj).length;\n    }\n  } else if (name.charCodeAt(0) < 0x40) {\n    // Might have numbers in there?\n    // Special cases for string array indexing\n    if (this.isa(obj, this.STRING)) {\n      var n = Interpreter.legalArrayIndex(name);\n      if (!isNaN(n) && n < String(obj).length) {\n        return String(obj)[n];\n      }\n    }\n  }\n  do {\n    const myObj = <Interpreter.MyObject>obj;\n    if (myObj.properties && name in myObj.properties) {\n      var getter = myObj.getter[name];\n      if (getter) {\n        // Flag this function as being a getter and thus needing immediate\n        // execution (rather than being the value of the property).\n        getter.isGetter = true;\n        return getter;\n      }\n      return myObj.properties[name];\n    }\n  } while ((obj = this.getPrototype(obj)));\n  return undefined;\n};\n\n/**\n * Does the named property exist on a data object.\n * @param {Interpreter.MyValue} obj Data object.\n * @param {Interpreter.MyValue} name Name of property.\n * @return {boolean} True if property exists.\n */\npublic hasProperty(obj: Interpreter.MyValue, name: Interpreter.MyValue) {\n  if (!obj['isObject']) {\n    throw TypeError('Primitive data type has no properties');\n  }\n  name = String(name);\n  if (name === 'length' && this.isa(obj, this.STRING)) {\n    return true;\n  }\n  if (this.isa(obj, this.STRING)) {\n    var n = Interpreter.legalArrayIndex(name);\n    if (!isNaN(n) && n < String(obj).length) {\n      return true;\n    }\n  }\n  do {\n    const myObj = <Interpreter.MyObject> obj;\n    if (myObj.properties && name in myObj.properties) {\n      return true;\n    }\n  } while ((obj = this.getPrototype(obj)));\n  return false;\n};\n\n/**\n * Set a property value on a data object.\n * @param {!Interpreter.MyObject} obj Data object.\n * @param {Interpreter.MyValue} name Name of property.\n * @param {Interpreter.MyValue|ReferenceError} value New property value.\n *   Use ReferenceError if value is handled by descriptor instead.\n * @param {Object=} opt_descriptor Optional descriptor object.\n * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\n *     needs to be called, otherwise undefined.\n */\npublic setProperty(obj: Interpreter.MyObject, name: Interpreter.MyValue, value: Interpreter.MyValue | ReferenceErrorConstructor, opt_descriptor?): Interpreter.MyObject {\n  name = String(name);\n  if (obj === undefined || obj === null) {\n    this.throwException(this.TYPE_ERROR,\n                        \"Cannot set property '\" + name + \"' of \" + obj);\n  }\n  if (opt_descriptor && ('get' in opt_descriptor || 'set' in opt_descriptor) &&\n      ('value' in opt_descriptor || 'writable' in opt_descriptor)) {\n    this.throwException(this.TYPE_ERROR, 'Invalid property descriptor. ' +\n        'Cannot both specify accessors and a value or writable attribute');\n  }\n  var strict = !this.stateStack || this.getScope().strict;\n  if (!obj.isObject) {\n    if (strict) {\n      this.throwException(this.TYPE_ERROR, \"Can't create property '\" + name +\n                          \"' on '\" + obj + \"'\");\n    }\n    return;\n  }\n  if (this.isa(obj, this.STRING)) {\n    var n = Interpreter.legalArrayIndex(name);\n    if (name === 'length' || (!isNaN(n) && n < String(obj).length)) {\n      // Can't set length or letters on String objects.\n      if (strict) {\n        this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\n            \"property '\" + name + \"' of String '\" + obj.data + \"'\");\n      }\n      return;\n    }\n  }\n  if (obj.class === 'Array') {\n    // Arrays have a magic length variable that is bound to the elements.\n    var length = obj.properties.length;\n    var i;\n    if (name === 'length') {\n      // Delete elements if length is smaller.\n      value = Interpreter.legalArrayLength(<number>value);\n      if (isNaN(value)) {\n        this.throwException(this.RANGE_ERROR, 'Invalid array length');\n      }\n      if (value < length) {\n        for (i in obj.properties) {\n          i = Interpreter.legalArrayIndex(i);\n          if (!isNaN(i) && value <= i) {\n            delete obj.properties[i];\n          }\n        }\n      }\n    } else if (!isNaN(i = Interpreter.legalArrayIndex(name))) {\n      // Increase length if this index is larger.\n      obj.properties.length = Math.max(length, i + 1);\n    }\n  }\n  if (obj.preventExtensions && !(name in obj.properties)) {\n    if (strict) {\n      this.throwException(this.TYPE_ERROR, \"Can't add property '\" + name +\n                          \"', object is not extensible\");\n    }\n    return;\n  }\n  if (opt_descriptor) {\n    // Define the property.\n    if ('get' in opt_descriptor) {\n      if (opt_descriptor.get) {\n        obj.getter[name] = opt_descriptor.get;\n      } else {\n        delete obj.getter[name];\n      }\n    }\n    if ('set' in opt_descriptor) {\n      if (opt_descriptor.set) {\n        obj.setter[name] = opt_descriptor.set;\n      } else {\n        delete obj.setter[name];\n      }\n    }\n    var descriptor: Interpreter.MyDescriptor = {};\n    if ('configurable' in opt_descriptor) {\n      descriptor.configurable = opt_descriptor.configurable;\n    }\n    if ('enumerable' in opt_descriptor) {\n      descriptor.enumerable = opt_descriptor.enumerable;\n    }\n    if ('writable' in opt_descriptor) {\n      descriptor.writable = opt_descriptor.writable;\n      delete obj.getter[name];\n      delete obj.setter[name];\n    }\n    if ('value' in opt_descriptor) {\n      descriptor.value = opt_descriptor.value;\n      delete obj.getter[name];\n      delete obj.setter[name];\n    } else if (value !== ReferenceError) {\n      descriptor.value = value;\n      delete obj.getter[name];\n      delete obj.setter[name];\n    }\n    try {\n      Object.defineProperty(obj.properties, name, <any>descriptor);\n    } catch (e) {\n      this.throwException(this.TYPE_ERROR, 'Cannot redefine property: ' + name);\n    }\n  } else {\n    // Set the property.\n    if (value === ReferenceError) {\n      throw ReferenceError('Value not specified.');\n    }\n    // Determine the parent (possibly self) where the property is defined.\n    var defObj = obj;\n    while (!(name in defObj.properties)) {\n      defObj = this.getPrototype(defObj);\n      if (!defObj) {\n        // This is a new property.\n        defObj = obj;\n        break;\n      }\n    }\n    if (defObj.setter && defObj.setter[name]) {\n      return defObj.setter[name];\n    }\n    if (defObj.getter && defObj.getter[name]) {\n      if (strict) {\n        this.throwException(this.TYPE_ERROR, \"Cannot set property '\" + name +\n            \"' of object '\" + obj + \"' which only has a getter\");\n      }\n    } else {\n      // No setter, simple assignment.\n      try {\n        obj.properties[name] = value;\n      } catch (e) {\n        if (strict) {\n          this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\n              \"property '\" + name + \"' of object '\" + obj + \"'\");\n        }\n      }\n    }\n  }\n};\n\n/**\n * Convenience method for adding a native function as a non-enumerable property\n * onto an object's prototype.\n * @param {!Interpreter.MyObject} obj Data object.\n * @param {Interpreter.MyValue} name Name of property.\n * @param {!Function} wrapper Function object.\n */\nprivate setNativeFunctionPrototype(obj: Interpreter.MyObject, name: Interpreter.MyValue, wrapper: Function) {\n  this.setProperty(obj.properties['prototype'], name,\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n};\n\n/**\n * Returns the current scope from the stateStack.\n * @return {!Interpreter.MyObject} Current scope dictionary.\n */\npublic getScope() {\n  var scope = this.stateStack[this.stateStack.length - 1].scope;\n  if (!scope) {\n    throw Error('No scope found.');\n  }\n  return scope;\n};\n\n/**\n * Create a new scope dictionary.\n * @param {!Object} node AST node defining the scope container\n *     (e.g. a function).\n * @param {Interpreter.MyObject} parentScope Scope to link to.\n * @return {!Interpreter.MyObject} New scope.\n */\npublic createScope(node: ESTree.Node, parentScope: Interpreter.MyObject) {\n  var scope = this.createObjectProto(null);\n  scope.parentScope = parentScope;\n  if (!parentScope) {\n    this.initGlobalScope(scope);\n  }\n  this.populateScope_(node, scope);\n\n  // Determine if this scope starts with 'use strict'.\n  scope.strict = false;\n  if (parentScope && parentScope.strict) {\n    scope.strict = true;\n  } else {\n    var firstNode = node['body'] && node['body'][0];\n    if (firstNode && firstNode.expression &&\n        firstNode.expression['type'] === 'Literal' &&\n        firstNode.expression.value === 'use strict') {\n      scope.strict = true;\n    }\n  }\n  return scope;\n};\n\n/**\n * Create a new special scope dictionary. Similar to createScope(), but\n * doesn't assume that the scope is for a function body.\n * This is used for 'catch' clauses and 'with' statements.\n * @param {!Interpreter.MyObject} parentScope Scope to link to.\n * @param {Interpreter.MyObject=} opt_scope Optional object to transform into\n *     scope.\n * @return {!Interpreter.MyObject} New scope.\n */\npublic createSpecialScope(parentScope: Interpreter.MyObject, opt_scope?: Interpreter.MyObject) {\n  if (!parentScope) {\n    throw Error('parentScope required');\n  }\n  var scope = opt_scope || this.createObjectProto(null);\n  scope.parentScope = parentScope;\n  scope.strict = parentScope.strict;\n  return scope;\n};\n\n/**\n * Retrieves a value from the scope chain.\n * @param {string} name Name of variable.\n * @return {Interpreter.MyValue} Any value.\n *   May be flagged as being a getter and thus needing immediate execution\n *   (rather than being the value of the property).\n */\npublic getValueFromScope(name: string): Interpreter.MyValue {\n  var scope = this.getScope();\n  while (scope && scope !== this.global) {\n    if (name in scope.properties) {\n      return scope.properties[name];\n    }\n    scope = scope.parentScope;\n  }\n  // The root scope is also an object which has inherited properties and\n  // could also have getters.\n  if (scope === this.global && this.hasProperty(scope, name)) {\n    return this.getProperty(scope, name);\n  }\n  // Typeof operator is unique: it can safely look at non-defined variables.\n  var prevNode = this.stateStack[this.stateStack.length - 1].node;\n  if (prevNode['type'] === 'UnaryExpression' &&\n      prevNode['operator'] === 'typeof') {\n    return undefined;\n  }\n  this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\n};\n\n/**\n * Sets a value to the current scope.\n * @param {string} name Name of variable.\n * @param {Interpreter.MyValue} value Value.\n * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\n *     needs to be called, otherwise undefined.\n */\npublic setValueToScope(name: string, value: Interpreter.MyValue) {\n  var scope = this.getScope();\n  var strict = scope.strict;\n  while (scope && scope !== this.global) {\n    if (name in scope.properties) {\n      scope.properties[name] = value;\n      return undefined;\n    }\n    scope = scope.parentScope;\n  }\n  // The root scope is also an object which has readonly properties and\n  // could also have setters.\n  if (scope === this.global && (!strict || this.hasProperty(scope, name))) {\n    return this.setProperty(scope, name, value);\n  }\n  this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\n};\n\n/**\n * Create a new scope for the given node.\n * @param {!Object} node AST node (program or function).\n * @param {!Interpreter.MyObject} scope Scope dictionary to populate.\n * @private\n */\npublic populateScope_(node: ESTree.Node, scope: Interpreter.MyObject) {\n  if (node['type'] === 'VariableDeclaration') {\n    for (var i = 0; i < node['declarations'].length; i++) {\n      this.setProperty(scope, node['declarations'][i]['id']['name'],\n          undefined, Interpreter.VARIABLE_DESCRIPTOR);\n    }\n  } else if (node['type'] === 'FunctionDeclaration') {\n    this.setProperty(scope, node['id']['name'],\n        this.createFunction(<ESTree.FunctionDeclaration>node, scope), Interpreter.VARIABLE_DESCRIPTOR);\n    return;  // Do not recurse into function.\n  } else if (node['type'] === 'FunctionExpression') {\n    return;  // Do not recurse into function.\n  } else if (node['type'] === 'ExpressionStatement') {\n    return;  // Expressions can't contain variable/function declarations.\n  }\n  var nodeClass = node['constructor'];\n  for (var name in node) {\n    var prop = node[name];\n    if (prop && typeof prop === 'object') {\n      if (Array.isArray(prop)) {\n        for (var i = 0; i < prop.length; i++) {\n          if (prop[i] && prop[i].constructor === nodeClass) {\n            this.populateScope_(prop[i], scope);\n          }\n        }\n      } else {\n        if (prop.constructor === nodeClass) {\n          this.populateScope_(prop, scope);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Remove start and end values from AST, or set start and end values to a\n * constant value.  Used to remove highlighting from polyfills and to set\n * highlighting in an eval to cover the entire eval expression.\n * @param {!Object} node AST node.\n * @param {number=} start Starting character of all nodes, or undefined.\n * @param {number=} end Ending character of all nodes, or undefined.\n * @private\n */\nprivate stripLocations_(node: ESTree.BaseNode, start: number, end: number) {\n  if (start) {\n    node['start'] = start;\n  } else {\n    delete node['start'];\n  }\n  if (end) {\n    node['end'] = end;\n  } else {\n    delete node['end'];\n  }\n  for (var name in node) {\n    if (node.hasOwnProperty(name)) {\n      var prop = node[name];\n      if (prop && typeof prop === 'object') {\n        this.stripLocations_(prop, start, end);\n      }\n    }\n  }\n};\n\n/**\n * Is the current state directly being called with as a construction with 'new'.\n * @return {boolean} True if 'new foo()', false if 'foo()'.\n */\npublic calledWithNew(): boolean {\n  return this.stateStack[this.stateStack.length - 1].isConstructor;\n};\n\n/**\n * Gets a value from the scope chain or from an object property.\n * @param {!Array} ref Name of variable or object/propname tuple.\n * @return {Interpreter.MyValue} Any value.\n *   May be flagged as being a getter and thus needing immediate execution\n *   (rather than being the value of the property).\n */\npublic getValue(ref) {\n  if (ref[0] === Interpreter.SCOPE_REFERENCE) {\n    // A null/varname variable lookup.\n    return this.getValueFromScope(ref[1]);\n  } else {\n    // An obj/prop components tuple (foo.bar).\n    return this.getProperty(ref[0], ref[1]);\n  }\n};\n\n/**\n * Sets a value to the scope chain or to an object property.\n * @param {!Array} ref Name of variable or object/propname tuple.\n * @param {Interpreter.MyValue} value Value.\n * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\n *     needs to be called, otherwise undefined.\n */\npublic setValue(ref: Array<any> & { 0: Interpreter.MyObject, 1: string }, value: Interpreter.MyValue) {\n  if (ref[0] === Interpreter.SCOPE_REFERENCE) {\n    // A null/varname variable lookup.\n    return this.setValueToScope(ref[1], value);\n  } else {\n    // An obj/prop components tuple (foo.bar).\n    return this.setProperty(ref[0], ref[1], value);\n  }\n};\n\n/**\n * Throw an exception in the interpreter that can be handled by an\n * interpreter try/catch statement.  If unhandled, a real exception will\n * be thrown.  Can be called with either an error class and a message, or\n * with an actual object to be thrown.\n * @param {!Interpreter.MyObject} errorClass Type of error (if message is\n *   provided) or the value to throw (if no message).\n * @param {string=} opt_message Message being thrown.\n */\npublic throwException(errorClass: Interpreter.MyObject, opt_message?: string) {\n  if (opt_message === undefined) {\n    var error = <Interpreter.MyObject>errorClass;  // This is a value to throw, not an error class.\n  } else {\n    var error = this.createObject(errorClass);\n    this.setProperty(error, 'message', opt_message,\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\n  }\n  this.executeException(error);\n  // Abort anything related to the current step.\n  throw Interpreter.STEP_ERROR;\n};\n\n/**\n * Throw an exception in the interpreter that can be handled by a\n * interpreter try/catch statement.  If unhandled, a real exception will\n * be thrown.\n * @param {!Interpreter.MyObject} error Error object to execute.\n */\npublic executeException(error: Interpreter.MyObject) {\n  // Search for a try statement.\n  const stateStack = this.stateStack.slice();\n  do {\n    this.stateStack.pop();\n    var state = this.stateStack[this.stateStack.length - 1];\n    if (state.node['type'] === 'TryStatement') {\n      state.throwValue = error;\n      return;\n    }\n  } while (state && state.node['type'] !== 'Program');\n\n  // Throw a real error.\n  var realError;\n  if (this.isa(error, this.ERROR)) {\n    var errorTable = {\n      'EvalError': EvalError,\n      'RangeError': RangeError,\n      'ReferenceError': ReferenceError,\n      'SyntaxError': SyntaxError,\n      'TypeError': TypeError,\n      'URIError': URIError\n    };\n    var name = this.getProperty(error, 'name').toString();\n    var message = this.getProperty(error, 'message').valueOf();\n    var type = errorTable[name] || Error;\n    realError = type(message);\n  } else {\n    realError = String(error);\n  }\n  this.stateStack = stateStack; // recover the original state stack\n  throw realError;\n};\n\n/**\n * Create a call to a getter function.\n * @param {!Interpreter.MyObject} func Function to execute.\n * @param {!Interpreter.MyObject|!Array} left\n *     Name of variable or object/propname tuple.\n * @private\n */\npublic createGetter_(func: Interpreter.MyObject, left: Interpreter.MyObject | Array<Interpreter.MyObject>) {\n  // Normally 'this' will be specified as the object component (o.x).\n  // Sometimes 'this' is explicitly provided (o).\n  var funcThis = Array.isArray(left) ? left[0] : left;\n  var node = new this.nodeConstructor();\n  node['type'] = 'CallExpression';\n  var state = new Interpreter.MyState(node,\n      this.stateStack[this.stateStack.length - 1].scope);\n  state.doneCallee_ = true;\n  state.funcThis_ = funcThis;\n  state.func_ = func;\n  state.doneArgs_ = true;\n  state.arguments_ = [];\n  return state;\n};\n\n/**\n * Create a call to a setter function.\n * @param {!Interpreter.MyObject} func Function to execute.\n * @param {!Interpreter.MyObject|!Array} left\n *     Name of variable or object/propname tuple.\n * @param {Interpreter.MyValue} value Value to set.\n * @private\n */\npublic createSetter_(func: Interpreter.MyObject, left: Interpreter.MyObject | Array<Interpreter.MyObject>, value: Interpreter.MyValue) {\n  // Normally 'this' will be specified as the object component (o.x).\n  // Sometimes 'this' is implicitly the global object (x).\n  var funcThis = Array.isArray(left) ? left[0] : this.global;\n  var node = new this.nodeConstructor();\n  node['type'] = 'CallExpression';\n  var state = new Interpreter.MyState(node,\n      this.stateStack[this.stateStack.length - 1].scope);\n  state.doneCallee_ = true;\n  state.funcThis_ = funcThis;\n  state.func_ = func;\n  state.doneArgs_ = true;\n  state.arguments_ = [value];\n  return state;\n};\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Functions to handle each node type.\n///////////////////////////////////////////////////////////////////////////////\n\nprivate stepArrayExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  var elements = node['elements'];\n  var n = state.n_ || 0;\n  if (!state.array_) {\n    state.array_ = this.createObjectProto(this.ARRAY_PROTO);\n    state.array_.properties.length = elements.length;\n  } else {\n    this.setProperty(state.array_, n, state.value);\n    n++;\n  }\n  while (n < elements.length) {\n    // Skip missing elements - they're not defined, not undefined.\n    if (elements[n]) {\n      state.n_ = n;\n      return new Interpreter.MyState(elements[n], state.scope);\n    }\n    n++;\n  }\n  stack.pop();\n  stack[stack.length - 1].value = state.array_;\n};\n\nprivate stepAssignmentExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    var nextState = new Interpreter.MyState(node['left'], state.scope);\n    nextState.components = true;\n    return nextState;\n  }\n  if (!state.doneRight_) {\n    if (!state.leftReference_) {\n      state.leftReference_ = state.value;\n    }\n    if (state.doneGetter_) {\n      state.leftValue_ = state.value;\n    }\n    if (!state.doneGetter_ && node['operator'] !== '=') {\n      var leftValue = this.getValue(state.leftReference_);\n      state.leftValue_ = leftValue;\n      if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\n        // Clear the getter flag and call the getter function.\n        leftValue.isGetter = false;\n        state.doneGetter_ = true;\n        var func = /** @type {!Interpreter.Object} */ (leftValue);\n        return this.createGetter_(func, state.leftReference_);\n      }\n    }\n    state.doneRight_ = true;\n    return new Interpreter.MyState(node['right'], state.scope);\n  }\n  if (state.doneSetter_) {\n    // Return if setter function.\n    // Setter method on property has completed.\n    // Ignore its return value, and use the original set value instead.\n    stack.pop();\n    stack[stack.length - 1].value = state.doneSetter_;\n    return;\n  }\n  var value = state.leftValue_;\n  var rightValue = state.value;\n  switch (node['operator']) {\n    case '=':    value =    rightValue; break;\n    case '+=':   value +=   rightValue; break;\n    case '-=':   value -=   rightValue; break;\n    case '*=':   value *=   rightValue; break;\n    case '/=':   value /=   rightValue; break;\n    case '%=':   value %=   rightValue; break;\n    case '<<=':  value <<=  rightValue; break;\n    case '>>=':  value >>=  rightValue; break;\n    case '>>>=': value >>>= rightValue; break;\n    case '&=':   value &=   rightValue; break;\n    case '^=':   value ^=   rightValue; break;\n    case '|=':   value |=   rightValue; break;\n    default:\n      throw SyntaxError('Unknown assignment expression: ' + node['operator']);\n  }\n  var setter = this.setValue(state.leftReference_, value);\n  if (setter) {\n    state.doneSetter_ = value;\n    return this.createSetter_(setter, state.leftReference_, value);\n  }\n  // Return if no setter function.\n  stack.pop();\n  stack[stack.length - 1].value = value;\n};\n\nprivate stepBinaryExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    return new Interpreter.MyState(node['left'], state.scope);\n  }\n  if (!state.doneRight_) {\n    state.doneRight_ = true;\n    state.leftValue_ = state.value;\n    return new Interpreter.MyState(node['right'], state.scope);\n  }\n  stack.pop();\n  var leftValue = state.leftValue_;\n  var rightValue = state.value;\n  var value;\n  switch (node['operator']) {\n    case '==':  value = leftValue ==  rightValue; break;\n    case '!=':  value = leftValue !=  rightValue; break;\n    case '===': value = leftValue === rightValue; break;\n    case '!==': value = leftValue !== rightValue; break;\n    case '>':   value = leftValue >   rightValue; break;\n    case '>=':  value = leftValue >=  rightValue; break;\n    case '<':   value = leftValue <   rightValue; break;\n    case '<=':  value = leftValue <=  rightValue; break;\n    case '+':   value = leftValue +   rightValue; break;\n    case '-':   value = leftValue -   rightValue; break;\n    case '*':   value = leftValue *   rightValue; break;\n    case '/':   value = leftValue /   rightValue; break;\n    case '%':   value = leftValue %   rightValue; break;\n    case '&':   value = leftValue &   rightValue; break;\n    case '|':   value = leftValue |   rightValue; break;\n    case '^':   value = leftValue ^   rightValue; break;\n    case '<<':  value = leftValue <<  rightValue; break;\n    case '>>':  value = leftValue >>  rightValue; break;\n    case '>>>': value = leftValue >>> rightValue; break;\n    case 'in':\n      if (!rightValue || !rightValue.isObject) {\n        this.throwException(this.TYPE_ERROR,\n            \"'in' expects an object, not '\" + rightValue + \"'\");\n      }\n      value = this.hasProperty(rightValue, leftValue);\n      break;\n    case 'instanceof':\n      if (!this.isa(rightValue, this.FUNCTION)) {\n        this.throwException(this.TYPE_ERROR,\n            'Right-hand side of instanceof is not an object');\n      }\n      value = leftValue.isObject ? this.isa(leftValue, rightValue) : false;\n      break;\n    default:\n      throw SyntaxError('Unknown binary operator: ' + node['operator']);\n  }\n  stack[stack.length - 1].value = value;\n};\n\nprivate stepBlockStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  var n = state.n_ || 0;\n  var expression = node['body'][n];\n  if (expression) {\n    state.n_ = n + 1;\n    return new Interpreter.MyState(expression, state.scope);\n  }\n  stack.pop();\n};\n\nprivate stepBreakStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  stack.pop();\n  var label = null;\n  if (node['label']) {\n    label = node['label']['name'];\n  }\n  while (state &&\n         state.node['type'] !== 'CallExpression' &&\n         state.node['type'] !== 'NewExpression') {\n    if (label) {\n      if (state.labels && state.labels.indexOf(label) !== -1) {\n        return;\n      }\n    } else if (state.isLoop || state.isSwitch) {\n      return;\n    }\n    state = stack.pop();\n  }\n  // Syntax error, do not allow this error to be trapped.\n  throw SyntaxError('Illegal break statement');\n};\n\nprivate stepCallExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.doneCallee_) {\n    state.doneCallee_ = 1;\n    // Components needed to determine value of 'this'.\n    var nextState = new Interpreter.MyState(node['callee'], state.scope);\n    nextState.components = true;\n    return nextState;\n  }\n  if (state.doneCallee_ === 1) {\n    // Determine value of the function.\n    state.doneCallee_ = 2;\n    var func = state.value;\n    if (Array.isArray(func)) {\n      state.func_ = this.getValue(func);\n      if (func[0] !== Interpreter.SCOPE_REFERENCE) {\n        // Method function, 'this' is object (ignored if invoked as 'new').\n        state.funcThis_ = func[0];\n      }\n      func = state.func_;\n      if (func && typeof func === 'object' && func.isGetter) {\n        // Clear the getter flag and call the getter function.\n        func.isGetter = false;\n        state.doneCallee_ = 1;\n        return this.createGetter_(/** @type {!Interpreter.Object} */ (func),\n                         state.value);\n      }\n    } else {\n      // Already evaluated function: (function(){...})();\n      state.func_ = func;\n    }\n    state.arguments_ = [];\n    state.n_ = 0;\n  }\n  var func = state.func_;\n  if (!state.doneArgs_) {\n    if (state.n_ !== 0) {\n      state.arguments_.push(state.value);\n    }\n    if (node['arguments'][state.n_]) {\n      return new Interpreter.MyState(node['arguments'][state.n_++], state.scope);\n    }\n    // Determine value of 'this' in function.\n    if (node['type'] === 'NewExpression') {\n      if (func.illegalConstructor) {\n        // Illegal: new escape();\n        this.throwException(this.TYPE_ERROR, func + ' is not a constructor');\n      }\n      // Constructor, 'this' is new object.\n      state.funcThis_ = this.createObject(func);\n      state.isConstructor = true;\n    } else if (state.funcThis_ === undefined) {\n      // Global function, 'this' is global object (or 'undefined' if strict).\n      state.funcThis_ = state.scope.strict ? undefined : this.global;\n    }\n    state.doneArgs_ = true;\n  }\n  if (!state.doneExec_) {\n    state.doneExec_ = true;\n    if (!func || !func.isObject) {\n      this.throwException(this.TYPE_ERROR, func + ' is not a function');\n    }\n    var funcNode = func.node;\n    if (funcNode) {\n      var scope = this.createScope(funcNode['body'], func.parentScope);\n      // Add all arguments.\n      for (var i = 0; i < funcNode['params'].length; i++) {\n        var paramName = funcNode['params'][i]['name'];\n        var paramValue = state.arguments_.length > i ? state.arguments_[i] :\n            undefined;\n        this.setProperty(scope, paramName, paramValue);\n      }\n      // Build arguments variable.\n      var argsList = this.createObjectProto(this.ARRAY_PROTO);\n      for (var i = 0; i < state.arguments_.length; i++) {\n        this.setProperty(argsList, i, state.arguments_[i]);\n      }\n      this.setProperty(scope, 'arguments', argsList);\n      // Add the function's name (var x = function foo(){};)\n      var name = funcNode['id'] && funcNode['id']['name'];\n      if (name) {\n        this.setProperty(scope, name, func);\n      }\n      this.setProperty(scope, 'this', state.funcThis_,\n                       Interpreter.READONLY_DESCRIPTOR);\n      state.value = undefined;  // Default value if no explicit return.\n      return new Interpreter.MyState(funcNode['body'], scope);\n    } else if (func.eval) {\n      var code = state.arguments_[0];\n      if (typeof code !== 'string') {\n        // JS does not parse String objects:\n        // eval(new String('1 + 1')) -> '1 + 1'\n        state.value = code;\n      } else {\n        try {\n          var ast = Interpreter.acorn.parse(code.toString(), Interpreter.PARSE_OPTIONS);\n        } catch (e) {\n          // Acorn threw a SyntaxError.  Rethrow as a trappable error.\n          this.throwException(this.SYNTAX_ERROR, 'Invalid code: ' + e.message);\n        }\n        var evalNode = new this.nodeConstructor();\n        evalNode['type'] = 'EvalProgram_';\n        evalNode['body'] = ast['body'];\n        this.stripLocations_(evalNode, node['start'], node['end']);\n        // Update current scope with definitions in eval().\n        var scope = <Interpreter.MyObject>state.scope;\n        if (scope.strict) {\n          // Strict mode get its own scope in eval.\n          scope = this.createScope(ast, scope);\n        } else {\n          // Non-strict mode pollutes the current scope.\n          this.populateScope_(ast, scope);\n        }\n        this.value = undefined;  // Default value if no code.\n        return new Interpreter.MyState(evalNode, scope);\n      }\n    } else if (func.nativeFunc) {\n      state.value = func.nativeFunc.apply(state.funcThis_, state.arguments_);\n    } else if (func.asyncFunc) {\n      var thisInterpreter = this;\n      var callback = function(value) {\n        state.value = value;\n        thisInterpreter.paused_ = false;\n      };\n      var argsWithCallback = state.arguments_.concat(callback);\n      this.paused_ = true;\n      func.asyncFunc.apply(state.funcThis_, argsWithCallback);\n      return;\n    } else {\n      /* A child of a function is a function but is not callable.  For example:\n      var F = function() {};\n      F.prototype = escape;\n      var f = new F();\n      f();\n      */\n      this.throwException(this.TYPE_ERROR, func.class + ' is not a function');\n    }\n  } else {\n    // Execution complete.  Put the return value on the stack.\n    stack.pop();\n    if (state.isConstructor && typeof state.value !== 'object') {\n      stack[stack.length - 1].value = state.funcThis_;\n    } else {\n      stack[stack.length - 1].value = state.value;\n    }\n  }\n};\n\nprivate stepCatchClause(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.done_) {\n    state.done_ = true;\n    // Create an empty scope.\n    var scope = this.createSpecialScope(state.scope);\n    // Add the argument.\n    this.setProperty(scope, node['param']['name'], state.throwValue);\n    // Execute catch clause.\n    return new Interpreter.MyState(node['body'], scope);\n  } else {\n    stack.pop();\n  }\n};\n\nprivate stepConditionalExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  var mode = state.mode_ || 0;\n  if (mode === 0) {\n    state.mode_ = 1;\n    return new Interpreter.MyState(node['test'], state.scope);\n  }\n  if (mode === 1) {\n    state.mode_ = 2;\n    var value = Boolean(state.value);\n    if (value && node['consequent']) {\n      // Execute 'if' block.\n      return new Interpreter.MyState(node['consequent'], state.scope);\n    } else if (!value && node['alternate']) {\n      // Execute 'else' block.\n      return new Interpreter.MyState(node['alternate'], state.scope);\n    }\n    // eval('1;if(false){2}') -> undefined\n    this.value = undefined;\n  }\n  stack.pop();\n  if (node['type'] === 'ConditionalExpression') {\n    stack[stack.length - 1].value = state.value;\n  }\n};\n\nprivate stepContinueStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  stack.pop();\n  var label = null;\n  if (node['label']) {\n    label = node['label']['name'];\n  }\n  state = stack[stack.length - 1];\n  while (state &&\n         state.node['type'] !== 'CallExpression' &&\n         state.node['type'] !== 'NewExpression') {\n    if (state.isLoop) {\n      if (!label || (state.labels && state.labels.indexOf(label) !== -1)) {\n        return;\n      }\n    }\n    stack.pop();\n    state = stack[stack.length - 1];\n  }\n  // Syntax error, do not allow this error to be trapped.\n  throw SyntaxError('Illegal continue statement');\n};\n\nprivate stepDebuggerStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  // Do nothing.  May be overridden by developers.\n  stack.pop();\n};\n\nprivate stepDoWhileStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (node['type'] === 'DoWhileStatement' && state.test_ === undefined) {\n    // First iteration of do/while executes without checking test.\n    state.value = true;\n    state.test_ = true;\n  }\n  if (!state.test_) {\n    state.test_ = true;\n    return new Interpreter.MyState(node['test'], state.scope);\n  }\n  if (!state.value) {  // Done, exit loop.\n    stack.pop();\n  } else if (node['body']) {  // Execute the body.\n    state.test_ = false;\n    state.isLoop = true;\n    return new Interpreter.MyState(node['body'], state.scope);\n  }\n};\n\nprivate stepEmptyStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  stack.pop();\n};\n\nprivate stepEvalProgram_(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  var n = state.n_ || 0;\n  var expression = node['body'][n];\n  if (expression) {\n    state.n_ = n + 1;\n    return new Interpreter.MyState(expression, state.scope);\n  }\n  stack.pop();\n  stack[stack.length - 1].value = this.value;\n};\n\nprivate stepExpressionStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.done_) {\n    state.done_ = true;\n    return new Interpreter.MyState(node['expression'], state.scope);\n  }\n  stack.pop();\n  // Save this value to interpreter.value for use as a return value if\n  // this code is inside an eval function.\n  this.value = state.value;\n};\n\nprivate stepForInStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  // First, initialize a variable if exists.  Only do so once, ever.\n  if (!state.doneInit_) {\n    state.doneInit_ = true;\n    if (node['left']['declarations'] &&\n        node['left']['declarations'][0]['init']) {\n      if (state.scope.strict) {\n        this.throwException(this.SYNTAX_ERROR,\n            'for-in loop variable declaration may not have an initializer.');\n      }\n      // Variable initialization: for (var x = 4 in y)\n      return new Interpreter.MyState(node['left'], state.scope);\n    }\n  }\n  // Second, look up the object.  Only do so once, ever.\n  if (!state.doneObject_) {\n    state.doneObject_ = true;\n    if (!state.variable_) {\n      state.variable_ = state.value;\n    }\n    return new Interpreter.MyState(node['right'], state.scope);\n  }\n  if (!state.isLoop) {\n    // First iteration.\n    state.isLoop = true;\n    state.object_ = state.value;\n    state.visited_ = Object.create(null);\n  }\n  // Third, find the property name for this iteration.\n  if (state.name_ === undefined) {\n    done: do {\n      if (state.object_ && state.object_.isObject) {\n        if (!state.props_) {\n          state.props_ = Object.getOwnPropertyNames(state.object_.properties);\n        }\n        do {\n          var prop = state.props_.shift();\n        } while (prop && (state.visited_[prop] ||\n            !Object.prototype.hasOwnProperty.call(state.object_.properties,\n                                                  prop)));\n        if (prop) {\n          state.visited_[prop] = true;\n          if (Object.prototype.propertyIsEnumerable.call(\n              state.object_.properties, prop)) {\n            state.name_ = prop;\n            break done;\n          }\n        }\n      } else if (state.object_ !== null) {\n        if (!state.props_) {\n          state.props_ = Object.getOwnPropertyNames(state.object_);\n        }\n        do {\n          var prop = state.props_.shift();\n        } while (prop && state.visited_[prop]);\n        if (prop) {\n          state.visited_[prop] = true;\n          state.name_ = prop;\n          break done;\n        }\n      }\n      state.object_ = this.getPrototype(state.object_);\n      state.props_ = null;\n    } while (state.object_ !== null);\n    if (state.object_ === null) {\n      // Done, exit loop.\n      stack.pop();\n      return;\n    }\n  }\n  // Fourth, find the variable\n  if (!state.doneVariable_) {\n    state.doneVariable_ = true;\n    var left = node['left'];\n    if (left['type'] === 'VariableDeclaration') {\n      // Inline variable declaration: for (var x in y)\n      state.variable_ =\n          [Interpreter.SCOPE_REFERENCE, left['declarations'][0]['id']['name']];\n    } else {\n      // Arbitrary left side: for (foo().bar in y)\n      state.variable_ = null;\n      var nextState = new Interpreter.MyState(left, state.scope);\n      nextState.components = true;\n      return nextState;\n    }\n  }\n  if (!state.variable_) {\n    state.variable_ = state.value;\n  }\n  // Fifth, set the variable.\n  if (!state.doneSetter_) {\n    state.doneSetter_ = true;\n    var value = state.name_;\n    var setter = this.setValue(state.variable_, value);\n    if (setter) {\n      return this.createSetter_(setter, state.variable_, value);\n    }\n  }\n  // Next step will be step three.\n  state.name_ = undefined;\n  // Reevaluate the variable since it could be a setter on the global object.\n  state.doneVariable_ = false;\n  state.doneSetter_ = false;\n  // Sixth and finally, execute the body if there was one.  this.\n  if (node['body']) {\n    return new Interpreter.MyState(node['body'], state.scope);\n  }\n};\n\nprivate stepForStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  var mode = state.mode_ || 0;\n  if (mode === 0) {\n    state.mode_ = 1;\n    if (node['init']) {\n      return new Interpreter.MyState(node['init'], state.scope);\n    }\n  } else if (mode === 1) {\n    state.mode_ = 2;\n    if (node['test']) {\n      return new Interpreter.MyState(node['test'], state.scope);\n    }\n  } else if (mode === 2) {\n    state.mode_ = 3;\n    if (node['test'] && !state.value) {\n      // Done, exit loop.\n      stack.pop();\n    } else {  // Execute the body.\n      state.isLoop = true;\n      return new Interpreter.MyState(node['body'], state.scope);\n    }\n  } else if (mode === 3) {\n    state.mode_ = 1;\n    if (node['update']) {\n      return new Interpreter.MyState(node['update'], state.scope);\n    }\n  }\n};\n\nprivate stepFunctionDeclaration(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  // This was found and handled when the scope was populated.\n  stack.pop();\n};\n\nprivate stepFunctionExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  stack.pop();\n  stack[stack.length - 1].value = this.createFunction(<ESTree.FunctionDeclaration>node, state.scope);\n};\n\nprivate stepIdentifier(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  stack.pop();\n  if (state.components) {\n    stack[stack.length - 1].value = [Interpreter.SCOPE_REFERENCE, node['name']];\n    return;\n  }\n  var value = this.getValueFromScope(node['name']);\n  // An identifier could be a getter if it's a property on the global object.\n  if (value && typeof value === 'object' && value.isGetter) {\n    // Clear the getter flag and call the getter function.\n    value.isGetter = false;\n    var scope = state.scope;\n    while (!this.hasProperty(scope, node['name'])) {\n      scope = scope.parentScope;\n    }\n    var func = /** @type {!Interpreter.Object} */ (value);\n    return this.createGetter_(func, this.global);\n  }\n  stack[stack.length - 1].value = value;\n};\n\nprivate stepIfStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  return this.stepConditionalExpression(stack, state, node);\n}\n\nprivate stepLabeledStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  // No need to hit this node again on the way back up the stack.\n  stack.pop();\n  // Note that a statement might have multiple labels.\n  var labels = state.labels || [];\n  labels.push(node['label']['name']);\n  var nextState = new Interpreter.MyState(node['body'], state.scope);\n  nextState.labels = labels;\n  return nextState;\n};\n\nprivate stepLiteral(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  stack.pop();\n  var value = node['value'];\n  if (value instanceof RegExp) {\n    var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\n    this.populateRegExp(pseudoRegexp, value);\n    value = pseudoRegexp;\n  }\n  stack[stack.length - 1].value = value;\n};\n\nprivate stepLogicalExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (node['operator'] !== '&&' && node['operator'] !== '||') {\n    throw SyntaxError('Unknown logical operator: ' + node['operator']);\n  }\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    return new Interpreter.MyState(node['left'], state.scope);\n  }\n  if (!state.doneRight_) {\n    if ((node['operator'] === '&&' && !state.value) ||\n        (node['operator'] === '||' && state.value)) {\n      // Shortcut evaluation.\n      stack.pop();\n      stack[stack.length - 1].value = state.value;\n    } else {\n      state.doneRight_ = true;\n      return new Interpreter.MyState(node['right'], state.scope);\n    }\n  } else {\n    stack.pop();\n    stack[stack.length - 1].value = state.value;\n  }\n};\n\nprivate stepMemberExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.doneObject_) {\n    state.doneObject_ = true;\n    return new Interpreter.MyState(node['object'], state.scope);\n  }\n  var propName;\n  if (!node['computed']) {\n    state.object_ = state.value;\n    // obj.foo -- Just access 'foo' directly.\n    propName = node['property']['name'];\n  } else if (!state.doneProperty_) {\n    state.object_ = state.value;\n    // obj[foo] -- Compute value of 'foo'.\n    state.doneProperty_ = true;\n    return new Interpreter.MyState(node['property'], state.scope);\n  } else {\n    propName = state.value;\n  }\n  stack.pop();\n  if (state.components) {\n    stack[stack.length - 1].value = [state.object_, propName];\n  } else {\n    var value = this.getProperty(state.object_, propName);\n    if (value && typeof value === 'object' && value.isGetter) {\n      // Clear the getter flag and call the getter function.\n      value.isGetter = false;\n      var func = /** @type {!Interpreter.Object} */ (value);\n      return this.createGetter_(func, state.object_);\n    }\n    stack[stack.length - 1].value = value;\n  }\n};\n\nprivate stepNewExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  return this.stepCallExpression(stack, state, node);\n}\n\nprivate stepObjectExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  var n = state.n_ || 0;\n  var property = node['properties'][n];\n  if (!state.object_) {\n    // First execution.\n    state.object_ = this.createObjectProto(this.OBJECT_PROTO);\n    state.properties_ = Object.create(null);\n  } else {\n    // Determine property name.\n    var key = <string>property['key'];\n    if (key['type'] === 'Identifier') {\n      var propName = key['name'];\n    } else if (key['type'] === 'Literal') {\n      var propName = key['value'];\n    } else {\n      throw SyntaxError('Unknown object structure: ' + key['type']);\n    }\n    // Set the property computed in the previous execution.\n    if (!state.properties_[propName]) {\n      // Create temp object to collect value, getter, and/or setter.\n      state.properties_[propName] = {};\n    }\n    state.properties_[propName][property['kind']] = state.value;\n    state.n_ = ++n;\n    property = node['properties'][n];\n  }\n  if (property) {\n    return new Interpreter.MyState(property['value'], state.scope);\n  }\n  for (var key in state.properties_) {\n    var kinds = state.properties_[key];\n    if ('get' in kinds || 'set' in kinds) {\n      // Set a property with a getter or setter.\n      var descriptor = {\n        configurable: true,\n        enumerable: true,\n        get: kinds['get'],\n        set: kinds['set']\n      };\n      this.setProperty(state.object_, key, null, descriptor);\n    } else {\n      // Set a normal property with a value.\n      this.setProperty(state.object_, key, kinds['init']);\n    }\n  }\n  stack.pop();\n  stack[stack.length - 1].value = state.object_;\n};\n\nprivate stepProgram(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  var n = state.n_ || 0;\n  var expression = node['body'][n];\n  if (expression) {\n    state.done = false;\n    state.n_ = n + 1;\n    return new Interpreter.MyState(expression, state.scope);\n  }\n  state.done = true;\n  // Don't pop the stateStack.\n  // Leave the root scope on the tree in case the program is appended to.\n};\n\nprivate stepReturnStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (node['argument'] && !state.done_) {\n    state.done_ = true;\n    return new Interpreter.MyState(node['argument'], state.scope);\n  }\n  var value = state.value;\n  var i = stack.length - 1;\n  state = stack[i];\n  while (state.node['type'] !== 'CallExpression' &&\n         state.node['type'] !== 'NewExpression') {\n    if (state.node['type'] !== 'TryStatement') {\n      stack.splice(i, 1);\n    }\n    i--;\n    if (i < 0) {\n      // Syntax error, do not allow this error to be trapped.\n      throw SyntaxError('Illegal return statement');\n    }\n    state = stack[i];\n  }\n  state.value = value;\n};\n\nprivate stepSequenceExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  var n = state.n_ || 0;\n  var expression = node['expressions'][n];\n  if (expression) {\n    state.n_ = n + 1;\n    return new Interpreter.MyState(expression, state.scope);\n  }\n  stack.pop();\n  stack[stack.length - 1].value = state.value;\n};\n\nprivate stepSwitchStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.test_) {\n    state.test_ = 1;\n    return new Interpreter.MyState(node['discriminant'], state.scope);\n  }\n  if (state.test_ === 1) {\n    state.test_ = 2;\n    // Preserve switch value between case tests.\n    state.switchValue_ = state.value;\n  }\n\n  while (true) {\n    var index = state.index_ || 0;\n    var switchCase = node['cases'][index];\n    if (!state.matched_ && switchCase && !switchCase['test']) {\n      // Test on the default case is null.\n      // Bypass (but store) the default case, and get back to it later.\n      state.defaultCase_ = index;\n      state.index_ = index + 1;\n      continue;\n    }\n    if (!switchCase && !state.matched_ && state.defaultCase_) {\n      // Ran through all cases, no match.  Jump to the default.\n      state.matched_ = true;\n      state.index_ = state.defaultCase_;\n      continue;\n    }\n    if (switchCase) {\n      if (!state.matched_ && !state.tested_ && switchCase['test']) {\n        state.tested_ = true;\n        return new Interpreter.MyState(switchCase['test'], state.scope);\n      }\n      if (state.matched_ || state.value === state.switchValue_) {\n        state.matched_ = true;\n        var n = state.n_ || 0;\n        if (switchCase['consequent'][n]) {\n          state.isSwitch = true;\n          state.n_ = n + 1;\n          return new Interpreter.MyState(switchCase['consequent'][n],\n                                       state.scope);\n        }\n      }\n      // Move on to next case.\n      state.tested_ = false;\n      state.n_ = 0;\n      state.index_ = index + 1;\n    } else {\n      stack.pop();\n      return;\n    }\n  }\n};\n\nprivate stepThisExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  stack.pop();\n  stack[stack.length - 1].value = this.getValueFromScope('this');\n};\n\nprivate stepThrowStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.done_) {\n    state.done_ = true;\n    return new Interpreter.MyState(node['argument'], state.scope);\n  } else {\n    this.throwException(state.value);\n  }\n};\n\nprivate stepTryStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.doneBlock_) {\n    state.doneBlock_ = true;\n    return new Interpreter.MyState(node['block'], state.scope);\n  }\n  if (state.throwValue && !state.doneHandler_ && node['handler']) {\n    state.doneHandler_ = true;\n    var nextState = new Interpreter.MyState(node['handler'], state.scope);\n    nextState.throwValue = state.throwValue;\n    state.throwValue = null;  // This error has been handled, don't rethrow.\n    return nextState;\n  }\n  if (!state.doneFinalizer_ && node['finalizer']) {\n    state.doneFinalizer_ = true;\n    return new Interpreter.MyState(node['finalizer'], state.scope);\n  }\n  if (state.throwValue) {\n    // There was no catch handler, or the catch/finally threw an error.\n    // Throw the error up to a higher try.\n    this.executeException(state.throwValue);\n  } else {\n    stack.pop();\n  }\n};\n\nprivate stepUnaryExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.done_) {\n    state.done_ = true;\n    var nextState = new Interpreter.MyState(node['argument'], state.scope);\n    nextState.components = node['operator'] === 'delete';\n    return nextState;\n  }\n  stack.pop();\n  var value = state.value;\n  if (node['operator'] === '-') {\n    value = -value;\n  } else if (node['operator'] === '+') {\n    value = +value;\n  } else if (node['operator'] === '!') {\n    value = !value;\n  } else if (node['operator'] === '~') {\n    value = ~value;\n  } else if (node['operator'] === 'delete') {\n    var result = true;\n    // If value is not an array, then it is a primitive, or some other value.\n    // If so, skip the delete and return true.\n    if (Array.isArray(value)) {\n      var obj = value[0];\n      if (obj === Interpreter.SCOPE_REFERENCE) {\n        // 'delete foo;' is the same as 'delete window.foo'.\n        obj = state.scope;\n      }\n      var name = String(value[1]);\n      try {\n        delete obj.properties[name];\n      } catch (e) {\n        if (state.scope.strict) {\n          this.throwException(this.TYPE_ERROR, \"Cannot delete property '\" +\n                              name + \"' of '\" + obj + \"'\");\n        } else {\n          result = false;\n        }\n      }\n    }\n    value = result;\n  } else if (node['operator'] === 'typeof') {\n    value = (value && value.class === 'Function') ? 'function' : typeof value;\n  } else if (node['operator'] === 'void') {\n    value = undefined;\n  } else {\n    throw SyntaxError('Unknown unary operator: ' + node['operator']);\n  }\n  stack[stack.length - 1].value = value;\n};\n\nprivate stepUpdateExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    var nextState = new Interpreter.MyState(node['argument'], state.scope);\n    nextState.components = true;\n    return nextState;\n  }\n  if (!state.leftSide_) {\n    state.leftSide_ = state.value;\n  }\n  if (state.doneGetter_) {\n    state.leftValue_ = state.value;\n  }\n  if (!state.doneGetter_) {\n    var leftValue = this.getValue(state.leftSide_);\n    state.leftValue_ = leftValue;\n    if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\n      // Clear the getter flag and call the getter function.\n      leftValue.isGetter = false;\n      state.doneGetter_ = true;\n      var func = /** @type {!Interpreter.Object} */ (leftValue);\n      return this.createGetter_(func, state.leftSide_);\n    }\n  }\n  if (state.doneSetter_) {\n    // Return if setter function.\n    // Setter method on property has completed.\n    // Ignore its return value, and use the original set value instead.\n    stack.pop();\n    stack[stack.length - 1].value = state.doneSetter_;\n    return;\n  }\n  leftValue = Number(state.leftValue_);\n  var changeValue;\n  if (node['operator'] === '++') {\n    changeValue = leftValue + 1;\n  } else if (node['operator'] === '--') {\n    changeValue = leftValue - 1;\n  } else {\n    throw SyntaxError('Unknown update expression: ' + node['operator']);\n  }\n  var returnValue = node['prefix'] ? changeValue : leftValue;\n  var setter = this.setValue(state.leftSide_, changeValue);\n  if (setter) {\n    state.doneSetter_ = returnValue;\n    return this.createSetter_(setter, state.leftSide_, changeValue);\n  }\n  // Return if no setter function.\n  stack.pop();\n  stack[stack.length - 1].value = returnValue;\n};\n\nprivate stepVariableDeclaration(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  var declarations = node['declarations'];\n  var n = state.n_ || 0;\n  var declarationNode = declarations[n];\n  if (state.init_ && declarationNode) {\n    // This setValue call never needs to deal with calling a setter function.\n    // Note that this is setting the init value, not defining the variable.\n    // Variable definition is done when scope is populated.\n    this.setValueToScope(declarationNode['id']['name'], state.value);\n    state.init_ = false;\n    declarationNode = declarations[++n];\n  }\n  while (declarationNode) {\n    // Skip any declarations that are not initialized.  They have already\n    // been defined as undefined in populateScope_.\n    if (declarationNode['init']) {\n      state.n_ = n;\n      state.init_ = true;\n      return new Interpreter.MyState(declarationNode['init'], state.scope);\n    }\n    declarationNode = declarations[++n];\n  }\n  stack.pop();\n};\n\nprivate stepWithStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  if (!state.doneObject_) {\n    state.doneObject_ = true;\n    return new Interpreter.MyState(node['object'], state.scope);\n  } else if (!state.doneBody_) {\n    state.doneBody_ = true;\n    var scope = this.createSpecialScope(state.scope, state.value);\n    return new Interpreter.MyState(node['body'], scope);\n  } else {\n    stack.pop();\n  }\n};\n\nprivate stepWhileStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\n  return this.stepDoWhileStatement(stack, state, node);\n}\n}\n\nmodule Interpreter {\n/**\n * Class for an object.\n * @param {Interpreter.MyObject} proto Prototype object or null.\n * @constructor\n */\nexport class MyObject {\n[key: string]: any;\ngetter: any;\nsetter: any;\nproperties: any;\n\nconstructor(proto) {\n  this.getter = Object.create(null);\n  this.setter = Object.create(null);\n  this.properties = Object.create(null);\n  this.proto = proto;\n}\n\n/** @type {Interpreter.MyObject} */\nproto: Interpreter.MyObject = null;\n\n/** @type {boolean} */\nisObject = true;\n\n/** @type {string} */\nclass = 'Object';\n\n/** @type {Date|RegExp|boolean|number|string|undefined|null} */\ndata: Date | RegExp | boolean | number | string | undefined | null = null;\n\n/**\n * Convert this object into a string.\n * @return {string} String value.\n * @override\n */\ntoString() {\n  if (this.class === 'Array') {\n    // Array\n    var cycles = Interpreter.toStringCycles_;\n    cycles.push(this);\n    try {\n      var strs = [];\n      for (var i = 0; i < this.properties.length; i++) {\n        var value = this.properties[i];\n        strs[i] = (value && value.isObject && cycles.indexOf(value) !== -1) ?\n            '...' : value;\n      }\n    } finally {\n      cycles.pop();\n    }\n    return strs.join(',');\n  }\n  if (this.class === 'Error') {\n    var cycles = Interpreter.toStringCycles_;\n    if (cycles.indexOf(this) !== -1) {\n      return '[object Error]';\n    }\n    var name, message;\n    // Bug: Does not support getters and setters for name or message.\n    var obj = <Interpreter.MyObject>this;\n    do {\n      if ('name' in obj.properties) {\n        name = obj.properties['name'];\n        break;\n      }\n    } while ((obj = obj.proto));\n    var obj = <Interpreter.MyObject>this;\n    do {\n      if ('message' in obj.properties) {\n        message = obj.properties['message'];\n        break;\n      }\n    } while ((obj = obj.proto));\n    cycles.push(this);\n    try {\n      name = name && name.toString();\n      message = message && message.toString();\n    } finally {\n      cycles.pop();\n    }\n    return message ? name + ': ' + message : String(name);\n  }\n\n  // RegExp, Date, and boxed primitives.\n  if (this.data !== null) {\n    return String(this.data);\n  }\n\n  return '[object ' + this.class + ']';\n}\n\n/**\n * Return the object's value.\n * @return {Interpreter.MyValue} Value.\n * @override\n */\nvalueOf() {\n  if (this.data === undefined || this.data === null ||\n      this.data instanceof RegExp) {\n    return this; // An Object.\n  }\n  if (this.data instanceof Date) {\n    return this.data.valueOf();  // Milliseconds.\n  }\n  return /** @type {(boolean|number|string)} */ (this.data);  // Boxed primitive.\n}\n}\n\n/**\n * Typedef for JS values.\n * @typedef {!Interpreter.MyObject|boolean|number|string|undefined|null}\n */\nexport type MyValue = MyObject | boolean | number | string | undefined | null;\n\n/**\n * Class for a state.\n * @param {!MyObject} node AST node for the state.\n * @param {!Interpreter.MyObject} scope Scope object for the state.\n * @constructor\n */\nexport class MyState {\n[key: string]: any;\nnode: ESTree.BaseNode;\nscope: Interpreter.MyObject;\nconstructor(node: ESTree.BaseNode, scope: Interpreter.MyObject) {\n  this.node = node;\n  this.scope = scope;\n}\n}\n\nexport interface MyValueTable {\n  pseudo: MyValue[],\n  native: any[]\n}\n\nexport interface MyDescriptor {\n  get?: MyObject;\n  set?: MyObject;\n  configurable?: boolean;\n  enumerable?: boolean;\n  writable?: boolean;\n  value?: any;\n}\n\nexport interface Acorn {\n  parse(code: string, options?: any): ESTree.Program;\n}\n\nexport interface NodeConstructor {\n  new (): ESTree.BaseNode;\n}\n\nexport interface NativeFunction extends Function {\n  id?: number;\n}\n}\n\n// These lines are added for API compatibility\nInterpreter['Object'] = Interpreter.MyObject;\nInterpreter['State'] = Interpreter.MyState;\n\n// Look for globally-defined acorn\ntry {\n  Interpreter.acorn = (self || global)['acorn'];\n} catch (e) {\n  // do nothing if we fail\n}\n\nexport = Interpreter;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/interpreter.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}