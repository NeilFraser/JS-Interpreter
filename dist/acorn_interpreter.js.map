{"version":3,"sources":["webpack:///dist/acorn_interpreter.js","webpack:///webpack/bootstrap 44c24c04f6b41a07e54d","webpack:///./lib/acorn_interpreter.ts","webpack:///./lib/acorn.js","webpack:///(webpack)/buildin/module.js","webpack:///./lib/interpreter.ts","webpack:///(webpack)/buildin/global.js"],"names":["Interpreter","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","require","acorn","apply","__WEBPACK_AMD_DEFINE_FACTORY__","_typeof","Symbol","iterator","obj","constructor","root","mod","setOptions","opts","options","opt","defaultOptions","sourceFile","raise","pos","message","loc","getLineInfo","input","line","column","err","SyntaxError","raisedAt","tokPos","makePredicate","words","compareTo","arr","length","f","JSON","stringify","split","cats","out","j","push","sort","a","b","cat","Function","line_loc_t","this","tokCurLine","tokLineStart","initTokenState","tokRegexpAllowed","skipSpace","finishToken","type","val","tokEnd","locations","tokEndLoc","tokType","tokVal","beforeExpr","skipBlockComment","startLoc","onComment","start","end","indexOf","lineBreak","lastIndex","match","exec","index","slice","skipLineComment","ch","charCodeAt","inputLen","next","nonASCIIwhitespace","test","String","fromCharCode","readToken_dot","readNumber","_dot","readToken_slash","readRegexp","finishOp","_assign","_slash","readToken_mult_modulo","_multiplyModulo","readToken_pipe_amp","code","_logicalOR","_logicalAND","_bitwiseOR","_bitwiseAND","readToken_caret","_bitwiseXOR","readToken_plus_min","newline","lastEnd","readToken","_incDec","_plusMin","readToken_lt_gt","size","_bitShift","_relational","readToken_eq_excl","_equality","_eq","_prefix","getTokenFromCode","_parenL","_parenR","_semi","_comma","_bracketL","_bracketR","_braceL","_braceR","_colon","_question","readHexNumber","readString","forceRegexp","tokStart","tokStartLoc","_eof","isIdentifierStart","readWord","tok","nonASCIIidentifierStart","str","escaped","inClass","content","charAt","mods","readWord1","_regexp","RegExp","readInt","radix","len","total","e","Infinity","_num","startsWithDot","isFloat","octal","parseFloat","strict","parseInt","quote","_string","readHexChar","containsEsc","word","first","isIdentifierChar","esc","escStr","_name","isKeyword","keywordTypes","forbidReserved","ecmaVersion","isReservedWord3","isReservedWord5","isStrictReservedWord","lastStart","lastEndLoc","setStrict","strct","lastIndexOf","node_t","node_loc_t","source","startNode","node","directSourceFile","ranges","range","startNodeFrom","other","finishNode","isUseStrict","stmt","expression","value","eat","canInsertSemicolon","strictSemicolons","semicolon","unexpected","expect","checkLVal","expr","isStrictBadIdWord","parseTopLevel","program","inFunction","labels","body","parseStatement","starttype","_break","_continue","isBreak","label","parseIdent","lab","kind","keyword","_debugger","_do","loopLabel","pop","_while","parseParenExpression","_for","parseFor","_var","init","parseVar","declarations","_in","parseForIn","parseExpression","_function","parseFunction","_if","consequent","alternate","_else","_return","argument","_switch","discriminant","cases","switchLabel","cur","sawDefault","_case","_default","isCase","_throw","_try","block","parseBlock","handler","_catch","clause","param","guard","guardedHandlers","empty","finalizer","_finally","_with","maybeName","isLoop","allowStrict","oldStrict","update","left","right","noIn","decl","id","noComma","parseMaybeAssign","expressions","parseMaybeConditional","isAssign","operator","parseExprOps","parseExprOp","parseMaybeUnary","minPrec","prec","binop","op","prefix","isUpdate","parseExprSubscripts","postfix","parseSubscripts","parseExprAtom","base","noCalls","computed","callee","arguments","parseExprList","_this","raw","_null","_true","_false","atomValue","tokStartLoc1","tokStart1","elements","parseObj","_new","parseNew","sawGetSet","properties","allowTrailingCommas","prop","key","parsePropertyName","isGetSet","conflict","isStatement","params","oldInFunc","oldLabels","close","allowTrailingComma","allowEmpty","elts","liberal","version","parse","inpt","offset","tokenize","getToken","t","endLoc","jumpTo","reAllowed","break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","while","with","null","true","false","new","in","instanceof","typeof","void","delete","tokTypes","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","slash","eq","eof","num","regexp","string","kw","nonASCIIidentifierStartChars","nonASCIIidentifier","webpackPolyfill","deprecate","paths","children","global","opt_initFunc","PARSE_OPTIONS","ast","initFunc_","paused_","polyfills_","functionCounter_","stepFunctions_","create","stepMatch","methodName","bind","createScope","join","stripLocations_","state","MyState","done","stateStack","run","nodeConstructor","OBJECT","OBJECT_PROTO","FUNCTION","FUNCTION_PROTO","ARRAY","ARRAY_PROTO","REGEXP","REGEXP_PROTO","NaN","appendCode","Error","populateScope_","scope","step","stack","nextState","STEP_ERROR","initGlobalScope","setProperty","READONLY_DESCRIPTOR","MyObject","initFunction","initObject","proto","initArray","initString","initBoolean","initNumber","initDate","initRegExp","initError","initMath","initJSON","thisInterpreter","func","createNativeFunction","x","EvalError","eval","isNaN","isFinite","strFunctions","escape","unescape","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","wrapper","nativeFunc","throwException","URI_ERROR","NONENUMERABLE_DESCRIPTOR","identifierRegexp","var_args","calledWithNew","newFunc","createObjectProto","args","SYNTAX_ERROR","parentScope","boxThis","isObject","getScope","box","getPrototype","data","thisArg","func_","funcThis_","arguments_","pseudoToNative","TYPE_ERROR","doneExec_","setNativeFunctionPrototype","toString","valueOf","throwIfNullUndefined","props","nativeToPseudo","getOwnPropertyNames","keys","descriptor","preventExtensions","ReferenceError","getOwnPropertyDescriptor","setter","set","writable","pseudoDescriptor","Boolean","propertyIsEnumerable","newArray","legalArrayLength","RANGE_ERROR","class","Array","shift","unshift","reverse","howmany","list","splice","opt_begin","opt_end","opt_separator","iLength","getProperty","hasProperty","element","isa","jLength","searchElement","opt_fromIndex","STRING","functions","compareString","locales","localeCompare","separator","limit","jsList","search","substr","newSubstr","replace","BOOLEAN","Number","NUMBER","numConsts","READONLY_NONENUMERABLE_DESCRIPTOR","fractionDigits","toExponential","ERROR","digits","toFixed","precision","toPrecision","toLocaleString","Date","concat","DATE","now","UTC","pattern","flags","rgx","populateRegExp","result","opt_message","newError","createObject","createErrorSubclass","EVAL_ERROR","REFERENCE_ERROR","myMath","mathConsts","Math","numFunctions","myJSON","text","nativeObj","child","childObj","legalArrayIndex","pseudoRegexp","nativeRegexp","ignoreCase","multiline","createFunction","opt_constructor","illegalConstructor","createAsyncFunction","asyncFunc","interpreter","map","pseudoObj","isArray","opt_cycles","cycles","pseudo","native","myObj","isGetter","TypeError","opt_descriptor","max","defObj","firstNode","createSpecialScope","opt_scope","getValueFromScope","prevNode","setValueToScope","VARIABLE_DESCRIPTOR","nodeClass","isConstructor","getValue","ref","SCOPE_REFERENCE","setValue","errorClass","error","executeException","throwValue","realError","errorTable","RangeError","URIError","createGetter_","funcThis","doneCallee_","doneArgs_","createSetter_","stepArrayExpression","n_","array_","stepAssignmentExpression","doneLeft_","components","doneRight_","leftReference_","doneGetter_","leftValue_","leftValue","doneSetter_","rightValue","stepBinaryExpression","stepBlockStatement","stepBreakStatement","isSwitch","stepCallExpression","funcNode","paramName","paramValue","argsList","evalNode","callback","argsWithCallback","stepCatchClause","done_","stepConditionalExpression","mode","mode_","stepContinueStatement","stepDebuggerStatement","stepDoWhileStatement","test_","stepEmptyStatement","stepEvalProgram_","stepExpressionStatement","stepForInStatement","doneInit_","doneObject_","variable_","object_","visited_","name_","props_","doneVariable_","stepForStatement","stepFunctionDeclaration","stepFunctionExpression","stepIdentifier","stepIfStatement","stepLabeledStatement","stepLiteral","stepLogicalExpression","stepMemberExpression","propName","doneProperty_","stepNewExpression","stepObjectExpression","properties_","kinds","stepProgram","stepReturnStatement","stepSequenceExpression","stepSwitchStatement","switchValue_","index_","switchCase","matched_","defaultCase_","tested_","stepThisExpression","stepThrowStatement","stepTryStatement","doneBlock_","doneHandler_","doneFinalizer_","stepUnaryExpression","stepUpdateExpression","leftSide_","changeValue","returnValue","stepVariableDeclaration","declarationNode","init_","stepWithStatement","doneBody_","stepWhileStatement","toStringCycles_","strs","self","g","window"],"mappings":"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vBwZ,EAAgB2E,YAAYxU,EAAO3J,KACrC4d,EAAKne,GAAU+Z,EAAgB0E,YAAYvU,EAAO3J,IAEpDP,QAGFme,GAAKne,GAAUkK,EAGnB,MAAO6P,GAAgB8C,eAAesB,IAExCpd,KAAKyb,2BAA2Bzb,KAAKmX,MAAO,SAAU4C,GAEtDA,EAAU,SAASgE,EAAeC,GAChC,MAAOjB,OAAMtgB,UAAU2E,QAAQlE,MAAM8C,KAAK0Q,WAAYf,YAExD3P,KAAKyb,2BAA2Bzb,KAAKmX,MAAO,UAAW4C,GAEvDA,EAAU,SAASgE,EAAeC,GAChC,MAAOjB,OAAMtgB,UAAU2L,YAAYlL,MAAM8C,KAAK0Q,WAAYf,YAE5D3P,KAAKyb,2BAA2Bzb,KAAKmX,MAAO,cAAe4C,GAE3DA,EAAU,WAER,MADAgD,OAAMtgB,UAAUiD,KAAKjE,KAAKuE,KAAK0Q,YACxB1Q,MAETA,KAAKyb,2BAA2Bzb,KAAKmX,MAAO,OAAQ4C,GAEpD/Z,KAAK+V,WAAWtW,KAGlB,kDACI,8CACF,kCACE,oEACA,YACA,wBACA,4BACA,yCACA,SACA,oBACE,+DACA,OACF,IACA,eACF,IACF,MAIA,mDACI,8CACF,+BACE,wFACA,wBACA,4BACA,gBACA,+DACA,kCACE,gBACE,kBACA,mDACF,IACF,IACA,cACF,IACF,MAIA,oDACI,8CACF,gCACE,kEACA,YACA,wBACA,4BACA,yCACA,SACA,oBACE,4CACA,OACF,IACF,IACF,MAIA,gDACI,8CACF,gCACE,8DACA,eACA,wBACA,4BACA,yCACA,sBACA,SACA,oBACE,mDACA,OACF,IACA,YACF,IACF,MAIA,mDACI,8CACF,0CACE,kEACA,4DACA,gCACE,wBACF,WACE,oCACA,kBACE,kEACF,IACA,kBACF,IACA,yBACE,mDACF,IACA,gBACF,IACF,MAIA,wDACI,8CACF,0CACE,yGACA,kEACA,+BACE,wBACF,WACE,mCACA,eACE,kEACF,IACA,kBACF,IACA,wBACE,mDACF,IACA,gBACF,IACF,MAIA,iDACI,8CACF,+BACE,6DACA,wBACA,4BACA,+DACA,kCACE,iDACE,e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","file":"./dist/acorn_interpreter.js","sourcesContent":["var Interpreter =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, acorn, Interpreter) {\r\n    \"use strict\";\r\n    /*!\r\n     * @license\r\n     * JavaScript Interpreter bundled with acorn v0.4.1\r\n     *\r\n     * Copyright 2013-2017 Google Inc. and Jun Kato\r\n     *\r\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n     * you may not use this file except in compliance with the License.\r\n     * You may obtain a copy of the License at\r\n     *\r\n     *   http://www.apache.org/licenses/LICENSE-2.0\r\n     *\r\n     * Unless required by applicable law or agreed to in writing, software\r\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n     * See the License for the specific language governing permissions and\r\n     * limitations under the License.\r\n     */\r\n    Interpreter.acorn = acorn;\r\n    return Interpreter;\r\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke and released under an MIT\n// license. The Unicode regexps (for identifiers and whitespace) were\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/marijnh/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/marijnh/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\n(function (root, mod) {\n  if (( false ? \"undefined\" : _typeof(exports)) == \"object\" && ( false ? \"undefined\" : _typeof(module)) == \"object\") return mod(exports); // CommonJS\n  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD\n  mod(root.acorn || (root.acorn = {})); // Plain browser env\n})(undefined, function (exports) {\n  \"use strict\";\n\n  exports.version = \"0.4.1\";\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api], with the caveat that the SpiderMonkey-specific syntax\n  // (`let`, `yield`, inline XML, etc) is not recognized.\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function (inpt, opts) {\n    input = String(inpt);inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n    return parseTopLevel(options.program);\n  };\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = exports.defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\n    // be either 3 or 5. This\n    // influences support for strict mode, the set of reserved words, and\n    // support for getters and setter.\n    ecmaVersion: 5,\n    // Turn on `strictSemicolons` to prevent the parser from doing\n    // automatic semicolon insertion.\n    strictSemicolons: false,\n    // When `allowTrailingCommas` is false, the parser will not allow\n    // trailing commas in array and object literals.\n    allowTrailingCommas: true,\n    // By default, reserved words are not enforced. Enable\n    // `forbidReserved` to enforce them.\n    forbidReserved: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `location` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `location` is on or off.\n    directSourceFile: null\n  };\n\n  function setOptions(opts) {\n    options = opts || {};\n    for (var opt in defaultOptions) {\n      if (!Object.prototype.hasOwnProperty.call(options, opt)) options[opt] = defaultOptions[opt];\n    }sourceFile = options.sourceFile || null;\n  }\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  var getLineInfo = exports.getLineInfo = function (input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreak.lastIndex = cur;\n      var match = lineBreak.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else break;\n    }\n    return { line: line, column: offset - cur };\n  };\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenize` export provides an interface to the tokenizer.\n  // Because the tokenizer is optimized for being efficiently used by\n  // the Acorn parser itself, this interface is somewhat crude and not\n  // very modular. Performing another parse or call to `tokenize` will\n  // reset the internal state, and invalidate existing tokenizers.\n\n  exports.tokenize = function (inpt, opts) {\n    input = String(inpt);inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n\n    var t = {};\n    function getToken(forceRegexp) {\n      readToken(forceRegexp);\n      t.start = tokStart;t.end = tokEnd;\n      t.startLoc = tokStartLoc;t.endLoc = tokEndLoc;\n      t.type = tokType;t.value = tokVal;\n      return t;\n    }\n    getToken.jumpTo = function (pos, reAllowed) {\n      tokPos = pos;\n      if (options.locations) {\n        tokCurLine = 1;\n        tokLineStart = lineBreak.lastIndex = 0;\n        var match;\n        while ((match = lineBreak.exec(input)) && match.index < pos) {\n          ++tokCurLine;\n          tokLineStart = match.index + match[0].length;\n        }\n      }\n      tokRegexpAllowed = reAllowed;\n      skipSpace();\n    };\n    return getToken;\n  };\n\n  // State is kept in (closure-)global variables. We already saw the\n  // `options`, `input`, and `inputLen` variables above.\n\n  // The current position of the tokenizer in the input.\n\n  var tokPos;\n\n  // The start and end offsets of the current token.\n\n  var tokStart, tokEnd;\n\n  // When `options.locations` is true, these hold objects\n  // containing the tokens start and end line/column pairs.\n\n  var tokStartLoc, tokEndLoc;\n\n  // The type and value of the current token. Token types are objects,\n  // named by variables against which they can be compared, and\n  // holding properties that describe them (indicating, for example,\n  // the precedence of an infix operator, and the original name of a\n  // keyword token). The kind of value that's held in `tokVal` depends\n  // on the type of the token. For literals, it is the literal value,\n  // for operators, the operator name, and so on.\n\n  var tokType, tokVal;\n\n  // Interal state for the tokenizer. To distinguish between division\n  // operators and regular expressions, it remembers whether the last\n  // token was one that is allowed to be followed by an expression.\n  // (If it is, a slash is probably a regexp, if it isn't it's a\n  // division operator. See the `parseStatement` function for a\n  // caveat.)\n\n  var tokRegexpAllowed;\n\n  // When `options.locations` is true, these are used to keep\n  // track of the current line, and know when a new line has been\n  // entered.\n\n  var tokCurLine, tokLineStart;\n\n  // These store the position of the previous token, which is useful\n  // when finishing a node and assigning its `end` position.\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  // This is the parser's state. `inFunction` is used to reject\n  // `return` statements outside of functions, `labels` to verify that\n  // `break` and `continue` have somewhere to jump to, and `strict`\n  // indicates whether strict mode is on.\n\n  var inFunction, labels, strict;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  function raise(pos, message) {\n    var loc = getLineInfo(input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos;err.loc = loc;err.raisedAt = tokPos;\n    throw err;\n  }\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // These are the general types. The `type` property is only used to\n  // make them recognizeable when debugging.\n\n  var _num = { type: \"num\" },\n      _regexp = { type: \"regexp\" },\n      _string = { type: \"string\" };\n  var _name = { type: \"name\" },\n      _eof = { type: \"eof\" };\n\n  // Keyword tokens. The `keyword` property (also used in keyword-like\n  // operators) indicates that the token originated from an\n  // identifier-like word, which is used when parsing property names.\n  //\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var _break = { keyword: \"break\" },\n      _case = { keyword: \"case\", beforeExpr: true },\n      _catch = { keyword: \"catch\" };\n  var _continue = { keyword: \"continue\" },\n      _debugger = { keyword: \"debugger\" },\n      _default = { keyword: \"default\" };\n  var _do = { keyword: \"do\", isLoop: true },\n      _else = { keyword: \"else\", beforeExpr: true };\n  var _finally = { keyword: \"finally\" },\n      _for = { keyword: \"for\", isLoop: true },\n      _function = { keyword: \"function\" };\n  var _if = { keyword: \"if\" },\n      _return = { keyword: \"return\", beforeExpr: true },\n      _switch = { keyword: \"switch\" };\n  var _throw = { keyword: \"throw\", beforeExpr: true },\n      _try = { keyword: \"try\" },\n      _var = { keyword: \"var\" };\n  var _while = { keyword: \"while\", isLoop: true },\n      _with = { keyword: \"with\" },\n      _new = { keyword: \"new\", beforeExpr: true };\n  var _this = { keyword: \"this\" };\n\n  // The keywords that denote values.\n\n  var _null = { keyword: \"null\", atomValue: null },\n      _true = { keyword: \"true\", atomValue: true };\n  var _false = { keyword: \"false\", atomValue: false };\n\n  // Some keywords are treated as regular operators. `in` sometimes\n  // (when parsing `for`) needs to be tested against specifically, so\n  // we assign a variable name to it for quick comparing.\n\n  var _in = { keyword: \"in\", binop: 7, beforeExpr: true };\n\n  // Map keyword names to token types.\n\n  var keywordTypes = { \"break\": _break, \"case\": _case, \"catch\": _catch,\n    \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n    \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n    \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n    \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n    \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n    \"instanceof\": { keyword: \"instanceof\", binop: 7, beforeExpr: true }, \"this\": _this,\n    \"typeof\": { keyword: \"typeof\", prefix: true, beforeExpr: true },\n    \"void\": { keyword: \"void\", prefix: true, beforeExpr: true },\n    \"delete\": { keyword: \"delete\", prefix: true, beforeExpr: true } };\n\n  // Punctuation token types. Again, the `type` property is purely for debugging.\n\n  var _bracketL = { type: \"[\", beforeExpr: true },\n      _bracketR = { type: \"]\" },\n      _braceL = { type: \"{\", beforeExpr: true };\n  var _braceR = { type: \"}\" },\n      _parenL = { type: \"(\", beforeExpr: true },\n      _parenR = { type: \")\" };\n  var _comma = { type: \",\", beforeExpr: true },\n      _semi = { type: \";\", beforeExpr: true };\n  var _colon = { type: \":\", beforeExpr: true },\n      _dot = { type: \".\" },\n      _question = { type: \"?\", beforeExpr: true };\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator. `isUpdate` specifies that the node produced by\n  // the operator should be of type UpdateExpression rather than\n  // simply UnaryExpression (`++` and `--`).\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  var _slash = { binop: 10, beforeExpr: true },\n      _eq = { isAssign: true, beforeExpr: true };\n  var _assign = { isAssign: true, beforeExpr: true };\n  var _incDec = { postfix: true, prefix: true, isUpdate: true },\n      _prefix = { prefix: true, beforeExpr: true };\n  var _logicalOR = { binop: 1, beforeExpr: true };\n  var _logicalAND = { binop: 2, beforeExpr: true };\n  var _bitwiseOR = { binop: 3, beforeExpr: true };\n  var _bitwiseXOR = { binop: 4, beforeExpr: true };\n  var _bitwiseAND = { binop: 5, beforeExpr: true };\n  var _equality = { binop: 6, beforeExpr: true };\n  var _relational = { binop: 7, beforeExpr: true };\n  var _bitShift = { binop: 8, beforeExpr: true };\n  var _plusMin = { binop: 9, prefix: true, beforeExpr: true };\n  var _multiplyModulo = { binop: 10, beforeExpr: true };\n\n  // Provide access to the token types for external users of the\n  // tokenizer.\n\n  exports.tokTypes = { bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n    parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n    dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n    num: _num, regexp: _regexp, string: _string };\n  for (var kw in keywordTypes) {\n    exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n  } // This is a trick taken from Esprima. It turns out that, on\n  // non-Chrome browsers, to check whether a string is in a set, a\n  // predicate containing a big ugly `switch` statement is faster than\n  // a regular expression, and on Chrome the two are about on par.\n  // This function uses `eval` (non-lexical) to produce such a\n  // predicate from a space-separated string of words.\n  //\n  // It starts by sorting the words by length.\n\n  function makePredicate(words) {\n    words = words.split(\" \");\n    var f = \"\",\n        cats = [];\n    out: for (var i = 0; i < words.length; ++i) {\n      for (var j = 0; j < cats.length; ++j) {\n        if (cats[j][0].length == words[i].length) {\n          cats[j].push(words[i]);\n          continue out;\n        }\n      }cats.push([words[i]]);\n    }\n    function compareTo(arr) {\n      if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n      f += \"switch(str){\";\n      for (var i = 0; i < arr.length; ++i) {\n        f += \"case \" + JSON.stringify(arr[i]) + \":\";\n      }f += \"return true}return false;\";\n    }\n\n    // When there are more than three length categories, an outer\n    // switch first dispatches on the lengths, to save on comparisons.\n\n    if (cats.length > 3) {\n      cats.sort(function (a, b) {\n        return b.length - a.length;\n      });\n      f += \"switch(str.length){\";\n      for (var i = 0; i < cats.length; ++i) {\n        var cat = cats[i];\n        f += \"case \" + cat[0].length + \":\";\n        compareTo(cat);\n      }\n      f += \"}\";\n\n      // Otherwise, simply generate a flat `switch` statement.\n    } else {\n      compareTo(words);\n    }\n    return new Function(\"str\", f);\n  }\n\n  // The ECMAScript 3 reserved word list.\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  // ECMAScript 5 reserved words.\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  // The additional reserved words in strict mode.\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  // The forbidden variable names in strict mode.\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  // And the keywords.\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u0620-\\u0649\\u0672-\\u06D3\\u06E7-\\u06E8\\u06FB-\\u06FC\\u0730-\\u074A\\u0800-\\u0814\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0840-\\u0857\\u08E4-\\u08FE\\u0900-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09D7\\u09DF-\\u09E0\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5F-\\u0B60\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2-\\u0CE3\\u0CE6-\\u0CEF\\u0D02\\u0D03\\u0D46-\\u0D48\\u0D57\\u0D62-\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E34-\\u0E3A\\u0E40-\\u0E45\\u0E50-\\u0E59\\u0EB4-\\u0EB9\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F41-\\u0F47\\u0F71-\\u0F84\\u0F86-\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u170E-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17B2\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1920-\\u192B\\u1930-\\u193B\\u1951-\\u196D\\u19B0-\\u19C0\\u19C8-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A15\\u1A20-\\u1A53\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1B46-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C00-\\u1C22\\u1C40-\\u1C49\\u1C5B-\\u1C7D\\u1CD0-\\u1CD2\\u1D00-\\u1DBE\\u1E01-\\u1F15\\u200C\\u200D\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2D81-\\u2D96\\u2DE0-\\u2DFF\\u3021-\\u3028\\u3099\\u309A\\uA640-\\uA66D\\uA674-\\uA67D\\uA69F\\uA6F0-\\uA6F1\\uA7F8-\\uA800\\uA806\\uA80B\\uA823-\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C4\\uA8D0-\\uA8D9\\uA8F3-\\uA8F7\\uA900-\\uA909\\uA926-\\uA92D\\uA930-\\uA945\\uA980-\\uA983\\uA9B3-\\uA9C0\\uAA00-\\uAA27\\uAA40-\\uAA41\\uAA4C-\\uAA4D\\uAA50-\\uAA59\\uAA7B\\uAAE0-\\uAAE9\\uAAF2-\\uAAF3\\uABC0-\\uABE1\\uABEC\\uABED\\uABF0-\\uABF9\\uFB20-\\uFB28\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  // Whether a single character denotes a newline.\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  // Test whether a given character code starts an identifier.\n\n  var isIdentifierStart = exports.isIdentifierStart = function (code) {\n    if (code < 65) return code === 36;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  // Test whether a given character is part of an identifier.\n\n  var isIdentifierChar = exports.isIdentifierChar = function (code) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  // ## Tokenizer\n\n  // These are used when `options.locations` is on, for the\n  // `tokStartLoc` and `tokEndLoc` properties.\n\n  function line_loc_t() {\n    this.line = tokCurLine;\n    this.column = tokPos - tokLineStart;\n  }\n\n  // Reset the token state. Used at the start of a parse.\n\n  function initTokenState() {\n    tokCurLine = 1;\n    tokPos = tokLineStart = 0;\n    tokRegexpAllowed = true;\n    skipSpace();\n  }\n\n  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and\n  // `tokRegexpAllowed`, and skips the space after the token, so that\n  // the next one's `tokStart` will point at the right position.\n\n  function finishToken(type, val) {\n    tokEnd = tokPos;\n    if (options.locations) tokEndLoc = new line_loc_t();\n    tokType = type;\n    skipSpace();\n    tokVal = val;\n    tokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n    var startLoc = options.onComment && options.locations && new line_loc_t();\n    var start = tokPos,\n        end = input.indexOf(\"*/\", tokPos += 2);\n    if (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n    tokPos = end + 2;\n    if (options.locations) {\n      lineBreak.lastIndex = start;\n      var match;\n      while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n        ++tokCurLine;\n        tokLineStart = match.index + match[0].length;\n      }\n    }\n    if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t());\n  }\n\n  function skipLineComment() {\n    var start = tokPos;\n    var startLoc = options.onComment && options.locations && new line_loc_t();\n    var ch = input.charCodeAt(tokPos += 2);\n    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++tokPos;\n      ch = input.charCodeAt(tokPos);\n    }\n    if (options.onComment) options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t());\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  function skipSpace() {\n    while (tokPos < inputLen) {\n      var ch = input.charCodeAt(tokPos);\n      if (ch === 32) {\n        // ' '\n        ++tokPos;\n      } else if (ch === 13) {\n        ++tokPos;\n        var next = input.charCodeAt(tokPos);\n        if (next === 10) {\n          ++tokPos;\n        }\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch === 10 || ch === 8232 || ch === 8233) {\n        ++tokPos;\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch > 8 && ch < 14) {\n        ++tokPos;\n      } else if (ch === 47) {\n        // '/'\n        var next = input.charCodeAt(tokPos + 1);\n        if (next === 42) {\n          // '*'\n          skipBlockComment();\n        } else if (next === 47) {\n          // '/'\n          skipLineComment();\n        } else break;\n      } else if (ch === 160) {\n        // '\\xa0'\n        ++tokPos;\n      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++tokPos;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  // The `forceRegexp` parameter is used in the one case where the\n  // `tokRegexpAllowed` trick does not work. See `parseStatement`.\n\n  function readToken_dot() {\n    var next = input.charCodeAt(tokPos + 1);\n    if (next >= 48 && next <= 57) return readNumber(true);\n    ++tokPos;\n    return finishToken(_dot);\n  }\n\n  function readToken_slash() {\n    // '/'\n    var next = input.charCodeAt(tokPos + 1);\n    if (tokRegexpAllowed) {\n      ++tokPos;return readRegexp();\n    }\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() {\n    // '%*'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) {\n    // '|&'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() {\n    // '^'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) {\n    // '+-'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) {\n      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {\n        // A `-->` line comment\n        tokPos += 3;\n        skipLineComment();\n        skipSpace();\n        return readToken();\n      }\n      return finishOp(_incDec, 2);\n    }\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) {\n    // '<>'\n    var next = input.charCodeAt(tokPos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n      return finishOp(_bitShift, size);\n    }\n    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      tokPos += 4;\n      skipLineComment();\n      skipSpace();\n      return readToken();\n    }\n    if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n    return finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) {\n    // '=!'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n    return finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit.\n      case 46:\n        // '.'\n        return readToken_dot();\n\n      // Punctuation tokens.\n      case 40:\n        ++tokPos;return finishToken(_parenL);\n      case 41:\n        ++tokPos;return finishToken(_parenR);\n      case 59:\n        ++tokPos;return finishToken(_semi);\n      case 44:\n        ++tokPos;return finishToken(_comma);\n      case 91:\n        ++tokPos;return finishToken(_bracketL);\n      case 93:\n        ++tokPos;return finishToken(_bracketR);\n      case 123:\n        ++tokPos;return finishToken(_braceL);\n      case 125:\n        ++tokPos;return finishToken(_braceR);\n      case 58:\n        ++tokPos;return finishToken(_colon);\n      case 63:\n        ++tokPos;return finishToken(_question);\n\n      // '0x' is a hexadecimal number.\n      case 48:\n        // '0'\n        var next = input.charCodeAt(tokPos + 1);\n        if (next === 120 || next === 88) return readHexNumber();\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:\n        // 1-9\n        return readNumber(false);\n\n      // Quotes produce strings.\n      case 34:case 39:\n        // '\"', \"'\"\n        return readString(code);\n\n      // Operators are parsed inline in tiny state machines. '=' (61) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case 47:\n        // '/'\n        return readToken_slash(code);\n\n      case 37:case 42:\n        // '%*'\n        return readToken_mult_modulo();\n\n      case 124:case 38:\n        // '|&'\n        return readToken_pipe_amp(code);\n\n      case 94:\n        // '^'\n        return readToken_caret();\n\n      case 43:case 45:\n        // '+-'\n        return readToken_plus_min(code);\n\n      case 60:case 62:\n        // '<>'\n        return readToken_lt_gt(code);\n\n      case 61:case 33:\n        // '=!'\n        return readToken_eq_excl(code);\n\n      case 126:\n        // '~'\n        return finishOp(_prefix, 1);\n    }\n\n    return false;\n  }\n\n  function readToken(forceRegexp) {\n    if (!forceRegexp) tokStart = tokPos;else tokPos = tokStart + 1;\n    if (options.locations) tokStartLoc = new line_loc_t();\n    if (forceRegexp) return readRegexp();\n    if (tokPos >= inputLen) return finishToken(_eof);\n\n    var code = input.charCodeAt(tokPos);\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) return readWord();\n\n    var tok = getTokenFromCode(code);\n\n    if (tok === false) {\n      // If we are here, we either found a non-ASCII identifier\n      // character, or something that's entirely disallowed.\n      var ch = String.fromCharCode(code);\n      if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n      raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n    }\n    return tok;\n  }\n\n  function finishOp(type, size) {\n    var str = input.slice(tokPos, tokPos + size);\n    tokPos += size;\n    finishToken(type, str);\n  }\n\n  // Parse a regular expression. Some context-awareness is necessary,\n  // since a '/' inside a '[]' set does not end the expression.\n\n  function readRegexp() {\n    var content = \"\",\n        escaped,\n        inClass,\n        start = tokPos;\n    for (;;) {\n      if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n      var ch = input.charAt(tokPos);\n      if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n      if (!escaped) {\n        if (ch === \"[\") inClass = true;else if (ch === \"]\" && inClass) inClass = false;else if (ch === \"/\" && !inClass) break;\n        escaped = ch === \"\\\\\";\n      } else escaped = false;\n      ++tokPos;\n    }\n    var content = input.slice(start, tokPos);\n    ++tokPos;\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n    var mods = readWord1();\n    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n    return finishToken(_regexp, new RegExp(content, mods));\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  function readInt(radix, len) {\n    var start = tokPos,\n        total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = input.charCodeAt(tokPos),\n          val;\n      if (code >= 97) val = code - 97 + 10; // a\n      else if (code >= 65) val = code - 65 + 10; // A\n        else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n          else val = Infinity;\n      if (val >= radix) break;\n      ++tokPos;\n      total = total * radix + val;\n    }\n    if (tokPos === start || len != null && tokPos - start !== len) return null;\n\n    return total;\n  }\n\n  function readHexNumber() {\n    tokPos += 2; // 0x\n    var val = readInt(16);\n    if (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n    return finishToken(_num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  function readNumber(startsWithDot) {\n    var start = tokPos,\n        isFloat = false,\n        octal = input.charCodeAt(tokPos) === 48;\n    if (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n    if (input.charCodeAt(tokPos) === 46) {\n      ++tokPos;\n      readInt(10);\n      isFloat = true;\n    }\n    var next = input.charCodeAt(tokPos);\n    if (next === 69 || next === 101) {\n      // 'eE'\n      next = input.charCodeAt(++tokPos);\n      if (next === 43 || next === 45) ++tokPos; // '+-'\n      if (readInt(10) === null) raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n    var str = input.slice(start, tokPos),\n        val;\n    if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");else val = parseInt(str, 8);\n    return finishToken(_num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  function readString(quote) {\n    tokPos++;\n    var out = \"\";\n    for (;;) {\n      if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n      var ch = input.charCodeAt(tokPos);\n      if (ch === quote) {\n        ++tokPos;\n        return finishToken(_string, out);\n      }\n      if (ch === 92) {\n        // '\\'\n        ch = input.charCodeAt(++tokPos);\n        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n        if (octal) octal = octal[0];\n        while (octal && parseInt(octal, 8) > 255) {\n          octal = octal.slice(0, -1);\n        }if (octal === \"0\") octal = null;\n        ++tokPos;\n        if (octal) {\n          if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n          out += String.fromCharCode(parseInt(octal, 8));\n          tokPos += octal.length - 1;\n        } else {\n          switch (ch) {\n            case 110:\n              out += \"\\n\";break; // 'n' -> '\\n'\n            case 114:\n              out += \"\\r\";break; // 'r' -> '\\r'\n            case 120:\n              out += String.fromCharCode(readHexChar(2));break; // 'x'\n            case 117:\n              out += String.fromCharCode(readHexChar(4));break; // 'u'\n            case 85:\n              out += String.fromCharCode(readHexChar(8));break; // 'U'\n            case 116:\n              out += \"\\t\";break; // 't' -> '\\t'\n            case 98:\n              out += \"\\b\";break; // 'b' -> '\\b'\n            case 118:\n              out += \"\\x0B\";break; // 'v' -> '\\u000b'\n            case 102:\n              out += \"\\f\";break; // 'f' -> '\\f'\n            case 48:\n              out += \"\\0\";break; // 0 -> '\\0'\n            case 13:\n              if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\\r\\n'\n            case 10:\n              // ' \\n'\n              if (options.locations) {\n                tokLineStart = tokPos;++tokCurLine;\n              }\n              break;\n            default:\n              out += String.fromCharCode(ch);break;\n          }\n        }\n      } else {\n        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n        out += String.fromCharCode(ch); // '\\'\n        ++tokPos;\n      }\n    }\n  }\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  function readHexChar(len) {\n    var n = readInt(16, len);\n    if (n === null) raise(tokStart, \"Bad character escape sequence\");\n    return n;\n  }\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n  var containsEsc;\n\n  // Read an identifier, and return it as a string. Sets `containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Only builds up the word character-by-character when it actually\n  // containeds an escape, as a micro-optimization.\n\n  function readWord1() {\n    containsEsc = false;\n    var word,\n        first = true,\n        start = tokPos;\n    for (;;) {\n      var ch = input.charCodeAt(tokPos);\n      if (isIdentifierChar(ch)) {\n        if (containsEsc) word += input.charAt(tokPos);\n        ++tokPos;\n      } else if (ch === 92) {\n        // \"\\\"\n        if (!containsEsc) word = input.slice(start, tokPos);\n        containsEsc = true;\n        if (input.charCodeAt(++tokPos) != 117) // \"u\"\n          raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        ++tokPos;\n        var esc = readHexChar(4);\n        var escStr = String.fromCharCode(esc);\n        if (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, \"Invalid Unicode escape\");\n        word += escStr;\n      } else {\n        break;\n      }\n      first = false;\n    }\n    return containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  function readWord() {\n    var word = readWord1();\n    var type = _name;\n    if (!containsEsc) {\n      if (isKeyword(word)) type = keywordTypes[word];else if (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) || strict && isStrictReservedWord(word)) raise(tokStart, \"The keyword '\" + word + \"' is reserved\");\n    }\n    return finishToken(type, word);\n  }\n\n  // ## Parser\n\n  // A recursive descent parser operates by defining functions for all\n  // syntactic elements, and recursively calling those, each function\n  // advancing the input stream and returning an AST node. Precedence\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n  // instead of `(!x)[1]` is handled by the fact that the parser\n  // function that parses unary prefix operators is called first, and\n  // in turn calls the function that parses `[]` subscripts  that\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\n  // *that* in the unary operator node.\n  //\n  // Acorn uses an [operator precedence parser][opp] to handle binary\n  // operator precedence, because it is much more compact than using\n  // the technique outlined above, which uses different, nesting\n  // functions to specify precedence, for all of the ten binary\n  // precedence levels that JavaScript defines.\n  //\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n  // ### Parser utilities\n\n  // Continue to the next token.\n\n  function next() {\n    lastStart = tokStart;\n    lastEnd = tokEnd;\n    lastEndLoc = tokEndLoc;\n    readToken();\n  }\n\n  // Enter strict mode. Re-reads the next token to please pedantic\n  // tests (\"use strict\"; 010; -- should fail).\n\n  function setStrict(strct) {\n    strict = strct;\n    tokPos = lastEnd;\n    if (options.locations) {\n      while (tokPos < tokLineStart) {\n        tokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n        --tokCurLine;\n      }\n    }\n    skipSpace();\n    readToken();\n  }\n\n  // Start an AST node, attaching a start offset.\n\n  function node_t() {\n    this.type = null;\n    this.start = tokStart;\n    this.end = null;\n  }\n\n  function node_loc_t() {\n    this.start = tokStartLoc;\n    this.end = null;\n    if (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n    var node = new node_t();\n    if (options.locations) node.loc = new node_loc_t();\n    if (options.directSourceFile) node.sourceFile = options.directSourceFile;\n    if (options.ranges) node.range = [tokStart, 0];\n    return node;\n  }\n\n  // Start a node whose start offset information should be based on\n  // the start of another node. For example, a binary operator node is\n  // only started after its left-hand side has already been parsed.\n\n  function startNodeFrom(other) {\n    var node = new node_t();\n    node.start = other.start;\n    if (options.locations) {\n      node.loc = new node_loc_t();\n      node.loc.start = other.loc.start;\n    }\n    if (options.ranges) node.range = [other.range[0], 0];\n\n    return node;\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNode(node, type) {\n    node.type = type;\n    node.end = lastEnd;\n    if (options.locations) node.loc.end = lastEndLoc;\n    if (options.ranges) node.range[1] = lastEnd;\n    return node;\n  }\n\n  // Test whether a statement node is the string literal `\"use strict\"`.\n\n  function isUseStrict(stmt) {\n    return options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  function eat(type) {\n    if (tokType === type) {\n      next();\n      return true;\n    }\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  function canInsertSemicolon() {\n    return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  function semicolon() {\n    if (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  function expect(type) {\n    if (tokType === type) next();else unexpected();\n  }\n\n  // Raise an unexpected token error.\n\n  function unexpected() {\n    raise(tokStart, \"Unexpected token\");\n  }\n\n  // Verify that a node is an lval  something that can be assigned\n  // to.\n\n  function checkLVal(expr) {\n    if (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\") raise(expr.start, \"Assigning to rvalue\");\n    if (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name)) raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  function parseTopLevel(program) {\n    lastStart = lastEnd = tokPos;\n    if (options.locations) lastEndLoc = new line_loc_t();\n    inFunction = strict = null;\n    labels = [];\n    readToken();\n\n    var node = program || startNode(),\n        first = true;\n    if (!program) node.body = [];\n    while (tokType !== _eof) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && isUseStrict(stmt)) setStrict(true);\n      first = false;\n    }\n    return finishNode(node, \"Program\");\n  }\n\n  var loopLabel = { kind: \"loop\" },\n      switchLabel = { kind: \"switch\" };\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo);`, where looking at the previous token\n  // does not help.\n\n  function parseStatement() {\n    if (tokType === _slash || tokType === _assign && tokVal == \"/=\") readToken(true);\n\n    var starttype = tokType,\n        node = startNode();\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n      case _break:case _continue:\n        next();\n        var isBreak = starttype === _break;\n        if (eat(_semi) || canInsertSemicolon()) node.label = null;else if (tokType !== _name) unexpected();else {\n          node.label = parseIdent();\n          semicolon();\n        }\n\n        // Verify that there is an actual destination to break or\n        // continue to.\n        for (var i = 0; i < labels.length; ++i) {\n          var lab = labels[i];\n          if (node.label == null || lab.name === node.label.name) {\n            if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n            if (node.label && isBreak) break;\n          }\n        }\n        if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n        return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n      case _debugger:\n        next();\n        semicolon();\n        return finishNode(node, \"DebuggerStatement\");\n\n      case _do:\n        next();\n        labels.push(loopLabel);\n        node.body = parseStatement();\n        labels.pop();\n        expect(_while);\n        node.test = parseParenExpression();\n        semicolon();\n        return finishNode(node, \"DoWhileStatement\");\n\n      // Disambiguating between a `for` and a `for`/`in` loop is\n      // non-trivial. Basically, we have to parse the init `var`\n      // statement or expression, disallowing the `in` operator (see\n      // the second parameter to `parseExpression`), and then check\n      // whether the next token is `in`. When there is no init part\n      // (semicolon immediately after the opening parenthesis), it is\n      // a regular `for` loop.\n\n      case _for:\n        next();\n        labels.push(loopLabel);\n        expect(_parenL);\n        if (tokType === _semi) return parseFor(node, null);\n        if (tokType === _var) {\n          var init = startNode();\n          next();\n          parseVar(init, true);\n          finishNode(init, \"VariableDeclaration\");\n          if (init.declarations.length === 1 && eat(_in)) return parseForIn(node, init);\n          return parseFor(node, init);\n        }\n        var init = parseExpression(false, true);\n        if (eat(_in)) {\n          checkLVal(init);return parseForIn(node, init);\n        }\n        return parseFor(node, init);\n\n      case _function:\n        next();\n        return parseFunction(node, true);\n\n      case _if:\n        next();\n        node.test = parseParenExpression();\n        node.consequent = parseStatement();\n        node.alternate = eat(_else) ? parseStatement() : null;\n        return finishNode(node, \"IfStatement\");\n\n      case _return:\n        if (!inFunction) raise(tokStart, \"'return' outside of function\");\n        next();\n\n        // In `return` (and `break`/`continue`), the keywords with\n        // optional arguments, we eagerly look for a semicolon or the\n        // possibility to insert one.\n\n        if (eat(_semi) || canInsertSemicolon()) node.argument = null;else {\n          node.argument = parseExpression();semicolon();\n        }\n        return finishNode(node, \"ReturnStatement\");\n\n      case _switch:\n        next();\n        node.discriminant = parseParenExpression();\n        node.cases = [];\n        expect(_braceL);\n        labels.push(switchLabel);\n\n        // Statements under must be grouped (by label) in SwitchCase\n        // nodes. `cur` is used to keep the node that we are currently\n        // adding statements to.\n\n        for (var cur, sawDefault; tokType != _braceR;) {\n          if (tokType === _case || tokType === _default) {\n            var isCase = tokType === _case;\n            if (cur) finishNode(cur, \"SwitchCase\");\n            node.cases.push(cur = startNode());\n            cur.consequent = [];\n            next();\n            if (isCase) cur.test = parseExpression();else {\n              if (sawDefault) raise(lastStart, \"Multiple default clauses\");sawDefault = true;\n              cur.test = null;\n            }\n            expect(_colon);\n          } else {\n            if (!cur) unexpected();\n            cur.consequent.push(parseStatement());\n          }\n        }\n        if (cur) finishNode(cur, \"SwitchCase\");\n        next(); // Closing brace\n        labels.pop();\n        return finishNode(node, \"SwitchStatement\");\n\n      case _throw:\n        next();\n        if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, \"Illegal newline after throw\");\n        node.argument = parseExpression();\n        semicolon();\n        return finishNode(node, \"ThrowStatement\");\n\n      case _try:\n        next();\n        node.block = parseBlock();\n        node.handler = null;\n        if (tokType === _catch) {\n          var clause = startNode();\n          next();\n          expect(_parenL);\n          clause.param = parseIdent();\n          if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n          expect(_parenR);\n          clause.guard = null;\n          clause.body = parseBlock();\n          node.handler = finishNode(clause, \"CatchClause\");\n        }\n        node.guardedHandlers = empty;\n        node.finalizer = eat(_finally) ? parseBlock() : null;\n        if (!node.handler && !node.finalizer) raise(node.start, \"Missing catch or finally clause\");\n        return finishNode(node, \"TryStatement\");\n\n      case _var:\n        next();\n        parseVar(node);\n        semicolon();\n        return finishNode(node, \"VariableDeclaration\");\n\n      case _while:\n        next();\n        node.test = parseParenExpression();\n        labels.push(loopLabel);\n        node.body = parseStatement();\n        labels.pop();\n        return finishNode(node, \"WhileStatement\");\n\n      case _with:\n        if (strict) raise(tokStart, \"'with' in strict mode\");\n        next();\n        node.object = parseParenExpression();\n        node.body = parseStatement();\n        return finishNode(node, \"WithStatement\");\n\n      case _braceL:\n        return parseBlock();\n\n      case _semi:\n        next();\n        return finishNode(node, \"EmptyStatement\");\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n\n      default:\n        var maybeName = tokVal,\n            expr = parseExpression();\n        if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n          for (var i = 0; i < labels.length; ++i) {\n            if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n          }var kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n          labels.push({ name: maybeName, kind: kind });\n          node.body = parseStatement();\n          labels.pop();\n          node.label = expr;\n          return finishNode(node, \"LabeledStatement\");\n        } else {\n          node.expression = expr;\n          semicolon();\n          return finishNode(node, \"ExpressionStatement\");\n        }\n    }\n  }\n\n  // Used for constructs like `switch` and `if` that insist on\n  // parentheses around their expression.\n\n  function parseParenExpression() {\n    expect(_parenL);\n    var val = parseExpression();\n    expect(_parenR);\n    return val;\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  function parseBlock(allowStrict) {\n    var node = startNode(),\n        first = true,\n        strict = false,\n        oldStrict;\n    node.body = [];\n    expect(_braceL);\n    while (!eat(_braceR)) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && allowStrict && isUseStrict(stmt)) {\n        oldStrict = strict;\n        setStrict(strict = true);\n      }\n      first = false;\n    }\n    if (strict && !oldStrict) setStrict(false);\n    return finishNode(node, \"BlockStatement\");\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  function parseFor(node, init) {\n    node.init = init;\n    expect(_semi);\n    node.test = tokType === _semi ? null : parseExpression();\n    expect(_semi);\n    node.update = tokType === _parenR ? null : parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` loop.\n\n  function parseForIn(node, init) {\n    node.left = init;\n    node.right = parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForInStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  function parseVar(node, noIn) {\n    node.declarations = [];\n    node.kind = \"var\";\n    for (;;) {\n      var decl = startNode();\n      decl.id = parseIdent();\n      if (strict && isStrictBadIdWord(decl.id.name)) raise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n      decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n      node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n      if (!eat(_comma)) break;\n    }\n    return node;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The arguments are used to forbid comma\n  // sequences (in argument lists, array literals, or object literals)\n  // or the `in` operator (in for loops initalization expressions).\n\n  function parseExpression(noComma, noIn) {\n    var expr = parseMaybeAssign(noIn);\n    if (!noComma && tokType === _comma) {\n      var node = startNodeFrom(expr);\n      node.expressions = [expr];\n      while (eat(_comma)) {\n        node.expressions.push(parseMaybeAssign(noIn));\n      }return finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  function parseMaybeAssign(noIn) {\n    var left = parseMaybeConditional(noIn);\n    if (tokType.isAssign) {\n      var node = startNodeFrom(left);\n      node.operator = tokVal;\n      node.left = left;\n      next();\n      node.right = parseMaybeAssign(noIn);\n      checkLVal(left);\n      return finishNode(node, \"AssignmentExpression\");\n    }\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  function parseMaybeConditional(noIn) {\n    var expr = parseExprOps(noIn);\n    if (eat(_question)) {\n      var node = startNodeFrom(expr);\n      node.test = expr;\n      node.consequent = parseExpression(true);\n      expect(_colon);\n      node.alternate = parseExpression(true, noIn);\n      return finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  // Start the precedence parser.\n\n  function parseExprOps(noIn) {\n    return parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  function parseExprOp(left, minPrec, noIn) {\n    var prec = tokType.binop;\n    if (prec != null && (!noIn || tokType !== _in)) {\n      if (prec > minPrec) {\n        var node = startNodeFrom(left);\n        node.left = left;\n        node.operator = tokVal;\n        var op = tokType;\n        next();\n        node.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n        var exprNode = finishNode(node, op === _logicalOR || op === _logicalAND ? \"LogicalExpression\" : \"BinaryExpression\");\n        return parseExprOp(exprNode, minPrec, noIn);\n      }\n    }\n    return left;\n  }\n\n  // Parse unary operators, both prefix and postfix.\n\n  function parseMaybeUnary() {\n    if (tokType.prefix) {\n      var node = startNode(),\n          update = tokType.isUpdate;\n      node.operator = tokVal;\n      node.prefix = true;\n      tokRegexpAllowed = true;\n      next();\n      node.argument = parseMaybeUnary();\n      if (update) checkLVal(node.argument);else if (strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") raise(node.start, \"Deleting local variable in strict mode\");\n      return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n    var expr = parseExprSubscripts();\n    while (tokType.postfix && !canInsertSemicolon()) {\n      var node = startNodeFrom(expr);\n      node.operator = tokVal;\n      node.prefix = false;\n      node.argument = expr;\n      checkLVal(expr);\n      next();\n      expr = finishNode(node, \"UpdateExpression\");\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  function parseExprSubscripts() {\n    return parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n    if (eat(_dot)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseIdent(true);\n      node.computed = false;\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (eat(_bracketL)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseExpression();\n      node.computed = true;\n      expect(_bracketR);\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (!noCalls && eat(_parenL)) {\n      var node = startNodeFrom(base);\n      node.callee = base;\n      node.arguments = parseExprList(_parenR, false);\n      return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n    } else return base;\n  }\n\n  // Parse an atomic expression  either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  function parseExprAtom() {\n    switch (tokType) {\n      case _this:\n        var node = startNode();\n        next();\n        return finishNode(node, \"ThisExpression\");\n      case _name:\n        return parseIdent();\n      case _num:case _string:case _regexp:\n        var node = startNode();\n        node.value = tokVal;\n        node.raw = input.slice(tokStart, tokEnd);\n        next();\n        return finishNode(node, \"Literal\");\n\n      case _null:case _true:case _false:\n        var node = startNode();\n        node.value = tokType.atomValue;\n        node.raw = tokType.keyword;\n        next();\n        return finishNode(node, \"Literal\");\n\n      case _parenL:\n        var tokStartLoc1 = tokStartLoc,\n            tokStart1 = tokStart;\n        next();\n        var val = parseExpression();\n        val.start = tokStart1;\n        val.end = tokEnd;\n        if (options.locations) {\n          val.loc.start = tokStartLoc1;\n          val.loc.end = tokEndLoc;\n        }\n        if (options.ranges) val.range = [tokStart1, tokEnd];\n        expect(_parenR);\n        return val;\n\n      case _bracketL:\n        var node = startNode();\n        next();\n        node.elements = parseExprList(_bracketR, true, true);\n        return finishNode(node, \"ArrayExpression\");\n\n      case _braceL:\n        return parseObj();\n\n      case _function:\n        var node = startNode();\n        next();\n        return parseFunction(node, false);\n\n      case _new:\n        return parseNew();\n\n      default:\n        unexpected();\n    }\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument\n  // to be a `[]` or dot subscript expression, but not a call  at\n  // least, not without wrapping it in parentheses. Thus, it uses the\n\n  function parseNew() {\n    var node = startNode();\n    next();\n    node.callee = parseSubscripts(parseExprAtom(), true);\n    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);else node.arguments = empty;\n    return finishNode(node, \"NewExpression\");\n  }\n\n  // Parse an object literal.\n\n  function parseObj() {\n    var node = startNode(),\n        first = true,\n        sawGetSet = false;\n    node.properties = [];\n    next();\n    while (!eat(_braceR)) {\n      if (!first) {\n        expect(_comma);\n        if (options.allowTrailingCommas && eat(_braceR)) break;\n      } else first = false;\n\n      var prop = { key: parsePropertyName() },\n          isGetSet = false,\n          kind;\n      if (eat(_colon)) {\n        prop.value = parseExpression(true);\n        kind = prop.kind = \"init\";\n      } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n        isGetSet = sawGetSet = true;\n        kind = prop.kind = prop.key.name;\n        prop.key = parsePropertyName();\n        if (tokType !== _parenL) unexpected();\n        prop.value = parseFunction(startNode(), false);\n      } else unexpected();\n\n      // getters and setters are not allowed to clash  either with\n      // each other or with an init property  and in strict mode,\n      // init properties are also not allowed to be repeated.\n\n      if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var other = node.properties[i];\n          if (other.key.name === prop.key.name) {\n            var conflict = kind == other.kind || isGetSet && other.kind === \"init\" || kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n            if (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n            if (conflict) raise(prop.key.start, \"Redefinition of property\");\n          }\n        }\n      }\n      node.properties.push(prop);\n    }\n    return finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n    if (tokType === _num || tokType === _string) return parseExprAtom();\n    return parseIdent(true);\n  }\n\n  // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  function parseFunction(node, isStatement) {\n    if (tokType === _name) node.id = parseIdent();else if (isStatement) unexpected();else node.id = null;\n    node.params = [];\n    var first = true;\n    expect(_parenL);\n    while (!eat(_parenR)) {\n      if (!first) expect(_comma);else first = false;\n      node.params.push(parseIdent());\n    }\n\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldInFunc = inFunction,\n        oldLabels = labels;\n    inFunction = true;labels = [];\n    node.body = parseBlock(true);\n    inFunction = oldInFunc;labels = oldLabels;\n\n    // If this is a strict mode function, verify that argument names\n    // are not repeated, and it does not try to bind the words `eval`\n    // or `arguments`.\n    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n      for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n        var id = i < 0 ? node.id : node.params[i];\n        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name)) raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n        if (i >= 0) for (var j = 0; j < i; ++j) {\n          if (id.name === node.params[j].name) raise(id.start, \"Argument name clash in strict mode\");\n        }\n      }\n    }\n\n    return finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n    var elts = [],\n        first = true;\n    while (!eat(close)) {\n      if (!first) {\n        expect(_comma);\n        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n      } else first = false;\n\n      if (allowEmpty && tokType === _comma) elts.push(null);else elts.push(parseExpression(true));\n    }\n    return elts;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  function parseIdent(liberal) {\n    var node = startNode();\n    node.name = tokType === _name ? tokVal : liberal && !options.forbidReserved && tokType.keyword || unexpected();\n    tokRegexpAllowed = false;\n    next();\n    return finishNode(node, \"Identifier\");\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference path=\"./_estree.d.ts\" />\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\r\n    \"use strict\";\r\n    /**\r\n     * @license\r\n     * JavaScript Interpreter\r\n     *\r\n     * Copyright 2013-2017 Google Inc. and Jun Kato\r\n     *\r\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n     * you may not use this file except in compliance with the License.\r\n     * You may obtain a copy of the License at\r\n     *\r\n     *   http://www.apache.org/licenses/LICENSE-2.0\r\n     *\r\n     * Unless required by applicable law or agreed to in writing, software\r\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n     * See the License for the specific language governing permissions and\r\n     * limitations under the License.\r\n     */\r\n    /**\r\n     * @fileoverview Interpreting JavaScript in JavaScript.\r\n     * @author fraser@google.com (Neil Fraser)\r\n     * @author i@junkato (Jun Kato)\r\n     */\r\n    /**\r\n     * Create a new interpreter.\r\n     * @param {string|!Object} code Raw JavaScript text or AST.\r\n     * @param {Function=} opt_initFunc Optional initialization function.  Used to\r\n     *     define APIs.  When called it is passed the interpreter object and the\r\n     *     global scope object.\r\n     * @constructor\r\n     */\r\n    var Interpreter = (function () {\r\n        function Interpreter(code, opt_initFunc) {\r\n            if (typeof code === 'string') {\r\n                code = Interpreter.acorn.parse(code, Interpreter.PARSE_OPTIONS);\r\n            }\r\n            this.ast = code;\r\n            this.initFunc_ = opt_initFunc;\r\n            this.paused_ = false;\r\n            this.polyfills_ = [];\r\n            // Unique identifier for native functions.  Used in serialization.\r\n            this.functionCounter_ = 0;\r\n            // Map node types to our step function names; a property lookup is faster\r\n            // than string concatenation with \"step\" prefix.\r\n            this.stepFunctions_ = Object.create(null);\r\n            var stepMatch = /^step([A-Z]\\w*)$/;\r\n            var m;\r\n            for (var methodName in this) {\r\n                if ((typeof this[methodName] === 'function') &&\r\n                    (m = methodName.match(stepMatch))) {\r\n                    this.stepFunctions_[m[1]] = this[methodName].bind(this);\r\n                }\r\n            }\r\n            // Create and initialize the global scope.\r\n            this.global = this.createScope(this.ast, null);\r\n            // Run the polyfills.\r\n            this.ast = Interpreter.acorn.parse(this.polyfills_.join('\\n'), Interpreter.PARSE_OPTIONS);\r\n            this.polyfills_ = undefined; // Allow polyfill strings to garbage collect.\r\n            this.stripLocations_(this.ast, undefined, undefined);\r\n            var state = new Interpreter.MyState(this.ast, this.global);\r\n            state.done = false;\r\n            this.stateStack = [state];\r\n            this.run();\r\n            this.value = undefined;\r\n            // Point at the main program.\r\n            this.ast = code;\r\n            var state = new Interpreter.MyState(this.ast, this.global);\r\n            state.done = false;\r\n            this.stateStack.length = 0;\r\n            this.stateStack[0] = state;\r\n            // Get a handle on Acorn's node_t object.  It's tricky to access.\r\n            this.nodeConstructor = state.node.constructor;\r\n            // Preserve publicly properties from being pruned/renamed by JS compilers.\r\n            // Add others as needed.\r\n            this['stateStack'] = this.stateStack;\r\n            this['OBJECT'] = this.OBJECT;\r\n            this['OBJECT_PROTO'] = this.OBJECT_PROTO;\r\n            this['FUNCTION'] = this.FUNCTION;\r\n            this['FUNCTION_PROTO'] = this.FUNCTION_PROTO;\r\n            this['ARRAY'] = this.ARRAY;\r\n            this['ARRAY_PROTO'] = this.ARRAY_PROTO;\r\n            this['REGEXP'] = this.REGEXP;\r\n            this['REGEXP_PROTO'] = this.REGEXP_PROTO;\r\n            // The following properties are obsolete.  Do not use.\r\n            this['UNDEFINED'] = undefined;\r\n            this['NULL'] = null;\r\n            this['NAN'] = NaN;\r\n            this['TRUE'] = true;\r\n            this['FALSE'] = false;\r\n            this['STRING_EMPTY'] = '';\r\n            this['NUMBER_ZERO'] = 0;\r\n            this['NUMBER_ONE'] = 1;\r\n        }\r\n        ;\r\n        /**\r\n         * Add more code to the interpreter.\r\n         * @param {string|!Object} code Raw JavaScript text or AST.\r\n         */\r\n        Interpreter.prototype.appendCode = function (code) {\r\n            var state = this.stateStack[0];\r\n            if (!state || state.node['type'] !== 'Program') {\r\n                throw Error('Expecting original AST to start with a Program node.');\r\n            }\r\n            if (typeof code === 'string') {\r\n                code = Interpreter.acorn.parse(code, Interpreter.PARSE_OPTIONS);\r\n            }\r\n            if (!code || code['type'] !== 'Program') {\r\n                throw Error('Expecting new AST to start with a Program node.');\r\n            }\r\n            this.populateScope_(code, state.scope);\r\n            // Append the new program to the old one.\r\n            for (var i = 0, node; (node = code['body'][i]); i++) {\r\n                state.node['body'].push(node);\r\n            }\r\n            state.done = false;\r\n        };\r\n        ;\r\n        /**\r\n         * Execute one step of the interpreter.\r\n         * @return {boolean} True if a step was executed, false if no more instructions.\r\n         */\r\n        Interpreter.prototype.step = function () {\r\n            var stack = this.stateStack;\r\n            var state = stack[stack.length - 1];\r\n            if (!state) {\r\n                return false;\r\n            }\r\n            var node = state.node, type = node['type'];\r\n            if (type === 'Program' && state.done) {\r\n                return false;\r\n            }\r\n            else if (this.paused_) {\r\n                return true;\r\n            }\r\n            try {\r\n                var nextState = this.stepFunctions_[type](stack, state, node);\r\n            }\r\n            catch (e) {\r\n                // Eat any step errors.  They have been thrown on the stack.\r\n                if (e !== Interpreter.STEP_ERROR) {\r\n                    // Uh oh.  This is a real error in the JS-Interpreter.  Rethrow.\r\n                    throw e;\r\n                }\r\n            }\r\n            if (nextState) {\r\n                stack.push(nextState);\r\n            }\r\n            if (!node['end']) {\r\n                // This is polyfill code.  Keep executing until we arrive at user code.\r\n                return this.step();\r\n            }\r\n            return true;\r\n        };\r\n        ;\r\n        /**\r\n         * Execute the interpreter to program completion.  Vulnerable to infinite loops.\r\n         * @return {boolean} True if a execution is asynchronously blocked,\r\n         *     false if no more instructions.\r\n         */\r\n        Interpreter.prototype.run = function () {\r\n            while (!this.paused_ && this.step()) { }\r\n            return this.paused_;\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the global scope with buitin properties and functions.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initGlobalScope = function (scope) {\r\n            // Initialize uneditable global properties.\r\n            this.setProperty(scope, 'NaN', NaN, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'Infinity', Infinity, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'undefined', undefined, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'window', scope, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'this', scope, Interpreter.READONLY_DESCRIPTOR);\r\n            this.setProperty(scope, 'self', scope); // Editable.\r\n            // Create the objects which will become Object.prototype and\r\n            // Function.prototype, which are needed to bootstrap everything else.\r\n            this.OBJECT_PROTO = new Interpreter.MyObject(null);\r\n            this.FUNCTION_PROTO = new Interpreter.MyObject(this.OBJECT_PROTO);\r\n            // Initialize global objects.\r\n            this.initFunction(scope);\r\n            this.initObject(scope);\r\n            // Unable to set scope's parent prior (OBJECT did not exist).\r\n            // Note that in a browser this would be 'Window', whereas in Node.js it would\r\n            // be 'Object'.  This interpreter is closer to Node in that it has no DOM.\r\n            scope.proto = this.OBJECT_PROTO;\r\n            this.setProperty(scope, 'constructor', this.OBJECT);\r\n            this.initArray(scope);\r\n            this.initString(scope);\r\n            this.initBoolean(scope);\r\n            this.initNumber(scope);\r\n            this.initDate(scope);\r\n            this.initRegExp(scope);\r\n            this.initError(scope);\r\n            this.initMath(scope);\r\n            this.initJSON(scope);\r\n            // Initialize global functions.\r\n            var thisInterpreter = this;\r\n            var func = this.createNativeFunction(function (x) { throw EvalError(\"Can't happen\"); }, false);\r\n            func.eval = true;\r\n            this.setProperty(scope, 'eval', func);\r\n            this.setProperty(scope, 'parseInt', this.createNativeFunction(parseInt, false));\r\n            this.setProperty(scope, 'parseFloat', this.createNativeFunction(parseFloat, false));\r\n            this.setProperty(scope, 'isNaN', this.createNativeFunction(isNaN, false));\r\n            this.setProperty(scope, 'isFinite', this.createNativeFunction(isFinite, false));\r\n            var strFunctions = [\r\n                [escape, 'escape'], [unescape, 'unescape'],\r\n                [decodeURI, 'decodeURI'], [decodeURIComponent, 'decodeURIComponent'],\r\n                [encodeURI, 'encodeURI'], [encodeURIComponent, 'encodeURIComponent']\r\n            ];\r\n            for (var i = 0; i < strFunctions.length; i++) {\r\n                var wrapper = (function (nativeFunc) {\r\n                    return function (str) {\r\n                        try {\r\n                            return nativeFunc(str);\r\n                        }\r\n                        catch (e) {\r\n                            // decodeURI('%xy') will throw an error.  Catch and rethrow.\r\n                            thisInterpreter.throwException(thisInterpreter.URI_ERROR, e.message);\r\n                        }\r\n                    };\r\n                })(strFunctions[i][0]);\r\n                this.setProperty(scope, strFunctions[i][1], this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            // Run any user-provided initialization.\r\n            if (this.initFunc_) {\r\n                this.initFunc_(this, scope);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Function class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initFunction = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            var identifierRegexp = /^[A-Za-z_$][\\w$]*$/;\r\n            // Function constructor.\r\n            wrapper = function (var_args) {\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Function().\r\n                    var newFunc = this;\r\n                }\r\n                else {\r\n                    // Called as Function().\r\n                    var newFunc = thisInterpreter.createObjectProto(thisInterpreter.FUNCTION_PROTO);\r\n                }\r\n                if (arguments.length) {\r\n                    var code = String(arguments[arguments.length - 1]);\r\n                }\r\n                else {\r\n                    var code = '';\r\n                }\r\n                var args = [];\r\n                for (var i = 0; i < arguments.length - 1; i++) {\r\n                    var name = String(arguments[i]);\r\n                    if (!name.match(identifierRegexp)) {\r\n                        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid function argument: ' + name);\r\n                    }\r\n                    args.push(name);\r\n                }\r\n                args = args.join(', ');\r\n                // Interestingly, the scope for constructed functions is the global scope,\r\n                // even if they were constructed in some other scope.\r\n                newFunc.parentScope = thisInterpreter.global;\r\n                // Acorn needs to parse code in the context of a function or else 'return'\r\n                // statements will be syntax errors.\r\n                try {\r\n                    var ast = Interpreter.acorn.parse('$ = function(' + args + ') {' + code + '};', Interpreter.PARSE_OPTIONS);\r\n                }\r\n                catch (e) {\r\n                    // Acorn threw a SyntaxError.  Rethrow as a trappable error.\r\n                    thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid code: ' + e.message);\r\n                }\r\n                if (ast['body'].length !== 1) {\r\n                    // Function('a', 'return a + 6;}; {alert(1);');\r\n                    thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid code in function body.');\r\n                }\r\n                newFunc.node = ast['body'][0]['expression']['right'];\r\n                thisInterpreter.setProperty(newFunc, 'length', newFunc.node['length'], Interpreter.READONLY_DESCRIPTOR);\r\n                return newFunc;\r\n            };\r\n            wrapper.id = this.functionCounter_++;\r\n            this.FUNCTION = this.createObjectProto(this.FUNCTION_PROTO);\r\n            this.setProperty(scope, 'Function', this.FUNCTION);\r\n            // Manually setup type and prototype because createObj doesn't recognize\r\n            // this object as a function (this.FUNCTION did not exist).\r\n            this.setProperty(this.FUNCTION, 'prototype', this.FUNCTION_PROTO);\r\n            this.FUNCTION.nativeFunc = wrapper;\r\n            // Configure Function.prototype.\r\n            this.setProperty(this.FUNCTION_PROTO, 'constructor', this.FUNCTION, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.FUNCTION_PROTO.nativeFunc = function () { };\r\n            this.FUNCTION_PROTO.nativeFunc.id = this.functionCounter_++;\r\n            this.setProperty(this.FUNCTION_PROTO, 'length', 0, Interpreter.READONLY_DESCRIPTOR);\r\n            var boxThis = function (value) {\r\n                // In non-strict mode 'this' must be an object.\r\n                if ((!value || !value.isObject) && !thisInterpreter.getScope().strict) {\r\n                    if (value === undefined || value === null) {\r\n                        // 'Undefined' and 'null' are changed to global object.\r\n                        value = thisInterpreter.global;\r\n                    }\r\n                    else {\r\n                        // Primitives must be boxed in non-strict mode.\r\n                        var box = thisInterpreter.createObjectProto(thisInterpreter.getPrototype(value));\r\n                        box.data = value;\r\n                        value = box;\r\n                    }\r\n                }\r\n                return value;\r\n            };\r\n            wrapper = function (thisArg, args) {\r\n                var state = thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\r\n                // Rewrite the current 'CallExpression' to apply a different function.\r\n                state.func_ = this;\r\n                // Assign the 'this' object.\r\n                state.funcThis_ = boxThis(thisArg);\r\n                // Bind any provided arguments.\r\n                state.arguments_ = [];\r\n                if (args !== null && args !== undefined) {\r\n                    if (args.isObject) {\r\n                        state.arguments_ = thisInterpreter.pseudoToNative(args);\r\n                    }\r\n                    else {\r\n                        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'CreateListFromArrayLike called on non-object');\r\n                    }\r\n                }\r\n                state.doneExec_ = false;\r\n            };\r\n            this.setNativeFunctionPrototype(this.FUNCTION, 'apply', wrapper);\r\n            wrapper = function (thisArg, var_args) {\r\n                var state = thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\r\n                // Rewrite the current 'CallExpression' to call a different function.\r\n                state.func_ = this;\r\n                // Assign the 'this' object.\r\n                state.funcThis_ = boxThis(thisArg);\r\n                // Bind any provided arguments.\r\n                state.arguments_ = [];\r\n                for (var i = 1; i < arguments.length; i++) {\r\n                    state.arguments_.push(arguments[i]);\r\n                }\r\n                state.doneExec_ = false;\r\n            };\r\n            this.setNativeFunctionPrototype(this.FUNCTION, 'call', wrapper);\r\n            this.polyfills_.push(\r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\r\n            \"Object.defineProperty(Function.prototype, 'bind',\", \"{configurable: true, writable: true, value:\", \"function(oThis) {\", \"if (typeof this !== 'function') {\", \"throw TypeError('What is trying to be bound is not callable');\", \"}\", \"var aArgs   = Array.prototype.slice.call(arguments, 1),\", \"fToBind = this,\", \"fNOP    = function() {},\", \"fBound  = function() {\", \"return fToBind.apply(this instanceof fNOP\", \"? this\", \": oThis,\", \"aArgs.concat(Array.prototype.slice.call(arguments)));\", \"};\", \"if (this.prototype) {\", \"fNOP.prototype = this.prototype;\", \"}\", \"fBound.prototype = new fNOP();\", \"return fBound;\", \"}\", \"});\", \"\");\r\n            // Function has no parent to inherit from, so it needs its own mandatory\r\n            // toString and valueOf functions.\r\n            wrapper = function () {\r\n                return this.toString();\r\n            };\r\n            this.setNativeFunctionPrototype(this.FUNCTION, 'toString', wrapper);\r\n            this.setProperty(this.FUNCTION, 'toString', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function () {\r\n                return this.valueOf();\r\n            };\r\n            this.setNativeFunctionPrototype(this.FUNCTION, 'valueOf', wrapper);\r\n            this.setProperty(this.FUNCTION, 'valueOf', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Object class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initObject = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // Object constructor.\r\n            wrapper = function (value) {\r\n                if (value === undefined || value === null) {\r\n                    // Create a new object.\r\n                    if (thisInterpreter.calledWithNew()) {\r\n                        // Called as new Object().\r\n                        return this;\r\n                    }\r\n                    else {\r\n                        // Called as Object().\r\n                        return thisInterpreter.createObjectProto(thisInterpreter.OBJECT_PROTO);\r\n                    }\r\n                }\r\n                if (!value.isObject) {\r\n                    // Wrap the value as an object.\r\n                    var box = thisInterpreter.createObjectProto(thisInterpreter.getPrototype(value));\r\n                    box.data = value;\r\n                    return box;\r\n                }\r\n                // Return the provided object.\r\n                return value;\r\n            };\r\n            this.OBJECT = this.createNativeFunction(wrapper, true);\r\n            // Throw away the created prototype and use the root prototype.\r\n            this.setProperty(this.OBJECT, 'prototype', this.OBJECT_PROTO);\r\n            this.setProperty(this.OBJECT_PROTO, 'constructor', this.OBJECT);\r\n            this.setProperty(scope, 'Object', this.OBJECT);\r\n            /**\r\n             * Checks if the provided value is null or undefined.\r\n             * If so, then throw an error in the call stack.\r\n             * @param {Interpreter.MyValue} value Value to check.\r\n             */\r\n            var throwIfNullUndefined = function (value) {\r\n                if (value === undefined || value === null) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, \"Cannot convert '\" + value + \"' to object\");\r\n                }\r\n            };\r\n            // Static methods on Object.\r\n            wrapper = function (obj) {\r\n                throwIfNullUndefined(obj);\r\n                var props = obj.isObject ? obj.properties : obj;\r\n                return thisInterpreter.nativeToPseudo(Object.getOwnPropertyNames(props));\r\n            };\r\n            this.setProperty(this.OBJECT, 'getOwnPropertyNames', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (obj) {\r\n                throwIfNullUndefined(obj);\r\n                if (!obj.isObject) {\r\n                    return thisInterpreter.nativeToPseudo(Object.keys(obj));\r\n                }\r\n                return thisInterpreter.nativeToPseudo(Object.keys(obj.properties));\r\n            };\r\n            this.setProperty(this.OBJECT, 'keys', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (proto) {\r\n                // Support for the second argument is the responsibility of a polyfill.\r\n                if (proto === null) {\r\n                    return thisInterpreter.createObjectProto(null);\r\n                }\r\n                if (proto === undefined || !proto.isObject) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Object prototype may only be an Object or null');\r\n                }\r\n                return thisInterpreter.createObjectProto(proto);\r\n            };\r\n            this.setProperty(this.OBJECT, 'create', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Add a polyfill to handle create's second argument.\r\n            this.polyfills_.push(\"(function() {\", \"var create_ = Object.create;\", \"Object.create = function(proto, props) {\", \"var obj = create_(proto);\", \"props && Object.defineProperties(obj, props);\", \"return obj;\", \"};\", \"})();\", \"\");\r\n            wrapper = function (obj, prop, descriptor) {\r\n                prop = String(prop);\r\n                if (!obj || !obj.isObject) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Object.defineProperty called on non-object');\r\n                }\r\n                if (!descriptor || !descriptor.isObject) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Property description must be an object');\r\n                }\r\n                if (!obj.properties[prop] && obj.preventExtensions) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, \"Can't define property '\" + prop + \"', object is not extensible\");\r\n                }\r\n                // The polyfill guarantees no inheritance and no getter functions.\r\n                // Therefore the descriptor properties map is the native object needed.\r\n                thisInterpreter.setProperty(obj, prop, ReferenceError, descriptor.properties);\r\n                return obj;\r\n            };\r\n            this.setProperty(this.OBJECT, 'defineProperty', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.polyfills_.push(\r\n            // Flatten the descriptor to remove any inheritance or getter functions.\r\n            \"(function() {\", \"var defineProperty_ = Object.defineProperty;\", \"Object.defineProperty = function(obj, prop, d1) {\", \"var d2 = {};\", \"if ('configurable' in d1) d2.configurable = d1.configurable;\", \"if ('enumerable' in d1) d2.enumerable = d1.enumerable;\", \"if ('writable' in d1) d2.writable = d1.writable;\", \"if ('value' in d1) d2.value = d1.value;\", \"if ('get' in d1) d2.get = d1.get;\", \"if ('set' in d1) d2.set = d1.set;\", \"return defineProperty_(obj, prop, d2);\", \"};\", \"})();\", \"Object.defineProperty(Object, 'defineProperties',\", \"{configurable: true, writable: true, value:\", \"function(obj, props) {\", \"var keys = Object.keys(props);\", \"for (var i = 0; i < keys.length; i++) {\", \"Object.defineProperty(obj, keys[i], props[keys[i]]);\", \"}\", \"return obj;\", \"}\", \"});\", \"\");\r\n            wrapper = function (obj, prop) {\r\n                if (!obj || !obj.isObject) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Object.getOwnPropertyDescriptor called on non-object');\r\n                }\r\n                prop = String(prop);\r\n                if (!(prop in obj.properties)) {\r\n                    return undefined;\r\n                }\r\n                var descriptor = Object.getOwnPropertyDescriptor(obj.properties, prop);\r\n                var getter = obj.getter[prop];\r\n                var setter = obj.setter[prop];\r\n                if (getter || setter) {\r\n                    descriptor.get = getter;\r\n                    descriptor.set = setter;\r\n                    delete descriptor.value;\r\n                    delete descriptor.writable;\r\n                }\r\n                var pseudoDescriptor = thisInterpreter.nativeToPseudo(descriptor);\r\n                if ('value' in descriptor) {\r\n                    thisInterpreter.setProperty(pseudoDescriptor, 'value', descriptor.value);\r\n                }\r\n                return pseudoDescriptor;\r\n            };\r\n            this.setProperty(this.OBJECT, 'getOwnPropertyDescriptor', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (obj) {\r\n                throwIfNullUndefined(obj);\r\n                return thisInterpreter.getPrototype(obj);\r\n            };\r\n            this.setProperty(this.OBJECT, 'getPrototypeOf', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (obj) {\r\n                return Boolean(obj) && !obj.preventExtensions;\r\n            };\r\n            this.setProperty(this.OBJECT, 'isExtensible', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (obj) {\r\n                if (obj && obj.isObject) {\r\n                    obj.preventExtensions = true;\r\n                }\r\n                return obj;\r\n            };\r\n            this.setProperty(this.OBJECT, 'preventExtensions', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Instance methods on Object.\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'toString', Interpreter.MyObject.prototype.toString);\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'toLocaleString', Interpreter.MyObject.prototype.toString);\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'valueOf', Interpreter.MyObject.prototype.valueOf);\r\n            wrapper = function (prop) {\r\n                throwIfNullUndefined(this);\r\n                if (!this.isObject) {\r\n                    return this.hasOwnProperty(prop);\r\n                }\r\n                return String(prop) in this.properties;\r\n            };\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'hasOwnProperty', wrapper);\r\n            wrapper = function (prop) {\r\n                throwIfNullUndefined(this);\r\n                return Object.prototype.propertyIsEnumerable.call(this.properties, prop);\r\n            };\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'propertyIsEnumerable', wrapper);\r\n            wrapper = function (obj) {\r\n                while (true) {\r\n                    // Note, circular loops shouldn't be possible.\r\n                    obj = thisInterpreter.getPrototype(obj);\r\n                    if (!obj) {\r\n                        // No parent; reached the top.\r\n                        return false;\r\n                    }\r\n                    if (obj === this) {\r\n                        return true;\r\n                    }\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.OBJECT, 'isPrototypeOf', wrapper);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Array class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initArray = function (scope) {\r\n            var thisInterpreter = this;\r\n            var getInt = function (obj, def) {\r\n                // Return an integer, or the default.\r\n                var n = obj ? Math.floor(obj) : def;\r\n                if (isNaN(n)) {\r\n                    n = def;\r\n                }\r\n                return n;\r\n            };\r\n            var wrapper;\r\n            // Array constructor.\r\n            wrapper = function (var_args) {\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Array().\r\n                    var newArray = this;\r\n                }\r\n                else {\r\n                    // Called as Array().\r\n                    var newArray = thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\r\n                }\r\n                var first = arguments[0];\r\n                if (arguments.length === 1 && typeof first === 'number') {\r\n                    if (isNaN(Interpreter.legalArrayLength(first))) {\r\n                        thisInterpreter.throwException(thisInterpreter.RANGE_ERROR, 'Invalid array length');\r\n                    }\r\n                    newArray.properties.length = first;\r\n                }\r\n                else {\r\n                    for (var i = 0; i < arguments.length; i++) {\r\n                        newArray.properties[i] = arguments[i];\r\n                    }\r\n                    newArray.properties.length = i;\r\n                }\r\n                return newArray;\r\n            };\r\n            this.ARRAY = this.createNativeFunction(wrapper, true);\r\n            this.ARRAY_PROTO = this.ARRAY.properties['prototype'];\r\n            this.setProperty(scope, 'Array', this.ARRAY);\r\n            // Static methods on Array.\r\n            wrapper = function (obj) {\r\n                return obj && obj.class === 'Array';\r\n            };\r\n            this.setProperty(this.ARRAY, 'isArray', this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Instance methods on Array.\r\n            wrapper = function () {\r\n                return Array.prototype.pop.call(this.properties);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'pop', wrapper);\r\n            wrapper = function (var_args) {\r\n                return Array.prototype.push.apply(this.properties, arguments);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'push', wrapper);\r\n            wrapper = function () {\r\n                return Array.prototype.shift.call(this.properties);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'shift', wrapper);\r\n            wrapper = function (var_args) {\r\n                return Array.prototype.unshift.apply(this.properties, arguments);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'unshift', wrapper);\r\n            wrapper = function () {\r\n                Array.prototype.reverse.call(this.properties);\r\n                return this;\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'reverse', wrapper);\r\n            wrapper = function (index, howmany /*, var_args*/) {\r\n                var list = Array.prototype.splice.apply(this.properties, arguments);\r\n                return thisInterpreter.nativeToPseudo(list);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'splice', wrapper);\r\n            wrapper = function (opt_begin, opt_end) {\r\n                var list = Array.prototype.slice.call(this.properties, opt_begin, opt_end);\r\n                return thisInterpreter.nativeToPseudo(list);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'slice', wrapper);\r\n            wrapper = function (opt_separator) {\r\n                return Array.prototype.join.call(this.properties, opt_separator);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'join', wrapper);\r\n            wrapper = function (var_args) {\r\n                var list = [];\r\n                var length = 0;\r\n                // Start by copying the current array.\r\n                var iLength = thisInterpreter.getProperty(this, 'length');\r\n                for (var i = 0; i < iLength; i++) {\r\n                    if (thisInterpreter.hasProperty(this, i)) {\r\n                        var element = thisInterpreter.getProperty(this, i);\r\n                        list[length] = element;\r\n                    }\r\n                    length++;\r\n                }\r\n                // Loop through all arguments and copy them in.\r\n                for (var i = 0; i < arguments.length; i++) {\r\n                    var value = arguments[i];\r\n                    if (thisInterpreter.isa(value, thisInterpreter.ARRAY)) {\r\n                        var jLength = thisInterpreter.getProperty(value, 'length');\r\n                        for (var j = 0; j < jLength; j++) {\r\n                            if (thisInterpreter.hasProperty(value, j)) {\r\n                                list[length] = thisInterpreter.getProperty(value, j);\r\n                            }\r\n                            length++;\r\n                        }\r\n                    }\r\n                    else {\r\n                        list[length] = value;\r\n                    }\r\n                }\r\n                return thisInterpreter.nativeToPseudo(list);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'concat', wrapper);\r\n            wrapper = function (searchElement, opt_fromIndex) {\r\n                return Array.prototype.indexOf.apply(this.properties, arguments);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'indexOf', wrapper);\r\n            wrapper = function (searchElement, opt_fromIndex) {\r\n                return Array.prototype.lastIndexOf.apply(this.properties, arguments);\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'lastIndexOf', wrapper);\r\n            wrapper = function () {\r\n                Array.prototype.sort.call(this.properties);\r\n                return this;\r\n            };\r\n            this.setNativeFunctionPrototype(this.ARRAY, 'sort', wrapper);\r\n            this.polyfills_.push(\r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/every\r\n            \"Object.defineProperty(Array.prototype, 'every',\", \"{configurable: true, writable: true, value:\", \"function(callbackfn, thisArg) {\", \"if (!this || typeof callbackfn !== 'function') throw TypeError();\", \"var T, k;\", \"var O = Object(this);\", \"var len = O.length >>> 0;\", \"if (arguments.length > 1) T = thisArg;\", \"k = 0;\", \"while (k < len) {\", \"if (k in O && !callbackfn.call(T, O[k], k, O)) return false;\", \"k++;\", \"}\", \"return true;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\r\n            \"Object.defineProperty(Array.prototype, 'filter',\", \"{configurable: true, writable: true, value:\", \"function(fun/*, thisArg*/) {\", \"if (this === void 0 || this === null || typeof fun !== 'function') throw TypeError();\", \"var t = Object(this);\", \"var len = t.length >>> 0;\", \"var res = [];\", \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\", \"for (var i = 0; i < len; i++) {\", \"if (i in t) {\", \"var val = t[i];\", \"if (fun.call(thisArg, val, i, t)) res.push(val);\", \"}\", \"}\", \"return res;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n            \"Object.defineProperty(Array.prototype, 'forEach',\", \"{configurable: true, writable: true, value:\", \"function(callback, thisArg) {\", \"if (!this || typeof callback !== 'function') throw TypeError();\", \"var T, k;\", \"var O = Object(this);\", \"var len = O.length >>> 0;\", \"if (arguments.length > 1) T = thisArg;\", \"k = 0;\", \"while (k < len) {\", \"if (k in O) callback.call(T, O[k], k, O);\", \"k++;\", \"}\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map\r\n            \"Object.defineProperty(Array.prototype, 'map',\", \"{configurable: true, writable: true, value:\", \"function(callback, thisArg) {\", \"if (!this || typeof callback !== 'function') new TypeError;\", \"var T, A, k;\", \"var O = Object(this);\", \"var len = O.length >>> 0;\", \"if (arguments.length > 1) T = thisArg;\", \"A = new Array(len);\", \"k = 0;\", \"while (k < len) {\", \"if (k in O) A[k] = callback.call(T, O[k], k, O);\", \"k++;\", \"}\", \"return A;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\r\n            \"Object.defineProperty(Array.prototype, 'reduce',\", \"{configurable: true, writable: true, value:\", \"function(callback /*, initialValue*/) {\", \"if (!this || typeof callback !== 'function') throw TypeError();\", \"var t = Object(this), len = t.length >>> 0, k = 0, value;\", \"if (arguments.length === 2) {\", \"value = arguments[1];\", \"} else {\", \"while (k < len && !(k in t)) k++;\", \"if (k >= len) {\", \"throw TypeError('Reduce of empty array with no initial value');\", \"}\", \"value = t[k++];\", \"}\", \"for (; k < len; k++) {\", \"if (k in t) value = callback(value, t[k], k, t);\", \"}\", \"return value;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\r\n            \"Object.defineProperty(Array.prototype, 'reduceRight',\", \"{configurable: true, writable: true, value:\", \"function(callback /*, initialValue*/) {\", \"if (null === this || 'undefined' === typeof this || 'function' !== typeof callback) throw TypeError();\", \"var t = Object(this), len = t.length >>> 0, k = len - 1, value;\", \"if (arguments.length >= 2) {\", \"value = arguments[1];\", \"} else {\", \"while (k >= 0 && !(k in t)) k--;\", \"if (k < 0) {\", \"throw TypeError('Reduce of empty array with no initial value');\", \"}\", \"value = t[k--];\", \"}\", \"for (; k >= 0; k--) {\", \"if (k in t) value = callback(value, t[k], k, t);\", \"}\", \"return value;\", \"}\", \"});\", \r\n            // Polyfill copied from:\r\n            // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/some\r\n            \"Object.defineProperty(Array.prototype, 'some',\", \"{configurable: true, writable: true, value:\", \"function(fun/*, thisArg*/) {\", \"if (!this || typeof fun !== 'function') throw TypeError();\", \"var t = Object(this);\", \"var len = t.length >>> 0;\", \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\", \"for (var i = 0; i < len; i++) {\", \"if (i in t && fun.call(thisArg, t[i], i, t)) {\", \"return true;\", \"}\", \"}\", \"return false;\", \"}\", \"});\", \"(function() {\", \"var sort_ = Array.prototype.sort;\", \"Array.prototype.sort = function(opt_comp) {\", \r\n            // Fast native sort.\r\n            \"if (typeof opt_comp !== 'function') {\", \"return sort_.call(this);\", \"}\", \r\n            // Slow bubble sort.\r\n            \"for (var i = 0; i < this.length; i++) {\", \"var changes = 0;\", \"for (var j = 0; j < this.length - i - 1; j++) {\", \"if (opt_comp(this[j], this[j + 1]) > 0) {\", \"var swap = this[j];\", \"this[j] = this[j + 1];\", \"this[j + 1] = swap;\", \"changes++;\", \"}\", \"}\", \"if (!changes) break;\", \"}\", \"return this;\", \"};\", \"})();\", \"Object.defineProperty(Array.prototype, 'toLocaleString',\", \"{configurable: true, writable: true, value:\", \"function() {\", \"var out = [];\", \"for (var i = 0; i < this.length; i++) {\", \"out[i] = (this[i] === null || this[i] === undefined) ? '' : this[i].toLocaleString();\", \"}\", \"return out.join(',');\", \"}\", \"});\", \"\");\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the String class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initString = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // String constructor.\r\n            wrapper = function (value) {\r\n                value = String(value);\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new String().\r\n                    this.data = value;\r\n                    return this;\r\n                }\r\n                else {\r\n                    // Called as String().\r\n                    return value;\r\n                }\r\n            };\r\n            this.STRING = this.createNativeFunction(wrapper, true);\r\n            this.setProperty(scope, 'String', this.STRING);\r\n            // Static methods on String.\r\n            this.setProperty(this.STRING, 'fromCharCode', this.createNativeFunction(String.fromCharCode, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Instance methods on String.\r\n            // Methods with exclusively primitive arguments.\r\n            var functions = ['trim', 'toLowerCase', 'toUpperCase',\r\n                'toLocaleLowerCase', 'toLocaleUpperCase', 'charAt', 'charCodeAt',\r\n                'substring', 'slice', 'substr', 'indexOf', 'lastIndexOf', 'concat'];\r\n            for (var i = 0; i < functions.length; i++) {\r\n                this.setNativeFunctionPrototype(this.STRING, functions[i], String.prototype[functions[i]]);\r\n            }\r\n            wrapper = function (compareString, locales, options) {\r\n                locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\r\n                options = options ? thisInterpreter.pseudoToNative(options) : undefined;\r\n                return String(this).localeCompare(compareString, locales, options);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'localeCompare', wrapper);\r\n            wrapper = function (separator, limit) {\r\n                if (thisInterpreter.isa(separator, thisInterpreter.REGEXP)) {\r\n                    separator = separator.data;\r\n                }\r\n                var jsList = String(this).split(separator, limit);\r\n                return thisInterpreter.nativeToPseudo(jsList);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'split', wrapper);\r\n            wrapper = function (regexp) {\r\n                regexp = regexp ? regexp.data : undefined;\r\n                var match = String(this).match(regexp);\r\n                if (!match) {\r\n                    return null;\r\n                }\r\n                return thisInterpreter.nativeToPseudo(match);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'match', wrapper);\r\n            wrapper = function (regexp) {\r\n                regexp = regexp ? regexp.data : undefined;\r\n                return String(this).search(regexp);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'search', wrapper);\r\n            wrapper = function (substr, newSubstr) {\r\n                // Support for function replacements is the responsibility of a polyfill.\r\n                return String(this).replace(substr.data || substr, newSubstr);\r\n            };\r\n            this.setNativeFunctionPrototype(this.STRING, 'replace', wrapper);\r\n            // Add a polyfill to handle replace's second argument being a function.\r\n            this.polyfills_.push(\"(function() {\", \"var replace_ = String.prototype.replace;\", \"String.prototype.replace = function(substr, newSubstr) {\", \"if (typeof newSubstr !== 'function') {\", \r\n            // string.replace(string|regexp, string)\r\n            \"return replace_.call(this, substr, newSubstr);\", \"}\", \"var str = this;\", \"if (substr instanceof RegExp) {\", // string.replace(regexp, function)\r\n            \"var subs = [];\", \"var m = substr.exec(str);\", \"while (m) {\", \"m.push(m.index, str);\", \"var inject = newSubstr.apply(null, m);\", \"subs.push([m.index, m[0].length, inject]);\", \"m = substr.global ? substr.exec(str) : null;\", \"}\", \"for (var i = subs.length - 1; i >= 0; i--) {\", \"str = str.substring(0, subs[i][0]) + subs[i][2] + \" +\r\n                \"str.substring(subs[i][0] + subs[i][1]);\", \"}\", \"} else {\", // string.replace(string, function)\r\n            \"var i = str.indexOf(substr);\", \"if (i !== -1) {\", \"var inject = newSubstr(str.substr(i, substr.length), i, str);\", \"str = str.substring(0, i) + inject + \" +\r\n                \"str.substring(i + substr.length);\", \"}\", \"}\", \"return str;\", \"};\", \"})();\", \"\");\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Boolean class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initBoolean = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // Boolean constructor.\r\n            wrapper = function (value) {\r\n                value = Boolean(value);\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Boolean().\r\n                    this.data = value;\r\n                    return this;\r\n                }\r\n                else {\r\n                    // Called as Boolean().\r\n                    return value;\r\n                }\r\n            };\r\n            this.BOOLEAN = this.createNativeFunction(wrapper, true);\r\n            this.setProperty(scope, 'Boolean', this.BOOLEAN);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Number class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initNumber = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // Number constructor.\r\n            wrapper = function (value) {\r\n                value = Number(value);\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Number().\r\n                    this.data = value;\r\n                    return this;\r\n                }\r\n                else {\r\n                    // Called as Number().\r\n                    return value;\r\n                }\r\n            };\r\n            this.NUMBER = this.createNativeFunction(wrapper, true);\r\n            this.setProperty(scope, 'Number', this.NUMBER);\r\n            var numConsts = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY',\r\n                'POSITIVE_INFINITY'];\r\n            for (var i = 0; i < numConsts.length; i++) {\r\n                this.setProperty(this.NUMBER, numConsts[i], Number[numConsts[i]], Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            // Instance methods on Number.\r\n            wrapper = function (fractionDigits) {\r\n                try {\r\n                    return Number(this).toExponential(fractionDigits);\r\n                }\r\n                catch (e) {\r\n                    // Throws if fractionDigits isn't within 0-20.\r\n                    thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toExponential', wrapper);\r\n            wrapper = function (digits) {\r\n                try {\r\n                    return Number(this).toFixed(digits);\r\n                }\r\n                catch (e) {\r\n                    // Throws if digits isn't within 0-20.\r\n                    thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toFixed', wrapper);\r\n            wrapper = function (precision) {\r\n                try {\r\n                    return Number(this).toPrecision(precision);\r\n                }\r\n                catch (e) {\r\n                    // Throws if precision isn't within range (depends on implementation).\r\n                    thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toPrecision', wrapper);\r\n            wrapper = function (radix) {\r\n                try {\r\n                    return Number(this).toString(radix);\r\n                }\r\n                catch (e) {\r\n                    // Throws if radix isn't within 2-36.\r\n                    thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n                }\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toString', wrapper);\r\n            wrapper = function (locales, options) {\r\n                locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\r\n                options = options ? thisInterpreter.pseudoToNative(options) : undefined;\r\n                return Number(this).toLocaleString(locales, options);\r\n            };\r\n            this.setNativeFunctionPrototype(this.NUMBER, 'toLocaleString', wrapper);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Date class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initDate = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // Date constructor.\r\n            wrapper = function (value, var_args) {\r\n                if (!thisInterpreter.calledWithNew()) {\r\n                    // Called as Date().\r\n                    // Calling Date() as a function returns a string, no arguments are heeded.\r\n                    return Date();\r\n                }\r\n                // Called as new Date().\r\n                var args = [null].concat([].slice.call(arguments));\r\n                this.data = new (Function.prototype.bind.apply(Date, args));\r\n                return this;\r\n            };\r\n            this.DATE = this.createNativeFunction(wrapper, true);\r\n            this.setProperty(scope, 'Date', this.DATE);\r\n            // Static methods on Date.\r\n            this.setProperty(this.DATE, 'now', this.createNativeFunction(Date.now, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.DATE, 'parse', this.createNativeFunction(Date.parse, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.DATE, 'UTC', this.createNativeFunction(Date.UTC, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            // Instance methods on Date.\r\n            var functions = ['getDate', 'getDay', 'getFullYear', 'getHours',\r\n                'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTime',\r\n                'getTimezoneOffset', 'getUTCDate', 'getUTCDay', 'getUTCFullYear',\r\n                'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth',\r\n                'getUTCSeconds', 'getYear',\r\n                'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\r\n                'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate',\r\n                'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes',\r\n                'setUTCMonth', 'setUTCSeconds', 'setYear',\r\n                'toDateString', 'toISOString', 'toJSON', 'toGMTString',\r\n                'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString',\r\n                'toTimeString', 'toUTCString'];\r\n            for (var i = 0; i < functions.length; i++) {\r\n                wrapper = (function (nativeFunc) {\r\n                    return function (var_args) {\r\n                        var args = [];\r\n                        for (var i = 0; i < arguments.length; i++) {\r\n                            args[i] = thisInterpreter.pseudoToNative(arguments[i]);\r\n                        }\r\n                        return this.data[nativeFunc].apply(this.data, args);\r\n                    };\r\n                })(functions[i]);\r\n                this.setNativeFunctionPrototype(this.DATE, functions[i], wrapper);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize Regular Expression object.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initRegExp = function (scope) {\r\n            var thisInterpreter = this;\r\n            var wrapper;\r\n            // RegExp constructor.\r\n            wrapper = function (pattern, flags) {\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new RegExp().\r\n                    var rgx = this;\r\n                }\r\n                else {\r\n                    // Called as RegExp().\r\n                    var rgx = thisInterpreter.createObjectProto(thisInterpreter.REGEXP_PROTO);\r\n                }\r\n                pattern = pattern ? pattern.toString() : '';\r\n                flags = flags ? flags.toString() : '';\r\n                thisInterpreter.populateRegExp(rgx, new RegExp(pattern, flags));\r\n                return rgx;\r\n            };\r\n            this.REGEXP = this.createNativeFunction(wrapper, true);\r\n            this.REGEXP_PROTO = this.REGEXP.properties['prototype'];\r\n            this.setProperty(scope, 'RegExp', this.REGEXP);\r\n            this.setProperty(this.REGEXP.properties['prototype'], 'global', undefined, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.REGEXP.properties['prototype'], 'ignoreCase', undefined, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.REGEXP.properties['prototype'], 'multiline', undefined, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.REGEXP.properties['prototype'], 'source', '(?:)', Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            wrapper = function (str) {\r\n                return this.data.test(str);\r\n            };\r\n            this.setNativeFunctionPrototype(this.REGEXP, 'test', wrapper);\r\n            wrapper = function (str) {\r\n                str = str.toString();\r\n                // Get lastIndex from wrapped regex, since this is settable.\r\n                this.data.lastIndex =\r\n                    Number(thisInterpreter.getProperty(this, 'lastIndex'));\r\n                var match = this.data.exec(str);\r\n                thisInterpreter.setProperty(this, 'lastIndex', this.data.lastIndex);\r\n                if (match) {\r\n                    var result = thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\r\n                    for (var i = 0; i < match.length; i++) {\r\n                        thisInterpreter.setProperty(result, i, match[i]);\r\n                    }\r\n                    // match has additional properties.\r\n                    thisInterpreter.setProperty(result, 'index', match.index);\r\n                    thisInterpreter.setProperty(result, 'input', match.input);\r\n                    return result;\r\n                }\r\n                return null;\r\n            };\r\n            this.setNativeFunctionPrototype(this.REGEXP, 'exec', wrapper);\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize the Error class.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initError = function (scope) {\r\n            var thisInterpreter = this;\r\n            // Error constructor.\r\n            this.ERROR = this.createNativeFunction(function (opt_message) {\r\n                if (thisInterpreter.calledWithNew()) {\r\n                    // Called as new Error().\r\n                    var newError = this;\r\n                }\r\n                else {\r\n                    // Called as Error().\r\n                    var newError = thisInterpreter.createObject(thisInterpreter.ERROR);\r\n                }\r\n                if (opt_message) {\r\n                    thisInterpreter.setProperty(newError, 'message', String(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n                }\r\n                return newError;\r\n            }, true);\r\n            this.setProperty(scope, 'Error', this.ERROR);\r\n            this.setProperty(this.ERROR.properties['prototype'], 'message', '', Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(this.ERROR.properties['prototype'], 'name', 'Error', Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            var createErrorSubclass = function (name) {\r\n                var constructor = thisInterpreter.createNativeFunction(function (opt_message) {\r\n                    if (thisInterpreter.calledWithNew()) {\r\n                        // Called as new XyzError().\r\n                        var newError = this;\r\n                    }\r\n                    else {\r\n                        // Called as XyzError().\r\n                        var newError = thisInterpreter.createObject(constructor);\r\n                    }\r\n                    if (opt_message) {\r\n                        thisInterpreter.setProperty(newError, 'message', String(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n                    }\r\n                    return newError;\r\n                }, true);\r\n                thisInterpreter.setProperty(constructor, 'prototype', thisInterpreter.createObject(thisInterpreter.ERROR));\r\n                thisInterpreter.setProperty(constructor.properties['prototype'], 'name', name, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n                thisInterpreter.setProperty(scope, name, constructor);\r\n                return constructor;\r\n            };\r\n            this.EVAL_ERROR = createErrorSubclass('EvalError');\r\n            this.RANGE_ERROR = createErrorSubclass('RangeError');\r\n            this.REFERENCE_ERROR = createErrorSubclass('ReferenceError');\r\n            this.SYNTAX_ERROR = createErrorSubclass('SyntaxError');\r\n            this.TYPE_ERROR = createErrorSubclass('TypeError');\r\n            this.URI_ERROR = createErrorSubclass('URIError');\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize Math object.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initMath = function (scope) {\r\n            var thisInterpreter = this;\r\n            var myMath = this.createObjectProto(this.OBJECT_PROTO);\r\n            this.setProperty(scope, 'Math', myMath);\r\n            var mathConsts = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI',\r\n                'SQRT1_2', 'SQRT2'];\r\n            for (var i = 0; i < mathConsts.length; i++) {\r\n                this.setProperty(myMath, mathConsts[i], Math[mathConsts[i]], Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            var numFunctions = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos',\r\n                'exp', 'floor', 'log', 'max', 'min', 'pow', 'random',\r\n                'round', 'sin', 'sqrt', 'tan'];\r\n            for (var i = 0; i < numFunctions.length; i++) {\r\n                this.setProperty(myMath, numFunctions[i], this.createNativeFunction(Math[numFunctions[i]], false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize JSON object.\r\n         * @param {!Interpreter.MyObject} scope Global scope.\r\n         */\r\n        Interpreter.prototype.initJSON = function (scope) {\r\n            var thisInterpreter = this;\r\n            var myJSON = thisInterpreter.createObjectProto(this.OBJECT_PROTO);\r\n            this.setProperty(scope, 'JSON', myJSON);\r\n            var wrapper = function (text) {\r\n                try {\r\n                    var nativeObj = JSON.parse(text.toString());\r\n                }\r\n                catch (e) {\r\n                    thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, e.message);\r\n                }\r\n                return thisInterpreter.nativeToPseudo(nativeObj);\r\n            };\r\n            this.setProperty(myJSON, 'parse', this.createNativeFunction(wrapper, false));\r\n            wrapper = function (value) {\r\n                var nativeObj = thisInterpreter.pseudoToNative(value);\r\n                try {\r\n                    var str = JSON.stringify(nativeObj);\r\n                }\r\n                catch (e) {\r\n                    thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, e.message);\r\n                }\r\n                return str;\r\n            };\r\n            this.setProperty(myJSON, 'stringify', this.createNativeFunction(wrapper, false));\r\n        };\r\n        ;\r\n        /**\r\n         * Is an object of a certain class?\r\n         * @param {Interpreter.MyValue} child Object to check.\r\n         * @param {Interpreter.MyObject} constructor Constructor of object.\r\n         * @return {boolean} True if object is the class or inherits from it.\r\n         *     False otherwise.\r\n         */\r\n        Interpreter.prototype.isa = function (child, constructor) {\r\n            if (child === null || child === undefined || !constructor) {\r\n                return false;\r\n            }\r\n            var proto = constructor.properties['prototype'];\r\n            if (child === proto) {\r\n                return true;\r\n            }\r\n            // The first step up the prototype chain is harder since the child might be\r\n            // a primitive value.  Subsequent steps can just follow the .proto property.\r\n            var childObj = this.getPrototype(child);\r\n            while (childObj) {\r\n                if (childObj === proto) {\r\n                    return true;\r\n                }\r\n                childObj = childObj.proto;\r\n            }\r\n            return false;\r\n        };\r\n        ;\r\n        /**\r\n         * Is a value a legal integer for an array length?\r\n         * @param {Interpreter.MyValue} x Value to check.\r\n         * @return {number} Zero, or a positive integer if the value can be\r\n         *     converted to such.  NaN otherwise.\r\n         */\r\n        Interpreter.legalArrayLength = function (x) {\r\n            var n = x >>> 0;\r\n            // Array length must be between 0 and 2^32-1 (inclusive).\r\n            return (n === Number(x)) ? n : NaN;\r\n        };\r\n        ;\r\n        /**\r\n         * Is a value a legal integer for an array index?\r\n         * @param {Interpreter.MyValue} x Value to check.\r\n         * @return {number} Zero, or a positive integer if the value can be\r\n         *     converted to such.  NaN otherwise.\r\n         */\r\n        Interpreter.legalArrayIndex = function (x) {\r\n            var n = x >>> 0;\r\n            // Array index cannot be 2^32-1, otherwise length would be 2^32.\r\n            // 0xffffffff is 2^32-1.\r\n            return (String(n) === String(x) && n !== 0xffffffff) ? n : NaN;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new data object based on a constructor's prototype.\r\n         * @param {Interpreter.MyObject} constructor Parent constructor function,\r\n         *     or null if scope object.\r\n         * @return {!Interpreter.MyObject} New data object.\r\n         */\r\n        Interpreter.prototype.createObject = function (constructor) {\r\n            return this.createObjectProto(constructor &&\r\n                constructor.properties['prototype']);\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new data object based on a prototype.\r\n         * @param {Interpreter.MyObject} proto Prototype object.\r\n         * @return {!Interpreter.MyObject} New data object.\r\n         */\r\n        Interpreter.prototype.createObjectProto = function (proto) {\r\n            var obj = new Interpreter.MyObject(proto);\r\n            // Functions have prototype objects.\r\n            if (this.isa(obj, this.FUNCTION)) {\r\n                this.setProperty(obj, 'prototype', this.createObjectProto(this.OBJECT_PROTO || null));\r\n                obj.class = 'Function';\r\n            }\r\n            // Arrays have length.\r\n            if (this.isa(obj, this.ARRAY)) {\r\n                this.setProperty(obj, 'length', 0, { configurable: false, enumerable: false, writable: true });\r\n                obj.class = 'Array';\r\n            }\r\n            if (this.isa(obj, this.ERROR)) {\r\n                obj.class = 'Error';\r\n            }\r\n            return obj;\r\n        };\r\n        ;\r\n        /**\r\n         * Initialize a pseudo regular expression object based on a native regular\r\n         * expression object.\r\n         * @param {!Interpreter.MyObject} pseudoRegexp The existing object to set.\r\n         * @param {!RegExp} nativeRegexp The native regular expression.\r\n         */\r\n        Interpreter.prototype.populateRegExp = function (pseudoRegexp, nativeRegexp) {\r\n            pseudoRegexp.data = nativeRegexp;\r\n            // lastIndex is settable, all others are read-only attributes\r\n            this.setProperty(pseudoRegexp, 'lastIndex', nativeRegexp.lastIndex, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(pseudoRegexp, 'source', nativeRegexp.source, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(pseudoRegexp, 'global', nativeRegexp.global, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(pseudoRegexp, 'ignoreCase', nativeRegexp.ignoreCase, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n            this.setProperty(pseudoRegexp, 'multiline', nativeRegexp.multiline, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new function.\r\n         * @param {!Object} node AST node defining the function.\r\n         * @param {!Object} scope Parent scope.\r\n         * @return {!Interpreter.MyObject} New function.\r\n         */\r\n        Interpreter.prototype.createFunction = function (node, scope) {\r\n            var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n            func.parentScope = scope;\r\n            func.node = node;\r\n            this.setProperty(func, 'length', func.node['params'].length, Interpreter.READONLY_DESCRIPTOR);\r\n            return func;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new native function.\r\n         * @param {!Function} nativeFunc JavaScript function.\r\n         * @param {boolean=} opt_constructor If true, the function's\r\n         * prototype will have its constructor property set to the function.\r\n         * If false, the function cannot be called as a constructor (e.g. escape).\r\n         * Defaults to undefined.\r\n         * @return {!Interpreter.MyObject} New function.\r\n         */\r\n        Interpreter.prototype.createNativeFunction = function (nativeFunc, opt_constructor) {\r\n            var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n            func.nativeFunc = nativeFunc;\r\n            nativeFunc.id = this.functionCounter_++;\r\n            this.setProperty(func, 'length', nativeFunc.length, Interpreter.READONLY_DESCRIPTOR);\r\n            if (opt_constructor) {\r\n                this.setProperty(func.properties['prototype'], 'constructor', func, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            else if (opt_constructor === false) {\r\n                func.illegalConstructor = true;\r\n                this.setProperty(func, 'prototype', undefined);\r\n            }\r\n            return func;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new native asynchronous function.\r\n         * @param {!Function} asyncFunc JavaScript function.\r\n         * @return {!Interpreter.MyObject} New function.\r\n         */\r\n        Interpreter.prototype.createAsyncFunction = function (asyncFunc) {\r\n            var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n            func.asyncFunc = asyncFunc;\r\n            asyncFunc.id = this.functionCounter_++;\r\n            this.setProperty(func, 'length', asyncFunc.length, Interpreter.READONLY_DESCRIPTOR);\r\n            return func;\r\n        };\r\n        ;\r\n        /**\r\n         * Converts from a native JS object or value to a JS interpreter object.\r\n         * Can handle JSON-style values.\r\n         * @param {*} nativeObj The native JS object to be converted.\r\n         * @return {Interpreter.MyValue} The equivalent JS interpreter object.\r\n         */\r\n        Interpreter.prototype.nativeToPseudo = function (nativeObj) {\r\n            if (typeof nativeObj === 'boolean' ||\r\n                typeof nativeObj === 'number' ||\r\n                typeof nativeObj === 'string' ||\r\n                nativeObj === null || nativeObj === undefined) {\r\n                return nativeObj;\r\n            }\r\n            if (nativeObj instanceof RegExp) {\r\n                var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\r\n                this.populateRegExp(pseudoRegexp, nativeObj);\r\n                return pseudoRegexp;\r\n            }\r\n            if (nativeObj instanceof Function) {\r\n                var interpreter = this;\r\n                var wrapper = function () {\r\n                    return interpreter.nativeToPseudo(nativeObj.apply(interpreter, Array.prototype.slice.call(arguments)\r\n                        .map(function (i) {\r\n                        return interpreter.pseudoToNative(i);\r\n                    })));\r\n                };\r\n                return this.createNativeFunction(wrapper, undefined);\r\n            }\r\n            var pseudoObj;\r\n            if (Array.isArray(nativeObj)) {\r\n                pseudoObj = this.createObjectProto(this.ARRAY_PROTO);\r\n                for (var i = 0; i < nativeObj.length; i++) {\r\n                    if (i in nativeObj) {\r\n                        this.setProperty(pseudoObj, i, this.nativeToPseudo(nativeObj[i]));\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                pseudoObj = this.createObjectProto(this.OBJECT_PROTO);\r\n                for (var key in nativeObj) {\r\n                    this.setProperty(pseudoObj, key, this.nativeToPseudo(nativeObj[key]));\r\n                }\r\n            }\r\n            return pseudoObj;\r\n        };\r\n        ;\r\n        /**\r\n         * Converts from a JS interpreter object to native JS object.\r\n         * Can handle JSON-style values, plus cycles.\r\n         * @param {Interpreter.MyValue} pseudoObj The JS interpreter object to be\r\n         * converted.\r\n         * @param {Object=} opt_cycles Cycle detection (used in recursive calls).\r\n         * @return {*} The equivalent native JS object or value.\r\n         */\r\n        Interpreter.prototype.pseudoToNative = function (pseudoObj, opt_cycles) {\r\n            if (typeof pseudoObj === 'boolean' ||\r\n                typeof pseudoObj === 'number' ||\r\n                typeof pseudoObj === 'string' ||\r\n                pseudoObj === null || pseudoObj === undefined) {\r\n                return pseudoObj;\r\n            }\r\n            if (this.isa(pseudoObj, this.REGEXP)) {\r\n                return pseudoObj.data;\r\n            }\r\n            var cycles = opt_cycles || {\r\n                pseudo: [],\r\n                native: []\r\n            };\r\n            var i = cycles.pseudo.indexOf(pseudoObj);\r\n            if (i !== -1) {\r\n                return cycles.native[i];\r\n            }\r\n            cycles.pseudo.push(pseudoObj);\r\n            var nativeObj;\r\n            if (this.isa(pseudoObj, this.ARRAY)) {\r\n                nativeObj = [];\r\n                cycles.native.push(nativeObj);\r\n                var length = this.getProperty(pseudoObj, 'length');\r\n                for (var i = 0; i < length; i++) {\r\n                    if (this.hasProperty(pseudoObj, i)) {\r\n                        nativeObj[i] =\r\n                            this.pseudoToNative(this.getProperty(pseudoObj, i), cycles);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                nativeObj = {};\r\n                cycles.native.push(nativeObj);\r\n                var val;\r\n                for (var key in pseudoObj.properties) {\r\n                    val = pseudoObj.properties[key];\r\n                    nativeObj[key] = this.pseudoToNative(val, cycles);\r\n                }\r\n            }\r\n            cycles.pseudo.pop();\r\n            cycles.native.pop();\r\n            return nativeObj;\r\n        };\r\n        ;\r\n        /**\r\n         * Look up the prototype for this value.\r\n         * @param {Interpreter.MyValue} value Data object.\r\n         * @return {Interpreter.MyObject} Prototype object, null if none.\r\n         */\r\n        Interpreter.prototype.getPrototype = function (value) {\r\n            switch (typeof value) {\r\n                case 'number':\r\n                    return this.NUMBER.properties['prototype'];\r\n                case 'boolean':\r\n                    return this.BOOLEAN.properties['prototype'];\r\n                case 'string':\r\n                    return this.STRING.properties['prototype'];\r\n            }\r\n            if (value) {\r\n                return value.proto;\r\n            }\r\n            return null;\r\n        };\r\n        ;\r\n        /**\r\n         * Fetch a property value from a data object.\r\n         * @param {Interpreter.MyValue} obj Data object.\r\n         * @param {Interpreter.MyValue} name Name of property.\r\n         * @return {Interpreter.MyValue} Property value (may be undefined).\r\n         */\r\n        Interpreter.prototype.getProperty = function (obj, name) {\r\n            name = String(name);\r\n            if (obj === undefined || obj === null) {\r\n                this.throwException(this.TYPE_ERROR, \"Cannot read property '\" + name + \"' of \" + obj);\r\n            }\r\n            if (name === 'length') {\r\n                // Special cases for magic length property.\r\n                if (this.isa(obj, this.STRING)) {\r\n                    return String(obj).length;\r\n                }\r\n            }\r\n            else if (name.charCodeAt(0) < 0x40) {\r\n                // Might have numbers in there?\r\n                // Special cases for string array indexing\r\n                if (this.isa(obj, this.STRING)) {\r\n                    var n = Interpreter.legalArrayIndex(name);\r\n                    if (!isNaN(n) && n < String(obj).length) {\r\n                        return String(obj)[n];\r\n                    }\r\n                }\r\n            }\r\n            do {\r\n                var myObj = obj;\r\n                if (myObj.properties && name in myObj.properties) {\r\n                    var getter = myObj.getter[name];\r\n                    if (getter) {\r\n                        // Flag this function as being a getter and thus needing immediate\r\n                        // execution (rather than being the value of the property).\r\n                        getter.isGetter = true;\r\n                        return getter;\r\n                    }\r\n                    return myObj.properties[name];\r\n                }\r\n            } while ((obj = this.getPrototype(obj)));\r\n            return undefined;\r\n        };\r\n        ;\r\n        /**\r\n         * Does the named property exist on a data object.\r\n         * @param {Interpreter.MyValue} obj Data object.\r\n         * @param {Interpreter.MyValue} name Name of property.\r\n         * @return {boolean} True if property exists.\r\n         */\r\n        Interpreter.prototype.hasProperty = function (obj, name) {\r\n            if (!obj['isObject']) {\r\n                throw TypeError('Primitive data type has no properties');\r\n            }\r\n            name = String(name);\r\n            if (name === 'length' && this.isa(obj, this.STRING)) {\r\n                return true;\r\n            }\r\n            if (this.isa(obj, this.STRING)) {\r\n                var n = Interpreter.legalArrayIndex(name);\r\n                if (!isNaN(n) && n < String(obj).length) {\r\n                    return true;\r\n                }\r\n            }\r\n            do {\r\n                var myObj = obj;\r\n                if (myObj.properties && name in myObj.properties) {\r\n                    return true;\r\n                }\r\n            } while ((obj = this.getPrototype(obj)));\r\n            return false;\r\n        };\r\n        ;\r\n        /**\r\n         * Set a property value on a data object.\r\n         * @param {!Interpreter.MyObject} obj Data object.\r\n         * @param {Interpreter.MyValue} name Name of property.\r\n         * @param {Interpreter.MyValue|ReferenceError} value New property value.\r\n         *   Use ReferenceError if value is handled by descriptor instead.\r\n         * @param {Object=} opt_descriptor Optional descriptor object.\r\n         * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n         *     needs to be called, otherwise undefined.\r\n         */\r\n        Interpreter.prototype.setProperty = function (obj, name, value, opt_descriptor) {\r\n            name = String(name);\r\n            if (obj === undefined || obj === null) {\r\n                this.throwException(this.TYPE_ERROR, \"Cannot set property '\" + name + \"' of \" + obj);\r\n            }\r\n            if (opt_descriptor && ('get' in opt_descriptor || 'set' in opt_descriptor) &&\r\n                ('value' in opt_descriptor || 'writable' in opt_descriptor)) {\r\n                this.throwException(this.TYPE_ERROR, 'Invalid property descriptor. ' +\r\n                    'Cannot both specify accessors and a value or writable attribute');\r\n            }\r\n            var strict = !this.stateStack || this.getScope().strict;\r\n            if (!obj.isObject) {\r\n                if (strict) {\r\n                    this.throwException(this.TYPE_ERROR, \"Can't create property '\" + name +\r\n                        \"' on '\" + obj + \"'\");\r\n                }\r\n                return;\r\n            }\r\n            if (this.isa(obj, this.STRING)) {\r\n                var n = Interpreter.legalArrayIndex(name);\r\n                if (name === 'length' || (!isNaN(n) && n < String(obj).length)) {\r\n                    // Can't set length or letters on String objects.\r\n                    if (strict) {\r\n                        this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\r\n                            \"property '\" + name + \"' of String '\" + obj.data + \"'\");\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            if (obj.class === 'Array') {\r\n                // Arrays have a magic length variable that is bound to the elements.\r\n                var length = obj.properties.length;\r\n                var i;\r\n                if (name === 'length') {\r\n                    // Delete elements if length is smaller.\r\n                    value = Interpreter.legalArrayLength(value);\r\n                    if (isNaN(value)) {\r\n                        this.throwException(this.RANGE_ERROR, 'Invalid array length');\r\n                    }\r\n                    if (value < length) {\r\n                        for (i in obj.properties) {\r\n                            i = Interpreter.legalArrayIndex(i);\r\n                            if (!isNaN(i) && value <= i) {\r\n                                delete obj.properties[i];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else if (!isNaN(i = Interpreter.legalArrayIndex(name))) {\r\n                    // Increase length if this index is larger.\r\n                    obj.properties.length = Math.max(length, i + 1);\r\n                }\r\n            }\r\n            if (obj.preventExtensions && !(name in obj.properties)) {\r\n                if (strict) {\r\n                    this.throwException(this.TYPE_ERROR, \"Can't add property '\" + name +\r\n                        \"', object is not extensible\");\r\n                }\r\n                return;\r\n            }\r\n            if (opt_descriptor) {\r\n                // Define the property.\r\n                if ('get' in opt_descriptor) {\r\n                    if (opt_descriptor.get) {\r\n                        obj.getter[name] = opt_descriptor.get;\r\n                    }\r\n                    else {\r\n                        delete obj.getter[name];\r\n                    }\r\n                }\r\n                if ('set' in opt_descriptor) {\r\n                    if (opt_descriptor.set) {\r\n                        obj.setter[name] = opt_descriptor.set;\r\n                    }\r\n                    else {\r\n                        delete obj.setter[name];\r\n                    }\r\n                }\r\n                var descriptor = {};\r\n                if ('configurable' in opt_descriptor) {\r\n                    descriptor.configurable = opt_descriptor.configurable;\r\n                }\r\n                if ('enumerable' in opt_descriptor) {\r\n                    descriptor.enumerable = opt_descriptor.enumerable;\r\n                }\r\n                if ('writable' in opt_descriptor) {\r\n                    descriptor.writable = opt_descriptor.writable;\r\n                    delete obj.getter[name];\r\n                    delete obj.setter[name];\r\n                }\r\n                if ('value' in opt_descriptor) {\r\n                    descriptor.value = opt_descriptor.value;\r\n                    delete obj.getter[name];\r\n                    delete obj.setter[name];\r\n                }\r\n                else if (value !== ReferenceError) {\r\n                    descriptor.value = value;\r\n                    delete obj.getter[name];\r\n                    delete obj.setter[name];\r\n                }\r\n                try {\r\n                    Object.defineProperty(obj.properties, name, descriptor);\r\n                }\r\n                catch (e) {\r\n                    this.throwException(this.TYPE_ERROR, 'Cannot redefine property: ' + name);\r\n                }\r\n            }\r\n            else {\r\n                // Set the property.\r\n                if (value === ReferenceError) {\r\n                    throw ReferenceError('Value not specified.');\r\n                }\r\n                // Determine the parent (possibly self) where the property is defined.\r\n                var defObj = obj;\r\n                while (!(name in defObj.properties)) {\r\n                    defObj = this.getPrototype(defObj);\r\n                    if (!defObj) {\r\n                        // This is a new property.\r\n                        defObj = obj;\r\n                        break;\r\n                    }\r\n                }\r\n                if (defObj.setter && defObj.setter[name]) {\r\n                    return defObj.setter[name];\r\n                }\r\n                if (defObj.getter && defObj.getter[name]) {\r\n                    if (strict) {\r\n                        this.throwException(this.TYPE_ERROR, \"Cannot set property '\" + name +\r\n                            \"' of object '\" + obj + \"' which only has a getter\");\r\n                    }\r\n                }\r\n                else {\r\n                    // No setter, simple assignment.\r\n                    try {\r\n                        obj.properties[name] = value;\r\n                    }\r\n                    catch (e) {\r\n                        if (strict) {\r\n                            this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\r\n                                \"property '\" + name + \"' of object '\" + obj + \"'\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Convenience method for adding a native function as a non-enumerable property\r\n         * onto an object's prototype.\r\n         * @param {!Interpreter.MyObject} obj Data object.\r\n         * @param {Interpreter.MyValue} name Name of property.\r\n         * @param {!Function} wrapper Function object.\r\n         */\r\n        Interpreter.prototype.setNativeFunctionPrototype = function (obj, name, wrapper) {\r\n            this.setProperty(obj.properties['prototype'], name, this.createNativeFunction(wrapper, false), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n        };\r\n        ;\r\n        /**\r\n         * Returns the current scope from the stateStack.\r\n         * @return {!Interpreter.MyObject} Current scope dictionary.\r\n         */\r\n        Interpreter.prototype.getScope = function () {\r\n            var scope = this.stateStack[this.stateStack.length - 1].scope;\r\n            if (!scope) {\r\n                throw Error('No scope found.');\r\n            }\r\n            return scope;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new scope dictionary.\r\n         * @param {!Object} node AST node defining the scope container\r\n         *     (e.g. a function).\r\n         * @param {Interpreter.MyObject} parentScope Scope to link to.\r\n         * @return {!Interpreter.MyObject} New scope.\r\n         */\r\n        Interpreter.prototype.createScope = function (node, parentScope) {\r\n            var scope = this.createObjectProto(null);\r\n            scope.parentScope = parentScope;\r\n            if (!parentScope) {\r\n                this.initGlobalScope(scope);\r\n            }\r\n            this.populateScope_(node, scope);\r\n            // Determine if this scope starts with 'use strict'.\r\n            scope.strict = false;\r\n            if (parentScope && parentScope.strict) {\r\n                scope.strict = true;\r\n            }\r\n            else {\r\n                var firstNode = node['body'] && node['body'][0];\r\n                if (firstNode && firstNode.expression &&\r\n                    firstNode.expression['type'] === 'Literal' &&\r\n                    firstNode.expression.value === 'use strict') {\r\n                    scope.strict = true;\r\n                }\r\n            }\r\n            return scope;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new special scope dictionary. Similar to createScope(), but\r\n         * doesn't assume that the scope is for a function body.\r\n         * This is used for 'catch' clauses and 'with' statements.\r\n         * @param {!Interpreter.MyObject} parentScope Scope to link to.\r\n         * @param {Interpreter.MyObject=} opt_scope Optional object to transform into\r\n         *     scope.\r\n         * @return {!Interpreter.MyObject} New scope.\r\n         */\r\n        Interpreter.prototype.createSpecialScope = function (parentScope, opt_scope) {\r\n            if (!parentScope) {\r\n                throw Error('parentScope required');\r\n            }\r\n            var scope = opt_scope || this.createObjectProto(null);\r\n            scope.parentScope = parentScope;\r\n            scope.strict = parentScope.strict;\r\n            return scope;\r\n        };\r\n        ;\r\n        /**\r\n         * Retrieves a value from the scope chain.\r\n         * @param {string} name Name of variable.\r\n         * @return {Interpreter.MyValue} Any value.\r\n         *   May be flagged as being a getter and thus needing immediate execution\r\n         *   (rather than being the value of the property).\r\n         */\r\n        Interpreter.prototype.getValueFromScope = function (name) {\r\n            var scope = this.getScope();\r\n            while (scope && scope !== this.global) {\r\n                if (name in scope.properties) {\r\n                    return scope.properties[name];\r\n                }\r\n                scope = scope.parentScope;\r\n            }\r\n            // The root scope is also an object which has inherited properties and\r\n            // could also have getters.\r\n            if (scope === this.global && this.hasProperty(scope, name)) {\r\n                return this.getProperty(scope, name);\r\n            }\r\n            // Typeof operator is unique: it can safely look at non-defined variables.\r\n            var prevNode = this.stateStack[this.stateStack.length - 1].node;\r\n            if (prevNode['type'] === 'UnaryExpression' &&\r\n                prevNode['operator'] === 'typeof') {\r\n                return undefined;\r\n            }\r\n            this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\r\n        };\r\n        ;\r\n        /**\r\n         * Sets a value to the current scope.\r\n         * @param {string} name Name of variable.\r\n         * @param {Interpreter.MyValue} value Value.\r\n         * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n         *     needs to be called, otherwise undefined.\r\n         */\r\n        Interpreter.prototype.setValueToScope = function (name, value) {\r\n            var scope = this.getScope();\r\n            var strict = scope.strict;\r\n            while (scope && scope !== this.global) {\r\n                if (name in scope.properties) {\r\n                    scope.properties[name] = value;\r\n                    return undefined;\r\n                }\r\n                scope = scope.parentScope;\r\n            }\r\n            // The root scope is also an object which has readonly properties and\r\n            // could also have setters.\r\n            if (scope === this.global && (!strict || this.hasProperty(scope, name))) {\r\n                return this.setProperty(scope, name, value);\r\n            }\r\n            this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\r\n        };\r\n        ;\r\n        /**\r\n         * Create a new scope for the given node.\r\n         * @param {!Object} node AST node (program or function).\r\n         * @param {!Interpreter.MyObject} scope Scope dictionary to populate.\r\n         * @private\r\n         */\r\n        Interpreter.prototype.populateScope_ = function (node, scope) {\r\n            if (node['type'] === 'VariableDeclaration') {\r\n                for (var i = 0; i < node['declarations'].length; i++) {\r\n                    this.setProperty(scope, node['declarations'][i]['id']['name'], undefined, Interpreter.VARIABLE_DESCRIPTOR);\r\n                }\r\n            }\r\n            else if (node['type'] === 'FunctionDeclaration') {\r\n                this.setProperty(scope, node['id']['name'], this.createFunction(node, scope), Interpreter.VARIABLE_DESCRIPTOR);\r\n                return; // Do not recurse into function.\r\n            }\r\n            else if (node['type'] === 'FunctionExpression') {\r\n                return; // Do not recurse into function.\r\n            }\r\n            else if (node['type'] === 'ExpressionStatement') {\r\n                return; // Expressions can't contain variable/function declarations.\r\n            }\r\n            var nodeClass = node['constructor'];\r\n            for (var name in node) {\r\n                var prop = node[name];\r\n                if (prop && typeof prop === 'object') {\r\n                    if (Array.isArray(prop)) {\r\n                        for (var i = 0; i < prop.length; i++) {\r\n                            if (prop[i] && prop[i].constructor === nodeClass) {\r\n                                this.populateScope_(prop[i], scope);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (prop.constructor === nodeClass) {\r\n                            this.populateScope_(prop, scope);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Remove start and end values from AST, or set start and end values to a\r\n         * constant value.  Used to remove highlighting from polyfills and to set\r\n         * highlighting in an eval to cover the entire eval expression.\r\n         * @param {!Object} node AST node.\r\n         * @param {number=} start Starting character of all nodes, or undefined.\r\n         * @param {number=} end Ending character of all nodes, or undefined.\r\n         * @private\r\n         */\r\n        Interpreter.prototype.stripLocations_ = function (node, start, end) {\r\n            if (start) {\r\n                node['start'] = start;\r\n            }\r\n            else {\r\n                delete node['start'];\r\n            }\r\n            if (end) {\r\n                node['end'] = end;\r\n            }\r\n            else {\r\n                delete node['end'];\r\n            }\r\n            for (var name in node) {\r\n                if (node.hasOwnProperty(name)) {\r\n                    var prop = node[name];\r\n                    if (prop && typeof prop === 'object') {\r\n                        this.stripLocations_(prop, start, end);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Is the current state directly being called with as a construction with 'new'.\r\n         * @return {boolean} True if 'new foo()', false if 'foo()'.\r\n         */\r\n        Interpreter.prototype.calledWithNew = function () {\r\n            return this.stateStack[this.stateStack.length - 1].isConstructor;\r\n        };\r\n        ;\r\n        /**\r\n         * Gets a value from the scope chain or from an object property.\r\n         * @param {!Array} ref Name of variable or object/propname tuple.\r\n         * @return {Interpreter.MyValue} Any value.\r\n         *   May be flagged as being a getter and thus needing immediate execution\r\n         *   (rather than being the value of the property).\r\n         */\r\n        Interpreter.prototype.getValue = function (ref) {\r\n            if (ref[0] === Interpreter.SCOPE_REFERENCE) {\r\n                // A null/varname variable lookup.\r\n                return this.getValueFromScope(ref[1]);\r\n            }\r\n            else {\r\n                // An obj/prop components tuple (foo.bar).\r\n                return this.getProperty(ref[0], ref[1]);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Sets a value to the scope chain or to an object property.\r\n         * @param {!Array} ref Name of variable or object/propname tuple.\r\n         * @param {Interpreter.MyValue} value Value.\r\n         * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n         *     needs to be called, otherwise undefined.\r\n         */\r\n        Interpreter.prototype.setValue = function (ref, value) {\r\n            if (ref[0] === Interpreter.SCOPE_REFERENCE) {\r\n                // A null/varname variable lookup.\r\n                return this.setValueToScope(ref[1], value);\r\n            }\r\n            else {\r\n                // An obj/prop components tuple (foo.bar).\r\n                return this.setProperty(ref[0], ref[1], value);\r\n            }\r\n        };\r\n        ;\r\n        /**\r\n         * Throw an exception in the interpreter that can be handled by an\r\n         * interpreter try/catch statement.  If unhandled, a real exception will\r\n         * be thrown.  Can be called with either an error class and a message, or\r\n         * with an actual object to be thrown.\r\n         * @param {!Interpreter.MyObject} errorClass Type of error (if message is\r\n         *   provided) or the value to throw (if no message).\r\n         * @param {string=} opt_message Message being thrown.\r\n         */\r\n        Interpreter.prototype.throwException = function (errorClass, opt_message) {\r\n            if (opt_message === undefined) {\r\n                var error = errorClass; // This is a value to throw, not an error class.\r\n            }\r\n            else {\r\n                var error = this.createObject(errorClass);\r\n                this.setProperty(error, 'message', opt_message, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n            }\r\n            this.executeException(error);\r\n            // Abort anything related to the current step.\r\n            throw Interpreter.STEP_ERROR;\r\n        };\r\n        ;\r\n        /**\r\n         * Throw an exception in the interpreter that can be handled by a\r\n         * interpreter try/catch statement.  If unhandled, a real exception will\r\n         * be thrown.\r\n         * @param {!Interpreter.MyObject} error Error object to execute.\r\n         */\r\n        Interpreter.prototype.executeException = function (error) {\r\n            // Search for a try statement.\r\n            do {\r\n                this.stateStack.pop();\r\n                var state = this.stateStack[this.stateStack.length - 1];\r\n                if (state.node['type'] === 'TryStatement') {\r\n                    state.throwValue = error;\r\n                    return;\r\n                }\r\n            } while (state && state.node['type'] !== 'Program');\r\n            // Throw a real error.\r\n            var realError;\r\n            if (this.isa(error, this.ERROR)) {\r\n                var errorTable = {\r\n                    'EvalError': EvalError,\r\n                    'RangeError': RangeError,\r\n                    'ReferenceError': ReferenceError,\r\n                    'SyntaxError': SyntaxError,\r\n                    'TypeError': TypeError,\r\n                    'URIError': URIError\r\n                };\r\n                var name = this.getProperty(error, 'name').toString();\r\n                var message = this.getProperty(error, 'message').valueOf();\r\n                var type = errorTable[name] || Error;\r\n                realError = type(message);\r\n            }\r\n            else {\r\n                realError = error.toString();\r\n            }\r\n            throw realError;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a call to a getter function.\r\n         * @param {!Interpreter.MyObject} func Function to execute.\r\n         * @param {!Interpreter.MyObject|!Array} left\r\n         *     Name of variable or object/propname tuple.\r\n         * @private\r\n         */\r\n        Interpreter.prototype.createGetter_ = function (func, left) {\r\n            // Normally 'this' will be specified as the object component (o.x).\r\n            // Sometimes 'this' is explicitly provided (o).\r\n            var funcThis = Array.isArray(left) ? left[0] : left;\r\n            var node = new this.nodeConstructor();\r\n            node['type'] = 'CallExpression';\r\n            var state = new Interpreter.MyState(node, this.stateStack[this.stateStack.length - 1].scope);\r\n            state.doneCallee_ = true;\r\n            state.funcThis_ = funcThis;\r\n            state.func_ = func;\r\n            state.doneArgs_ = true;\r\n            state.arguments_ = [];\r\n            return state;\r\n        };\r\n        ;\r\n        /**\r\n         * Create a call to a setter function.\r\n         * @param {!Interpreter.MyObject} func Function to execute.\r\n         * @param {!Interpreter.MyObject|!Array} left\r\n         *     Name of variable or object/propname tuple.\r\n         * @param {Interpreter.MyValue} value Value to set.\r\n         * @private\r\n         */\r\n        Interpreter.prototype.createSetter_ = function (func, left, value) {\r\n            // Normally 'this' will be specified as the object component (o.x).\r\n            // Sometimes 'this' is implicitly the global object (x).\r\n            var funcThis = Array.isArray(left) ? left[0] : this.global;\r\n            var node = new this.nodeConstructor();\r\n            node['type'] = 'CallExpression';\r\n            var state = new Interpreter.MyState(node, this.stateStack[this.stateStack.length - 1].scope);\r\n            state.doneCallee_ = true;\r\n            state.funcThis_ = funcThis;\r\n            state.func_ = func;\r\n            state.doneArgs_ = true;\r\n            state.arguments_ = [value];\r\n            return state;\r\n        };\r\n        ;\r\n        ///////////////////////////////////////////////////////////////////////////////\r\n        // Functions to handle each node type.\r\n        ///////////////////////////////////////////////////////////////////////////////\r\n        Interpreter.prototype.stepArrayExpression = function (stack, state, node) {\r\n            var elements = node['elements'];\r\n            var n = state.n_ || 0;\r\n            if (!state.array_) {\r\n                state.array_ = this.createObjectProto(this.ARRAY_PROTO);\r\n                state.array_.properties.length = elements.length;\r\n            }\r\n            else {\r\n                this.setProperty(state.array_, n, state.value);\r\n                n++;\r\n            }\r\n            while (n < elements.length) {\r\n                // Skip missing elements - they're not defined, not undefined.\r\n                if (elements[n]) {\r\n                    state.n_ = n;\r\n                    return new Interpreter.MyState(elements[n], state.scope);\r\n                }\r\n                n++;\r\n            }\r\n            stack.pop();\r\n            stack[stack.length - 1].value = state.array_;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepAssignmentExpression = function (stack, state, node) {\r\n            if (!state.doneLeft_) {\r\n                state.doneLeft_ = true;\r\n                var nextState = new Interpreter.MyState(node['left'], state.scope);\r\n                nextState.components = true;\r\n                return nextState;\r\n            }\r\n            if (!state.doneRight_) {\r\n                if (!state.leftReference_) {\r\n                    state.leftReference_ = state.value;\r\n                }\r\n                if (state.doneGetter_) {\r\n                    state.leftValue_ = state.value;\r\n                }\r\n                if (!state.doneGetter_ && node['operator'] !== '=') {\r\n                    var leftValue = this.getValue(state.leftReference_);\r\n                    state.leftValue_ = leftValue;\r\n                    if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\r\n                        // Clear the getter flag and call the getter function.\r\n                        leftValue.isGetter = false;\r\n                        state.doneGetter_ = true;\r\n                        var func = (leftValue);\r\n                        return this.createGetter_(func, state.leftReference_);\r\n                    }\r\n                }\r\n                state.doneRight_ = true;\r\n                return new Interpreter.MyState(node['right'], state.scope);\r\n            }\r\n            if (state.doneSetter_) {\r\n                // Return if setter function.\r\n                // Setter method on property has completed.\r\n                // Ignore its return value, and use the original set value instead.\r\n                stack.pop();\r\n                stack[stack.length - 1].value = state.doneSetter_;\r\n                return;\r\n            }\r\n            var value = state.leftValue_;\r\n            var rightValue = state.value;\r\n            switch (node['operator']) {\r\n                case '=':\r\n                    value = rightValue;\r\n                    break;\r\n                case '+=':\r\n                    value += rightValue;\r\n                    break;\r\n                case '-=':\r\n                    value -= rightValue;\r\n                    break;\r\n                case '*=':\r\n                    value *= rightValue;\r\n                    break;\r\n                case '/=':\r\n                    value /= rightValue;\r\n                    break;\r\n                case '%=':\r\n                    value %= rightValue;\r\n                    break;\r\n                case '<<=':\r\n                    value <<= rightValue;\r\n                    break;\r\n                case '>>=':\r\n                    value >>= rightValue;\r\n                    break;\r\n                case '>>>=':\r\n                    value >>>= rightValue;\r\n                    break;\r\n                case '&=':\r\n                    value &= rightValue;\r\n                    break;\r\n                case '^=':\r\n                    value ^= rightValue;\r\n                    break;\r\n                case '|=':\r\n                    value |= rightValue;\r\n                    break;\r\n                default:\r\n                    throw SyntaxError('Unknown assignment expression: ' + node['operator']);\r\n            }\r\n            var setter = this.setValue(state.leftReference_, value);\r\n            if (setter) {\r\n                state.doneSetter_ = value;\r\n                return this.createSetter_(setter, state.leftReference_, value);\r\n            }\r\n            // Return if no setter function.\r\n            stack.pop();\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepBinaryExpression = function (stack, state, node) {\r\n            if (!state.doneLeft_) {\r\n                state.doneLeft_ = true;\r\n                return new Interpreter.MyState(node['left'], state.scope);\r\n            }\r\n            if (!state.doneRight_) {\r\n                state.doneRight_ = true;\r\n                state.leftValue_ = state.value;\r\n                return new Interpreter.MyState(node['right'], state.scope);\r\n            }\r\n            stack.pop();\r\n            var leftValue = state.leftValue_;\r\n            var rightValue = state.value;\r\n            var value;\r\n            switch (node['operator']) {\r\n                case '==':\r\n                    value = leftValue == rightValue;\r\n                    break;\r\n                case '!=':\r\n                    value = leftValue != rightValue;\r\n                    break;\r\n                case '===':\r\n                    value = leftValue === rightValue;\r\n                    break;\r\n                case '!==':\r\n                    value = leftValue !== rightValue;\r\n                    break;\r\n                case '>':\r\n                    value = leftValue > rightValue;\r\n                    break;\r\n                case '>=':\r\n                    value = leftValue >= rightValue;\r\n                    break;\r\n                case '<':\r\n                    value = leftValue < rightValue;\r\n                    break;\r\n                case '<=':\r\n                    value = leftValue <= rightValue;\r\n                    break;\r\n                case '+':\r\n                    value = leftValue + rightValue;\r\n                    break;\r\n                case '-':\r\n                    value = leftValue - rightValue;\r\n                    break;\r\n                case '*':\r\n                    value = leftValue * rightValue;\r\n                    break;\r\n                case '/':\r\n                    value = leftValue / rightValue;\r\n                    break;\r\n                case '%':\r\n                    value = leftValue % rightValue;\r\n                    break;\r\n                case '&':\r\n                    value = leftValue & rightValue;\r\n                    break;\r\n                case '|':\r\n                    value = leftValue | rightValue;\r\n                    break;\r\n                case '^':\r\n                    value = leftValue ^ rightValue;\r\n                    break;\r\n                case '<<':\r\n                    value = leftValue << rightValue;\r\n                    break;\r\n                case '>>':\r\n                    value = leftValue >> rightValue;\r\n                    break;\r\n                case '>>>':\r\n                    value = leftValue >>> rightValue;\r\n                    break;\r\n                case 'in':\r\n                    if (!rightValue || !rightValue.isObject) {\r\n                        this.throwException(this.TYPE_ERROR, \"'in' expects an object, not '\" + rightValue + \"'\");\r\n                    }\r\n                    value = this.hasProperty(rightValue, leftValue);\r\n                    break;\r\n                case 'instanceof':\r\n                    if (!this.isa(rightValue, this.FUNCTION)) {\r\n                        this.throwException(this.TYPE_ERROR, 'Right-hand side of instanceof is not an object');\r\n                    }\r\n                    value = leftValue.isObject ? this.isa(leftValue, rightValue) : false;\r\n                    break;\r\n                default:\r\n                    throw SyntaxError('Unknown binary operator: ' + node['operator']);\r\n            }\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepBlockStatement = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var expression = node['body'][n];\r\n            if (expression) {\r\n                state.n_ = n + 1;\r\n                return new Interpreter.MyState(expression, state.scope);\r\n            }\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepBreakStatement = function (stack, state, node) {\r\n            stack.pop();\r\n            var label = null;\r\n            if (node['label']) {\r\n                label = node['label']['name'];\r\n            }\r\n            while (state &&\r\n                state.node['type'] !== 'CallExpression' &&\r\n                state.node['type'] !== 'NewExpression') {\r\n                if (label) {\r\n                    if (state.labels && state.labels.indexOf(label) !== -1) {\r\n                        return;\r\n                    }\r\n                }\r\n                else if (state.isLoop || state.isSwitch) {\r\n                    return;\r\n                }\r\n                state = stack.pop();\r\n            }\r\n            // Syntax error, do not allow this error to be trapped.\r\n            throw SyntaxError('Illegal break statement');\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepCallExpression = function (stack, state, node) {\r\n            if (!state.doneCallee_) {\r\n                state.doneCallee_ = 1;\r\n                // Components needed to determine value of 'this'.\r\n                var nextState = new Interpreter.MyState(node['callee'], state.scope);\r\n                nextState.components = true;\r\n                return nextState;\r\n            }\r\n            if (state.doneCallee_ === 1) {\r\n                // Determine value of the function.\r\n                state.doneCallee_ = 2;\r\n                var func = state.value;\r\n                if (Array.isArray(func)) {\r\n                    state.func_ = this.getValue(func);\r\n                    if (func[0] !== Interpreter.SCOPE_REFERENCE) {\r\n                        // Method function, 'this' is object (ignored if invoked as 'new').\r\n                        state.funcThis_ = func[0];\r\n                    }\r\n                    func = state.func_;\r\n                    if (func && typeof func === 'object' && func.isGetter) {\r\n                        // Clear the getter flag and call the getter function.\r\n                        func.isGetter = false;\r\n                        state.doneCallee_ = 1;\r\n                        return this.createGetter_(/** @type {!Interpreter.Object} */ (func), state.value);\r\n                    }\r\n                }\r\n                else {\r\n                    // Already evaluated function: (function(){...})();\r\n                    state.func_ = func;\r\n                }\r\n                state.arguments_ = [];\r\n                state.n_ = 0;\r\n            }\r\n            var func = state.func_;\r\n            if (!state.doneArgs_) {\r\n                if (state.n_ !== 0) {\r\n                    state.arguments_.push(state.value);\r\n                }\r\n                if (node['arguments'][state.n_]) {\r\n                    return new Interpreter.MyState(node['arguments'][state.n_++], state.scope);\r\n                }\r\n                // Determine value of 'this' in function.\r\n                if (node['type'] === 'NewExpression') {\r\n                    if (func.illegalConstructor) {\r\n                        // Illegal: new escape();\r\n                        this.throwException(this.TYPE_ERROR, func + ' is not a constructor');\r\n                    }\r\n                    // Constructor, 'this' is new object.\r\n                    state.funcThis_ = this.createObject(func);\r\n                    state.isConstructor = true;\r\n                }\r\n                else if (state.funcThis_ === undefined) {\r\n                    // Global function, 'this' is global object (or 'undefined' if strict).\r\n                    state.funcThis_ = state.scope.strict ? undefined : this.global;\r\n                }\r\n                state.doneArgs_ = true;\r\n            }\r\n            if (!state.doneExec_) {\r\n                state.doneExec_ = true;\r\n                if (!func || !func.isObject) {\r\n                    this.throwException(this.TYPE_ERROR, func + ' is not a function');\r\n                }\r\n                var funcNode = func.node;\r\n                if (funcNode) {\r\n                    var scope = this.createScope(funcNode['body'], func.parentScope);\r\n                    // Add all arguments.\r\n                    for (var i = 0; i < funcNode['params'].length; i++) {\r\n                        var paramName = funcNode['params'][i]['name'];\r\n                        var paramValue = state.arguments_.length > i ? state.arguments_[i] :\r\n                            undefined;\r\n                        this.setProperty(scope, paramName, paramValue);\r\n                    }\r\n                    // Build arguments variable.\r\n                    var argsList = this.createObjectProto(this.ARRAY_PROTO);\r\n                    for (var i = 0; i < state.arguments_.length; i++) {\r\n                        this.setProperty(argsList, i, state.arguments_[i]);\r\n                    }\r\n                    this.setProperty(scope, 'arguments', argsList);\r\n                    // Add the function's name (var x = function foo(){};)\r\n                    var name = funcNode['id'] && funcNode['id']['name'];\r\n                    if (name) {\r\n                        this.setProperty(scope, name, func);\r\n                    }\r\n                    this.setProperty(scope, 'this', state.funcThis_, Interpreter.READONLY_DESCRIPTOR);\r\n                    state.value = undefined; // Default value if no explicit return.\r\n                    return new Interpreter.MyState(funcNode['body'], scope);\r\n                }\r\n                else if (func.eval) {\r\n                    var code = state.arguments_[0];\r\n                    if (typeof code !== 'string') {\r\n                        // JS does not parse String objects:\r\n                        // eval(new String('1 + 1')) -> '1 + 1'\r\n                        state.value = code;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            var ast = Interpreter.acorn.parse(code.toString(), Interpreter.PARSE_OPTIONS);\r\n                        }\r\n                        catch (e) {\r\n                            // Acorn threw a SyntaxError.  Rethrow as a trappable error.\r\n                            this.throwException(this.SYNTAX_ERROR, 'Invalid code: ' + e.message);\r\n                        }\r\n                        var evalNode = new this.nodeConstructor();\r\n                        evalNode['type'] = 'EvalProgram_';\r\n                        evalNode['body'] = ast['body'];\r\n                        this.stripLocations_(evalNode, node['start'], node['end']);\r\n                        // Update current scope with definitions in eval().\r\n                        var scope = state.scope;\r\n                        if (scope.strict) {\r\n                            // Strict mode get its own scope in eval.\r\n                            scope = this.createScope(ast, scope);\r\n                        }\r\n                        else {\r\n                            // Non-strict mode pollutes the current scope.\r\n                            this.populateScope_(ast, scope);\r\n                        }\r\n                        this.value = undefined; // Default value if no code.\r\n                        return new Interpreter.MyState(evalNode, scope);\r\n                    }\r\n                }\r\n                else if (func.nativeFunc) {\r\n                    state.value = func.nativeFunc.apply(state.funcThis_, state.arguments_);\r\n                }\r\n                else if (func.asyncFunc) {\r\n                    var thisInterpreter = this;\r\n                    var callback = function (value) {\r\n                        state.value = value;\r\n                        thisInterpreter.paused_ = false;\r\n                    };\r\n                    var argsWithCallback = state.arguments_.concat(callback);\r\n                    this.paused_ = true;\r\n                    func.asyncFunc.apply(state.funcThis_, argsWithCallback);\r\n                    return;\r\n                }\r\n                else {\r\n                    /* A child of a function is a function but is not callable.  For example:\r\n                    var F = function() {};\r\n                    F.prototype = escape;\r\n                    var f = new F();\r\n                    f();\r\n                    */\r\n                    this.throwException(this.TYPE_ERROR, func.class + ' is not a function');\r\n                }\r\n            }\r\n            else {\r\n                // Execution complete.  Put the return value on the stack.\r\n                stack.pop();\r\n                if (state.isConstructor && typeof state.value !== 'object') {\r\n                    stack[stack.length - 1].value = state.funcThis_;\r\n                }\r\n                else {\r\n                    stack[stack.length - 1].value = state.value;\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepCatchClause = function (stack, state, node) {\r\n            if (!state.done_) {\r\n                state.done_ = true;\r\n                // Create an empty scope.\r\n                var scope = this.createSpecialScope(state.scope);\r\n                // Add the argument.\r\n                this.setProperty(scope, node['param']['name'], state.throwValue);\r\n                // Execute catch clause.\r\n                return new Interpreter.MyState(node['body'], scope);\r\n            }\r\n            else {\r\n                stack.pop();\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepConditionalExpression = function (stack, state, node) {\r\n            var mode = state.mode_ || 0;\r\n            if (mode === 0) {\r\n                state.mode_ = 1;\r\n                return new Interpreter.MyState(node['test'], state.scope);\r\n            }\r\n            if (mode === 1) {\r\n                state.mode_ = 2;\r\n                var value = Boolean(state.value);\r\n                if (value && node['consequent']) {\r\n                    // Execute 'if' block.\r\n                    return new Interpreter.MyState(node['consequent'], state.scope);\r\n                }\r\n                else if (!value && node['alternate']) {\r\n                    // Execute 'else' block.\r\n                    return new Interpreter.MyState(node['alternate'], state.scope);\r\n                }\r\n                // eval('1;if(false){2}') -> undefined\r\n                this.value = undefined;\r\n            }\r\n            stack.pop();\r\n            if (node['type'] === 'ConditionalExpression') {\r\n                stack[stack.length - 1].value = state.value;\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepContinueStatement = function (stack, state, node) {\r\n            stack.pop();\r\n            var label = null;\r\n            if (node['label']) {\r\n                label = node['label']['name'];\r\n            }\r\n            state = stack[stack.length - 1];\r\n            while (state &&\r\n                state.node['type'] !== 'CallExpression' &&\r\n                state.node['type'] !== 'NewExpression') {\r\n                if (state.isLoop) {\r\n                    if (!label || (state.labels && state.labels.indexOf(label) !== -1)) {\r\n                        return;\r\n                    }\r\n                }\r\n                stack.pop();\r\n                state = stack[stack.length - 1];\r\n            }\r\n            // Syntax error, do not allow this error to be trapped.\r\n            throw SyntaxError('Illegal continue statement');\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepDebuggerStatement = function (stack, state, node) {\r\n            // Do nothing.  May be overridden by developers.\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepDoWhileStatement = function (stack, state, node) {\r\n            if (node['type'] === 'DoWhileStatement' && state.test_ === undefined) {\r\n                // First iteration of do/while executes without checking test.\r\n                state.value = true;\r\n                state.test_ = true;\r\n            }\r\n            if (!state.test_) {\r\n                state.test_ = true;\r\n                return new Interpreter.MyState(node['test'], state.scope);\r\n            }\r\n            if (!state.value) {\r\n                stack.pop();\r\n            }\r\n            else if (node['body']) {\r\n                state.test_ = false;\r\n                state.isLoop = true;\r\n                return new Interpreter.MyState(node['body'], state.scope);\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepEmptyStatement = function (stack, state, node) {\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepEvalProgram_ = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var expression = node['body'][n];\r\n            if (expression) {\r\n                state.n_ = n + 1;\r\n                return new Interpreter.MyState(expression, state.scope);\r\n            }\r\n            stack.pop();\r\n            stack[stack.length - 1].value = this.value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepExpressionStatement = function (stack, state, node) {\r\n            if (!state.done_) {\r\n                state.done_ = true;\r\n                return new Interpreter.MyState(node['expression'], state.scope);\r\n            }\r\n            stack.pop();\r\n            // Save this value to interpreter.value for use as a return value if\r\n            // this code is inside an eval function.\r\n            this.value = state.value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepForInStatement = function (stack, state, node) {\r\n            // First, initialize a variable if exists.  Only do so once, ever.\r\n            if (!state.doneInit_) {\r\n                state.doneInit_ = true;\r\n                if (node['left']['declarations'] &&\r\n                    node['left']['declarations'][0]['init']) {\r\n                    if (state.scope.strict) {\r\n                        this.throwException(this.SYNTAX_ERROR, 'for-in loop variable declaration may not have an initializer.');\r\n                    }\r\n                    // Variable initialization: for (var x = 4 in y)\r\n                    return new Interpreter.MyState(node['left'], state.scope);\r\n                }\r\n            }\r\n            // Second, look up the object.  Only do so once, ever.\r\n            if (!state.doneObject_) {\r\n                state.doneObject_ = true;\r\n                if (!state.variable_) {\r\n                    state.variable_ = state.value;\r\n                }\r\n                return new Interpreter.MyState(node['right'], state.scope);\r\n            }\r\n            if (!state.isLoop) {\r\n                // First iteration.\r\n                state.isLoop = true;\r\n                state.object_ = state.value;\r\n                state.visited_ = Object.create(null);\r\n            }\r\n            // Third, find the property name for this iteration.\r\n            if (state.name_ === undefined) {\r\n                done: do {\r\n                    if (state.object_ && state.object_.isObject) {\r\n                        if (!state.props_) {\r\n                            state.props_ = Object.getOwnPropertyNames(state.object_.properties);\r\n                        }\r\n                        do {\r\n                            var prop = state.props_.shift();\r\n                        } while (prop && (state.visited_[prop] ||\r\n                            !Object.prototype.hasOwnProperty.call(state.object_.properties, prop)));\r\n                        if (prop) {\r\n                            state.visited_[prop] = true;\r\n                            if (Object.prototype.propertyIsEnumerable.call(state.object_.properties, prop)) {\r\n                                state.name_ = prop;\r\n                                break done;\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (state.object_ !== null) {\r\n                        if (!state.props_) {\r\n                            state.props_ = Object.getOwnPropertyNames(state.object_);\r\n                        }\r\n                        do {\r\n                            var prop = state.props_.shift();\r\n                        } while (prop && state.visited_[prop]);\r\n                        if (prop) {\r\n                            state.visited_[prop] = true;\r\n                            state.name_ = prop;\r\n                            break done;\r\n                        }\r\n                    }\r\n                    state.object_ = this.getPrototype(state.object_);\r\n                    state.props_ = null;\r\n                } while (state.object_ !== null);\r\n                if (state.object_ === null) {\r\n                    // Done, exit loop.\r\n                    stack.pop();\r\n                    return;\r\n                }\r\n            }\r\n            // Fourth, find the variable\r\n            if (!state.doneVariable_) {\r\n                state.doneVariable_ = true;\r\n                var left = node['left'];\r\n                if (left['type'] === 'VariableDeclaration') {\r\n                    // Inline variable declaration: for (var x in y)\r\n                    state.variable_ =\r\n                        [Interpreter.SCOPE_REFERENCE, left['declarations'][0]['id']['name']];\r\n                }\r\n                else {\r\n                    // Arbitrary left side: for (foo().bar in y)\r\n                    state.variable_ = null;\r\n                    var nextState = new Interpreter.MyState(left, state.scope);\r\n                    nextState.components = true;\r\n                    return nextState;\r\n                }\r\n            }\r\n            if (!state.variable_) {\r\n                state.variable_ = state.value;\r\n            }\r\n            // Fifth, set the variable.\r\n            if (!state.doneSetter_) {\r\n                state.doneSetter_ = true;\r\n                var value = state.name_;\r\n                var setter = this.setValue(state.variable_, value);\r\n                if (setter) {\r\n                    return this.createSetter_(setter, state.variable_, value);\r\n                }\r\n            }\r\n            // Next step will be step three.\r\n            state.name_ = undefined;\r\n            // Reevaluate the variable since it could be a setter on the global object.\r\n            state.doneVariable_ = false;\r\n            state.doneSetter_ = false;\r\n            // Sixth and finally, execute the body if there was one.  this.\r\n            if (node['body']) {\r\n                return new Interpreter.MyState(node['body'], state.scope);\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepForStatement = function (stack, state, node) {\r\n            var mode = state.mode_ || 0;\r\n            if (mode === 0) {\r\n                state.mode_ = 1;\r\n                if (node['init']) {\r\n                    return new Interpreter.MyState(node['init'], state.scope);\r\n                }\r\n            }\r\n            else if (mode === 1) {\r\n                state.mode_ = 2;\r\n                if (node['test']) {\r\n                    return new Interpreter.MyState(node['test'], state.scope);\r\n                }\r\n            }\r\n            else if (mode === 2) {\r\n                state.mode_ = 3;\r\n                if (node['test'] && !state.value) {\r\n                    // Done, exit loop.\r\n                    stack.pop();\r\n                }\r\n                else {\r\n                    state.isLoop = true;\r\n                    return new Interpreter.MyState(node['body'], state.scope);\r\n                }\r\n            }\r\n            else if (mode === 3) {\r\n                state.mode_ = 1;\r\n                if (node['update']) {\r\n                    return new Interpreter.MyState(node['update'], state.scope);\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepFunctionDeclaration = function (stack, state, node) {\r\n            // This was found and handled when the scope was populated.\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepFunctionExpression = function (stack, state, node) {\r\n            stack.pop();\r\n            stack[stack.length - 1].value = this.createFunction(node, state.scope);\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepIdentifier = function (stack, state, node) {\r\n            stack.pop();\r\n            if (state.components) {\r\n                stack[stack.length - 1].value = [Interpreter.SCOPE_REFERENCE, node['name']];\r\n                return;\r\n            }\r\n            var value = this.getValueFromScope(node['name']);\r\n            // An identifier could be a getter if it's a property on the global object.\r\n            if (value && typeof value === 'object' && value.isGetter) {\r\n                // Clear the getter flag and call the getter function.\r\n                value.isGetter = false;\r\n                var scope = state.scope;\r\n                while (!this.hasProperty(scope, node['name'])) {\r\n                    scope = scope.parentScope;\r\n                }\r\n                var func = (value);\r\n                return this.createGetter_(func, this.global);\r\n            }\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepIfStatement = function (stack, state, node) {\r\n            return this.stepConditionalExpression(stack, state, node);\r\n        };\r\n        Interpreter.prototype.stepLabeledStatement = function (stack, state, node) {\r\n            // No need to hit this node again on the way back up the stack.\r\n            stack.pop();\r\n            // Note that a statement might have multiple labels.\r\n            var labels = state.labels || [];\r\n            labels.push(node['label']['name']);\r\n            var nextState = new Interpreter.MyState(node['body'], state.scope);\r\n            nextState.labels = labels;\r\n            return nextState;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepLiteral = function (stack, state, node) {\r\n            stack.pop();\r\n            var value = node['value'];\r\n            if (value instanceof RegExp) {\r\n                var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\r\n                this.populateRegExp(pseudoRegexp, value);\r\n                value = pseudoRegexp;\r\n            }\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepLogicalExpression = function (stack, state, node) {\r\n            if (node['operator'] !== '&&' && node['operator'] !== '||') {\r\n                throw SyntaxError('Unknown logical operator: ' + node['operator']);\r\n            }\r\n            if (!state.doneLeft_) {\r\n                state.doneLeft_ = true;\r\n                return new Interpreter.MyState(node['left'], state.scope);\r\n            }\r\n            if (!state.doneRight_) {\r\n                if ((node['operator'] === '&&' && !state.value) ||\r\n                    (node['operator'] === '||' && state.value)) {\r\n                    // Shortcut evaluation.\r\n                    stack.pop();\r\n                    stack[stack.length - 1].value = state.value;\r\n                }\r\n                else {\r\n                    state.doneRight_ = true;\r\n                    return new Interpreter.MyState(node['right'], state.scope);\r\n                }\r\n            }\r\n            else {\r\n                stack.pop();\r\n                stack[stack.length - 1].value = state.value;\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepMemberExpression = function (stack, state, node) {\r\n            if (!state.doneObject_) {\r\n                state.doneObject_ = true;\r\n                return new Interpreter.MyState(node['object'], state.scope);\r\n            }\r\n            var propName;\r\n            if (!node['computed']) {\r\n                state.object_ = state.value;\r\n                // obj.foo -- Just access 'foo' directly.\r\n                propName = node['property']['name'];\r\n            }\r\n            else if (!state.doneProperty_) {\r\n                state.object_ = state.value;\r\n                // obj[foo] -- Compute value of 'foo'.\r\n                state.doneProperty_ = true;\r\n                return new Interpreter.MyState(node['property'], state.scope);\r\n            }\r\n            else {\r\n                propName = state.value;\r\n            }\r\n            stack.pop();\r\n            if (state.components) {\r\n                stack[stack.length - 1].value = [state.object_, propName];\r\n            }\r\n            else {\r\n                var value = this.getProperty(state.object_, propName);\r\n                if (value && typeof value === 'object' && value.isGetter) {\r\n                    // Clear the getter flag and call the getter function.\r\n                    value.isGetter = false;\r\n                    var func = (value);\r\n                    return this.createGetter_(func, state.object_);\r\n                }\r\n                stack[stack.length - 1].value = value;\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepNewExpression = function (stack, state, node) {\r\n            return this.stepCallExpression(stack, state, node);\r\n        };\r\n        Interpreter.prototype.stepObjectExpression = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var property = node['properties'][n];\r\n            if (!state.object_) {\r\n                // First execution.\r\n                state.object_ = this.createObjectProto(this.OBJECT_PROTO);\r\n                state.properties_ = Object.create(null);\r\n            }\r\n            else {\r\n                // Determine property name.\r\n                var key = property['key'];\r\n                if (key['type'] === 'Identifier') {\r\n                    var propName = key['name'];\r\n                }\r\n                else if (key['type'] === 'Literal') {\r\n                    var propName = key['value'];\r\n                }\r\n                else {\r\n                    throw SyntaxError('Unknown object structure: ' + key['type']);\r\n                }\r\n                // Set the property computed in the previous execution.\r\n                if (!state.properties_[propName]) {\r\n                    // Create temp object to collect value, getter, and/or setter.\r\n                    state.properties_[propName] = {};\r\n                }\r\n                state.properties_[propName][property['kind']] = state.value;\r\n                state.n_ = ++n;\r\n                property = node['properties'][n];\r\n            }\r\n            if (property) {\r\n                return new Interpreter.MyState(property['value'], state.scope);\r\n            }\r\n            for (var key in state.properties_) {\r\n                var kinds = state.properties_[key];\r\n                if ('get' in kinds || 'set' in kinds) {\r\n                    // Set a property with a getter or setter.\r\n                    var descriptor = {\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        get: kinds['get'],\r\n                        set: kinds['set']\r\n                    };\r\n                    this.setProperty(state.object_, key, null, descriptor);\r\n                }\r\n                else {\r\n                    // Set a normal property with a value.\r\n                    this.setProperty(state.object_, key, kinds['init']);\r\n                }\r\n            }\r\n            stack.pop();\r\n            stack[stack.length - 1].value = state.object_;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepProgram = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var expression = node['body'][n];\r\n            if (expression) {\r\n                state.done = false;\r\n                state.n_ = n + 1;\r\n                return new Interpreter.MyState(expression, state.scope);\r\n            }\r\n            state.done = true;\r\n            // Don't pop the stateStack.\r\n            // Leave the root scope on the tree in case the program is appended to.\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepReturnStatement = function (stack, state, node) {\r\n            if (node['argument'] && !state.done_) {\r\n                state.done_ = true;\r\n                return new Interpreter.MyState(node['argument'], state.scope);\r\n            }\r\n            var value = state.value;\r\n            var i = stack.length - 1;\r\n            state = stack[i];\r\n            while (state.node['type'] !== 'CallExpression' &&\r\n                state.node['type'] !== 'NewExpression') {\r\n                if (state.node['type'] !== 'TryStatement') {\r\n                    stack.splice(i, 1);\r\n                }\r\n                i--;\r\n                if (i < 0) {\r\n                    // Syntax error, do not allow this error to be trapped.\r\n                    throw SyntaxError('Illegal return statement');\r\n                }\r\n                state = stack[i];\r\n            }\r\n            state.value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepSequenceExpression = function (stack, state, node) {\r\n            var n = state.n_ || 0;\r\n            var expression = node['expressions'][n];\r\n            if (expression) {\r\n                state.n_ = n + 1;\r\n                return new Interpreter.MyState(expression, state.scope);\r\n            }\r\n            stack.pop();\r\n            stack[stack.length - 1].value = state.value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepSwitchStatement = function (stack, state, node) {\r\n            if (!state.test_) {\r\n                state.test_ = 1;\r\n                return new Interpreter.MyState(node['discriminant'], state.scope);\r\n            }\r\n            if (state.test_ === 1) {\r\n                state.test_ = 2;\r\n                // Preserve switch value between case tests.\r\n                state.switchValue_ = state.value;\r\n            }\r\n            while (true) {\r\n                var index = state.index_ || 0;\r\n                var switchCase = node['cases'][index];\r\n                if (!state.matched_ && switchCase && !switchCase['test']) {\r\n                    // Test on the default case is null.\r\n                    // Bypass (but store) the default case, and get back to it later.\r\n                    state.defaultCase_ = index;\r\n                    state.index_ = index + 1;\r\n                    continue;\r\n                }\r\n                if (!switchCase && !state.matched_ && state.defaultCase_) {\r\n                    // Ran through all cases, no match.  Jump to the default.\r\n                    state.matched_ = true;\r\n                    state.index_ = state.defaultCase_;\r\n                    continue;\r\n                }\r\n                if (switchCase) {\r\n                    if (!state.matched_ && !state.tested_ && switchCase['test']) {\r\n                        state.tested_ = true;\r\n                        return new Interpreter.MyState(switchCase['test'], state.scope);\r\n                    }\r\n                    if (state.matched_ || state.value === state.switchValue_) {\r\n                        state.matched_ = true;\r\n                        var n = state.n_ || 0;\r\n                        if (switchCase['consequent'][n]) {\r\n                            state.isSwitch = true;\r\n                            state.n_ = n + 1;\r\n                            return new Interpreter.MyState(switchCase['consequent'][n], state.scope);\r\n                        }\r\n                    }\r\n                    // Move on to next case.\r\n                    state.tested_ = false;\r\n                    state.n_ = 0;\r\n                    state.index_ = index + 1;\r\n                }\r\n                else {\r\n                    stack.pop();\r\n                    return;\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepThisExpression = function (stack, state, node) {\r\n            stack.pop();\r\n            stack[stack.length - 1].value = this.getValueFromScope('this');\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepThrowStatement = function (stack, state, node) {\r\n            if (!state.done_) {\r\n                state.done_ = true;\r\n                return new Interpreter.MyState(node['argument'], state.scope);\r\n            }\r\n            else {\r\n                this.throwException(state.value);\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepTryStatement = function (stack, state, node) {\r\n            if (!state.doneBlock_) {\r\n                state.doneBlock_ = true;\r\n                return new Interpreter.MyState(node['block'], state.scope);\r\n            }\r\n            if (state.throwValue && !state.doneHandler_ && node['handler']) {\r\n                state.doneHandler_ = true;\r\n                var nextState = new Interpreter.MyState(node['handler'], state.scope);\r\n                nextState.throwValue = state.throwValue;\r\n                state.throwValue = null; // This error has been handled, don't rethrow.\r\n                return nextState;\r\n            }\r\n            if (!state.doneFinalizer_ && node['finalizer']) {\r\n                state.doneFinalizer_ = true;\r\n                return new Interpreter.MyState(node['finalizer'], state.scope);\r\n            }\r\n            if (state.throwValue) {\r\n                // There was no catch handler, or the catch/finally threw an error.\r\n                // Throw the error up to a higher try.\r\n                this.executeException(state.throwValue);\r\n            }\r\n            else {\r\n                stack.pop();\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepUnaryExpression = function (stack, state, node) {\r\n            if (!state.done_) {\r\n                state.done_ = true;\r\n                var nextState = new Interpreter.MyState(node['argument'], state.scope);\r\n                nextState.components = node['operator'] === 'delete';\r\n                return nextState;\r\n            }\r\n            stack.pop();\r\n            var value = state.value;\r\n            if (node['operator'] === '-') {\r\n                value = -value;\r\n            }\r\n            else if (node['operator'] === '+') {\r\n                value = +value;\r\n            }\r\n            else if (node['operator'] === '!') {\r\n                value = !value;\r\n            }\r\n            else if (node['operator'] === '~') {\r\n                value = ~value;\r\n            }\r\n            else if (node['operator'] === 'delete') {\r\n                var result = true;\r\n                // If value is not an array, then it is a primitive, or some other value.\r\n                // If so, skip the delete and return true.\r\n                if (Array.isArray(value)) {\r\n                    var obj = value[0];\r\n                    if (obj === Interpreter.SCOPE_REFERENCE) {\r\n                        // 'delete foo;' is the same as 'delete window.foo'.\r\n                        obj = state.scope;\r\n                    }\r\n                    var name = String(value[1]);\r\n                    try {\r\n                        delete obj.properties[name];\r\n                    }\r\n                    catch (e) {\r\n                        if (state.scope.strict) {\r\n                            this.throwException(this.TYPE_ERROR, \"Cannot delete property '\" +\r\n                                name + \"' of '\" + obj + \"'\");\r\n                        }\r\n                        else {\r\n                            result = false;\r\n                        }\r\n                    }\r\n                }\r\n                value = result;\r\n            }\r\n            else if (node['operator'] === 'typeof') {\r\n                value = (value && value.class === 'Function') ? 'function' : typeof value;\r\n            }\r\n            else if (node['operator'] === 'void') {\r\n                value = undefined;\r\n            }\r\n            else {\r\n                throw SyntaxError('Unknown unary operator: ' + node['operator']);\r\n            }\r\n            stack[stack.length - 1].value = value;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepUpdateExpression = function (stack, state, node) {\r\n            if (!state.doneLeft_) {\r\n                state.doneLeft_ = true;\r\n                var nextState = new Interpreter.MyState(node['argument'], state.scope);\r\n                nextState.components = true;\r\n                return nextState;\r\n            }\r\n            if (!state.leftSide_) {\r\n                state.leftSide_ = state.value;\r\n            }\r\n            if (state.doneGetter_) {\r\n                state.leftValue_ = state.value;\r\n            }\r\n            if (!state.doneGetter_) {\r\n                var leftValue = this.getValue(state.leftSide_);\r\n                state.leftValue_ = leftValue;\r\n                if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\r\n                    // Clear the getter flag and call the getter function.\r\n                    leftValue.isGetter = false;\r\n                    state.doneGetter_ = true;\r\n                    var func = (leftValue);\r\n                    return this.createGetter_(func, state.leftSide_);\r\n                }\r\n            }\r\n            if (state.doneSetter_) {\r\n                // Return if setter function.\r\n                // Setter method on property has completed.\r\n                // Ignore its return value, and use the original set value instead.\r\n                stack.pop();\r\n                stack[stack.length - 1].value = state.doneSetter_;\r\n                return;\r\n            }\r\n            leftValue = Number(state.leftValue_);\r\n            var changeValue;\r\n            if (node['operator'] === '++') {\r\n                changeValue = leftValue + 1;\r\n            }\r\n            else if (node['operator'] === '--') {\r\n                changeValue = leftValue - 1;\r\n            }\r\n            else {\r\n                throw SyntaxError('Unknown update expression: ' + node['operator']);\r\n            }\r\n            var returnValue = node['prefix'] ? changeValue : leftValue;\r\n            var setter = this.setValue(state.leftSide_, changeValue);\r\n            if (setter) {\r\n                state.doneSetter_ = returnValue;\r\n                return this.createSetter_(setter, state.leftSide_, changeValue);\r\n            }\r\n            // Return if no setter function.\r\n            stack.pop();\r\n            stack[stack.length - 1].value = returnValue;\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepVariableDeclaration = function (stack, state, node) {\r\n            var declarations = node['declarations'];\r\n            var n = state.n_ || 0;\r\n            var declarationNode = declarations[n];\r\n            if (state.init_ && declarationNode) {\r\n                // This setValue call never needs to deal with calling a setter function.\r\n                // Note that this is setting the init value, not defining the variable.\r\n                // Variable definition is done when scope is populated.\r\n                this.setValueToScope(declarationNode['id']['name'], state.value);\r\n                state.init_ = false;\r\n                declarationNode = declarations[++n];\r\n            }\r\n            while (declarationNode) {\r\n                // Skip any declarations that are not initialized.  They have already\r\n                // been defined as undefined in populateScope_.\r\n                if (declarationNode['init']) {\r\n                    state.n_ = n;\r\n                    state.init_ = true;\r\n                    return new Interpreter.MyState(declarationNode['init'], state.scope);\r\n                }\r\n                declarationNode = declarations[++n];\r\n            }\r\n            stack.pop();\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepWithStatement = function (stack, state, node) {\r\n            if (!state.doneObject_) {\r\n                state.doneObject_ = true;\r\n                return new Interpreter.MyState(node['object'], state.scope);\r\n            }\r\n            else if (!state.doneBody_) {\r\n                state.doneBody_ = true;\r\n                var scope = this.createSpecialScope(state.scope, state.value);\r\n                return new Interpreter.MyState(node['body'], scope);\r\n            }\r\n            else {\r\n                stack.pop();\r\n            }\r\n        };\r\n        ;\r\n        Interpreter.prototype.stepWhileStatement = function (stack, state, node) {\r\n            return this.stepDoWhileStatement(stack, state, node);\r\n        };\r\n        /**\r\n         * @const {!Object} Configuration used for all Acorn parsing.\r\n         */\r\n        Interpreter.PARSE_OPTIONS = {\r\n            ecmaVersion: 5\r\n        };\r\n        /**\r\n         * Property descriptor of readonly properties.\r\n         */\r\n        Interpreter.READONLY_DESCRIPTOR = {\r\n            configurable: true,\r\n            enumerable: true,\r\n            writable: false\r\n        };\r\n        /**\r\n         * Property descriptor of non-enumerable properties.\r\n         */\r\n        Interpreter.NONENUMERABLE_DESCRIPTOR = {\r\n            configurable: true,\r\n            enumerable: false,\r\n            writable: true\r\n        };\r\n        /**\r\n         * Property descriptor of readonly, non-enumerable properties.\r\n         */\r\n        Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR = {\r\n            configurable: true,\r\n            enumerable: false,\r\n            writable: false\r\n        };\r\n        /**\r\n         * Property descriptor of variables.\r\n         */\r\n        Interpreter.VARIABLE_DESCRIPTOR = {\r\n            configurable: false,\r\n            enumerable: true,\r\n            writable: true\r\n        };\r\n        /**\r\n         * Unique symbol for indicating that a step has encountered an error, has\r\n         * added it to the stack, and will be thrown within the user's program.\r\n         * When STEP_ERROR is thrown in the JS-Interpreter, the error can be ignored.\r\n         */\r\n        Interpreter.STEP_ERROR = {};\r\n        /**\r\n         * Unique symbol for indicating that a reference is a variable on the scope,\r\n         * not an object property.\r\n         */\r\n        Interpreter.SCOPE_REFERENCE = {};\r\n        /**\r\n         * For cycle detection in array to string and error conversion;\r\n         * see spec bug github.com/tc39/ecma262/issues/289\r\n         * Since this is for atomic actions only, it can be a class property.\r\n         */\r\n        Interpreter.toStringCycles_ = [];\r\n        return Interpreter;\r\n    }());\r\n    (function (Interpreter) {\r\n        /**\r\n         * Class for an object.\r\n         * @param {Interpreter.MyObject} proto Prototype object or null.\r\n         * @constructor\r\n         */\r\n        var MyObject = (function () {\r\n            function MyObject(proto) {\r\n                /** @type {Interpreter.MyObject} */\r\n                this.proto = null;\r\n                /** @type {boolean} */\r\n                this.isObject = true;\r\n                /** @type {string} */\r\n                this.class = 'Object';\r\n                /** @type {Date|RegExp|boolean|number|string|undefined|null} */\r\n                this.data = null;\r\n                this.getter = Object.create(null);\r\n                this.setter = Object.create(null);\r\n                this.properties = Object.create(null);\r\n                this.proto = proto;\r\n            }\r\n            /**\r\n             * Convert this object into a string.\r\n             * @return {string} String value.\r\n             * @override\r\n             */\r\n            MyObject.prototype.toString = function () {\r\n                if (this.class === 'Array') {\r\n                    // Array\r\n                    var cycles = Interpreter.toStringCycles_;\r\n                    cycles.push(this);\r\n                    try {\r\n                        var strs = [];\r\n                        for (var i = 0; i < this.properties.length; i++) {\r\n                            var value = this.properties[i];\r\n                            strs[i] = (value && value.isObject && cycles.indexOf(value) !== -1) ?\r\n                                '...' : value;\r\n                        }\r\n                    }\r\n                    finally {\r\n                        cycles.pop();\r\n                    }\r\n                    return strs.join(',');\r\n                }\r\n                if (this.class === 'Error') {\r\n                    var cycles = Interpreter.toStringCycles_;\r\n                    if (cycles.indexOf(this) !== -1) {\r\n                        return '[object Error]';\r\n                    }\r\n                    var name, message;\r\n                    // Bug: Does not support getters and setters for name or message.\r\n                    var obj = this;\r\n                    do {\r\n                        if ('name' in obj.properties) {\r\n                            name = obj.properties['name'];\r\n                            break;\r\n                        }\r\n                    } while ((obj = obj.proto));\r\n                    var obj = this;\r\n                    do {\r\n                        if ('message' in obj.properties) {\r\n                            message = obj.properties['message'];\r\n                            break;\r\n                        }\r\n                    } while ((obj = obj.proto));\r\n                    cycles.push(this);\r\n                    try {\r\n                        name = name && name.toString();\r\n                        message = message && message.toString();\r\n                    }\r\n                    finally {\r\n                        cycles.pop();\r\n                    }\r\n                    return message ? name + ': ' + message : String(name);\r\n                }\r\n                // RegExp, Date, and boxed primitives.\r\n                if (this.data !== null) {\r\n                    return String(this.data);\r\n                }\r\n                return '[object ' + this.class + ']';\r\n            };\r\n            /**\r\n             * Return the object's value.\r\n             * @return {Interpreter.MyValue} Value.\r\n             * @override\r\n             */\r\n            MyObject.prototype.valueOf = function () {\r\n                if (this.data === undefined || this.data === null ||\r\n                    this.data instanceof RegExp) {\r\n                    return this; // An Object.\r\n                }\r\n                if (this.data instanceof Date) {\r\n                    return this.data.valueOf(); // Milliseconds.\r\n                }\r\n                return (this.data); // Boxed primitive.\r\n            };\r\n            return MyObject;\r\n        }());\r\n        Interpreter.MyObject = MyObject;\r\n        /**\r\n         * Class for a state.\r\n         * @param {!MyObject} node AST node for the state.\r\n         * @param {!Interpreter.MyObject} scope Scope object for the state.\r\n         * @constructor\r\n         */\r\n        var MyState = (function () {\r\n            function MyState(node, scope) {\r\n                this.node = node;\r\n                this.scope = scope;\r\n            }\r\n            return MyState;\r\n        }());\r\n        Interpreter.MyState = MyState;\r\n    })(Interpreter || (Interpreter = {}));\r\n    // These lines are added for API compatibility\r\n    Interpreter['Object'] = Interpreter.MyObject;\r\n    Interpreter['State'] = Interpreter.MyState;\r\n    // Look for globally-defined acorn\r\n    try {\r\n        Interpreter.acorn = (self || global)['acorn'];\r\n    }\r\n    catch (e) {\r\n        // do nothing if we fail\r\n    }\r\n    return Interpreter;\r\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/acorn_interpreter.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 44c24c04f6b41a07e54d","import acorn = require('./acorn');\r\nimport Interpreter = require('./interpreter');\r\n\r\n/*!\r\n * @license\r\n * JavaScript Interpreter bundled with acorn v0.4.1\r\n *\r\n * Copyright 2013-2017 Google Inc. and Jun Kato\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nInterpreter.acorn = acorn;\r\nexport = Interpreter;\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib/acorn_interpreter.ts","// Acorn is a tiny, fast JavaScript parser written in JavaScript.\r\n//\r\n// Acorn was written by Marijn Haverbeke and released under an MIT\r\n// license. The Unicode regexps (for identifiers and whitespace) were\r\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\r\n//\r\n// Git repositories for Acorn are available at\r\n//\r\n//     http://marijnhaverbeke.nl/git/acorn\r\n//     https://github.com/marijnh/acorn.git\r\n//\r\n// Please use the [github bug tracker][ghbt] to report issues.\r\n//\r\n// [ghbt]: https://github.com/marijnh/acorn/issues\r\n//\r\n// This file defines the main parser interface. The library also comes\r\n// with a [error-tolerant parser][dammit] and an\r\n// [abstract syntax tree walker][walk], defined in other files.\r\n//\r\n// [dammit]: acorn_loose.js\r\n// [walk]: util/walk.js\r\n\r\n(function(root, mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports); // CommonJS\r\n  if (typeof define == \"function\" && define.amd) return define([\"exports\"], mod); // AMD\r\n  mod(root.acorn || (root.acorn = {})); // Plain browser env\r\n})(this, function(exports) {\r\n  \"use strict\";\r\n\r\n  exports.version = \"0.4.1\";\r\n\r\n  // The main exported interface (under `self.acorn` when in the\r\n  // browser) is a `parse` function that takes a code string and\r\n  // returns an abstract syntax tree as specified by [Mozilla parser\r\n  // API][api], with the caveat that the SpiderMonkey-specific syntax\r\n  // (`let`, `yield`, inline XML, etc) is not recognized.\r\n  //\r\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\r\n\r\n  var options, input, inputLen, sourceFile;\r\n\r\n  exports.parse = function(inpt, opts) {\r\n    input = String(inpt); inputLen = input.length;\r\n    setOptions(opts);\r\n    initTokenState();\r\n    return parseTopLevel(options.program);\r\n  };\r\n\r\n  // A second optional argument can be given to further configure\r\n  // the parser process. These options are recognized:\r\n\r\n  var defaultOptions = exports.defaultOptions = {\r\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\r\n    // be either 3 or 5. This\r\n    // influences support for strict mode, the set of reserved words, and\r\n    // support for getters and setter.\r\n    ecmaVersion: 5,\r\n    // Turn on `strictSemicolons` to prevent the parser from doing\r\n    // automatic semicolon insertion.\r\n    strictSemicolons: false,\r\n    // When `allowTrailingCommas` is false, the parser will not allow\r\n    // trailing commas in array and object literals.\r\n    allowTrailingCommas: true,\r\n    // By default, reserved words are not enforced. Enable\r\n    // `forbidReserved` to enforce them.\r\n    forbidReserved: false,\r\n    // When `locations` is on, `loc` properties holding objects with\r\n    // `start` and `end` properties in `{line, column}` form (with\r\n    // line being 1-based and column 0-based) will be attached to the\r\n    // nodes.\r\n    locations: false,\r\n    // A function can be passed as `onComment` option, which will\r\n    // cause Acorn to call that function with `(block, text, start,\r\n    // end)` parameters whenever a comment is skipped. `block` is a\r\n    // boolean indicating whether this is a block (`/* */`) comment,\r\n    // `text` is the content of the comment, and `start` and `end` are\r\n    // character offsets that denote the start and end of the comment.\r\n    // When the `locations` option is on, two more parameters are\r\n    // passed, the full `{line, column}` locations of the start and\r\n    // end of the comments.\r\n    onComment: null,\r\n    // Nodes have their start and end characters offsets recorded in\r\n    // `start` and `end` properties (directly on the node, rather than\r\n    // the `loc` object, which holds line/column data. To also add a\r\n    // [semi-standardized][range] `range` property holding a `[start,\r\n    // end]` array with the same numbers, set the `ranges` option to\r\n    // `true`.\r\n    //\r\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\r\n    ranges: false,\r\n    // It is possible to parse multiple files into a single AST by\r\n    // passing the tree produced by parsing the first file as\r\n    // `program` option in subsequent parses. This will add the\r\n    // toplevel forms of the parsed file to the `Program` (top) node\r\n    // of an existing parse tree.\r\n    program: null,\r\n    // When `location` is on, you can pass this to record the source\r\n    // file in every node's `loc` object.\r\n    sourceFile: null,\r\n    // This value, if given, is stored in every node, whether\r\n    // `location` is on or off.\r\n    directSourceFile: null\r\n  };\r\n\r\n  function setOptions(opts) {\r\n    options = opts || {};\r\n    for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\r\n      options[opt] = defaultOptions[opt];\r\n    sourceFile = options.sourceFile || null;\r\n  }\r\n\r\n  // The `getLineInfo` function is mostly useful when the\r\n  // `locations` option is off (for performance reasons) and you\r\n  // want to find the line/column position for a given character\r\n  // offset. `input` should be the code string that the offset refers\r\n  // into.\r\n\r\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\r\n    for (var line = 1, cur = 0;;) {\r\n      lineBreak.lastIndex = cur;\r\n      var match = lineBreak.exec(input);\r\n      if (match && match.index < offset) {\r\n        ++line;\r\n        cur = match.index + match[0].length;\r\n      } else break;\r\n    }\r\n    return {line: line, column: offset - cur};\r\n  };\r\n\r\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\r\n  // The `tokenize` export provides an interface to the tokenizer.\r\n  // Because the tokenizer is optimized for being efficiently used by\r\n  // the Acorn parser itself, this interface is somewhat crude and not\r\n  // very modular. Performing another parse or call to `tokenize` will\r\n  // reset the internal state, and invalidate existing tokenizers.\r\n\r\n  exports.tokenize = function(inpt, opts) {\r\n    input = String(inpt); inputLen = input.length;\r\n    setOptions(opts);\r\n    initTokenState();\r\n\r\n    var t = {};\r\n    function getToken(forceRegexp) {\r\n      readToken(forceRegexp);\r\n      t.start = tokStart; t.end = tokEnd;\r\n      t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\r\n      t.type = tokType; t.value = tokVal;\r\n      return t;\r\n    }\r\n    getToken.jumpTo = function(pos, reAllowed) {\r\n      tokPos = pos;\r\n      if (options.locations) {\r\n        tokCurLine = 1;\r\n        tokLineStart = lineBreak.lastIndex = 0;\r\n        var match;\r\n        while ((match = lineBreak.exec(input)) && match.index < pos) {\r\n          ++tokCurLine;\r\n          tokLineStart = match.index + match[0].length;\r\n        }\r\n      }\r\n      tokRegexpAllowed = reAllowed;\r\n      skipSpace();\r\n    };\r\n    return getToken;\r\n  };\r\n\r\n  // State is kept in (closure-)global variables. We already saw the\r\n  // `options`, `input`, and `inputLen` variables above.\r\n\r\n  // The current position of the tokenizer in the input.\r\n\r\n  var tokPos;\r\n\r\n  // The start and end offsets of the current token.\r\n\r\n  var tokStart, tokEnd;\r\n\r\n  // When `options.locations` is true, these hold objects\r\n  // containing the tokens start and end line/column pairs.\r\n\r\n  var tokStartLoc, tokEndLoc;\r\n\r\n  // The type and value of the current token. Token types are objects,\r\n  // named by variables against which they can be compared, and\r\n  // holding properties that describe them (indicating, for example,\r\n  // the precedence of an infix operator, and the original name of a\r\n  // keyword token). The kind of value that's held in `tokVal` depends\r\n  // on the type of the token. For literals, it is the literal value,\r\n  // for operators, the operator name, and so on.\r\n\r\n  var tokType, tokVal;\r\n\r\n  // Interal state for the tokenizer. To distinguish between division\r\n  // operators and regular expressions, it remembers whether the last\r\n  // token was one that is allowed to be followed by an expression.\r\n  // (If it is, a slash is probably a regexp, if it isn't it's a\r\n  // division operator. See the `parseStatement` function for a\r\n  // caveat.)\r\n\r\n  var tokRegexpAllowed;\r\n\r\n  // When `options.locations` is true, these are used to keep\r\n  // track of the current line, and know when a new line has been\r\n  // entered.\r\n\r\n  var tokCurLine, tokLineStart;\r\n\r\n  // These store the position of the previous token, which is useful\r\n  // when finishing a node and assigning its `end` position.\r\n\r\n  var lastStart, lastEnd, lastEndLoc;\r\n\r\n  // This is the parser's state. `inFunction` is used to reject\r\n  // `return` statements outside of functions, `labels` to verify that\r\n  // `break` and `continue` have somewhere to jump to, and `strict`\r\n  // indicates whether strict mode is on.\r\n\r\n  var inFunction, labels, strict;\r\n\r\n  // This function is used to raise exceptions on parse errors. It\r\n  // takes an offset integer (into the current `input`) to indicate\r\n  // the location of the error, attaches the position to the end\r\n  // of the error message, and then raises a `SyntaxError` with that\r\n  // message.\r\n\r\n  function raise(pos, message) {\r\n    var loc = getLineInfo(input, pos);\r\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\r\n    var err = new SyntaxError(message);\r\n    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;\r\n    throw err;\r\n  }\r\n\r\n  // Reused empty array added for node fields that are always empty.\r\n\r\n  var empty = [];\r\n\r\n  // ## Token types\r\n\r\n  // The assignment of fine-grained, information-carrying type objects\r\n  // allows the tokenizer to store the information it has about a\r\n  // token in a way that is very cheap for the parser to look up.\r\n\r\n  // All token type variables start with an underscore, to make them\r\n  // easy to recognize.\r\n\r\n  // These are the general types. The `type` property is only used to\r\n  // make them recognizeable when debugging.\r\n\r\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\r\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\r\n\r\n  // Keyword tokens. The `keyword` property (also used in keyword-like\r\n  // operators) indicates that the token originated from an\r\n  // identifier-like word, which is used when parsing property names.\r\n  //\r\n  // The `beforeExpr` property is used to disambiguate between regular\r\n  // expressions and divisions. It is set on all token types that can\r\n  // be followed by an expression (thus, a slash after them would be a\r\n  // regular expression).\r\n  //\r\n  // `isLoop` marks a keyword as starting a loop, which is important\r\n  // to know when parsing a label, in order to allow or disallow\r\n  // continue jumps to that label.\r\n\r\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\r\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\r\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\r\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\r\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\r\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\r\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\r\n  var _this = {keyword: \"this\"};\r\n\r\n  // The keywords that denote values.\r\n\r\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\r\n  var _false = {keyword: \"false\", atomValue: false};\r\n\r\n  // Some keywords are treated as regular operators. `in` sometimes\r\n  // (when parsing `for`) needs to be tested against specifically, so\r\n  // we assign a variable name to it for quick comparing.\r\n\r\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\r\n\r\n  // Map keyword names to token types.\r\n\r\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\r\n                      \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\r\n                      \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\r\n                      \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\r\n                      \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\r\n                      \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\r\n                      \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\r\n                      \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\r\n                      \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\r\n                      \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\r\n\r\n  // Punctuation token types. Again, the `type` property is purely for debugging.\r\n\r\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\r\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\r\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\r\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\r\n\r\n  // Operators. These carry several kinds of properties to help the\r\n  // parser use them properly (the presence of these properties is\r\n  // what categorizes them as operators).\r\n  //\r\n  // `binop`, when present, specifies that this operator is a binary\r\n  // operator, and will refer to its precedence.\r\n  //\r\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\r\n  // unary operator. `isUpdate` specifies that the node produced by\r\n  // the operator should be of type UpdateExpression rather than\r\n  // simply UnaryExpression (`++` and `--`).\r\n  //\r\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\r\n  // binary operators with a very low precedence, that should result\r\n  // in AssignmentExpression nodes.\r\n\r\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\r\n  var _assign = {isAssign: true, beforeExpr: true};\r\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\r\n  var _logicalOR = {binop: 1, beforeExpr: true};\r\n  var _logicalAND = {binop: 2, beforeExpr: true};\r\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\r\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\r\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\r\n  var _equality = {binop: 6, beforeExpr: true};\r\n  var _relational = {binop: 7, beforeExpr: true};\r\n  var _bitShift = {binop: 8, beforeExpr: true};\r\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\r\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\r\n\r\n  // Provide access to the token types for external users of the\r\n  // tokenizer.\r\n\r\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\r\n                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\r\n                      dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\r\n                      num: _num, regexp: _regexp, string: _string};\r\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\r\n\r\n  // This is a trick taken from Esprima. It turns out that, on\r\n  // non-Chrome browsers, to check whether a string is in a set, a\r\n  // predicate containing a big ugly `switch` statement is faster than\r\n  // a regular expression, and on Chrome the two are about on par.\r\n  // This function uses `eval` (non-lexical) to produce such a\r\n  // predicate from a space-separated string of words.\r\n  //\r\n  // It starts by sorting the words by length.\r\n\r\n  function makePredicate(words) {\r\n    words = words.split(\" \");\r\n    var f = \"\", cats = [];\r\n    out: for (var i = 0; i < words.length; ++i) {\r\n      for (var j = 0; j < cats.length; ++j)\r\n        if (cats[j][0].length == words[i].length) {\r\n          cats[j].push(words[i]);\r\n          continue out;\r\n        }\r\n      cats.push([words[i]]);\r\n    }\r\n    function compareTo(arr) {\r\n      if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\r\n      f += \"switch(str){\";\r\n      for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\r\n      f += \"return true}return false;\";\r\n    }\r\n\r\n    // When there are more than three length categories, an outer\r\n    // switch first dispatches on the lengths, to save on comparisons.\r\n\r\n    if (cats.length > 3) {\r\n      cats.sort(function(a, b) {return b.length - a.length;});\r\n      f += \"switch(str.length){\";\r\n      for (var i = 0; i < cats.length; ++i) {\r\n        var cat = cats[i];\r\n        f += \"case \" + cat[0].length + \":\";\r\n        compareTo(cat);\r\n      }\r\n      f += \"}\";\r\n\r\n    // Otherwise, simply generate a flat `switch` statement.\r\n\r\n    } else {\r\n      compareTo(words);\r\n    }\r\n    return new Function(\"str\", f);\r\n  }\r\n\r\n  // The ECMAScript 3 reserved word list.\r\n\r\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\r\n\r\n  // ECMAScript 5 reserved words.\r\n\r\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\r\n\r\n  // The additional reserved words in strict mode.\r\n\r\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\r\n\r\n  // The forbidden variable names in strict mode.\r\n\r\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\r\n\r\n  // And the keywords.\r\n\r\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\r\n\r\n  // ## Character categories\r\n\r\n  // Big ugly regular expressions that match characters in the\r\n  // whitespace, identifier, and identifier-start categories. These\r\n  // are only applied when a character is found to actually have a\r\n  // code point above 128.\r\n\r\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\r\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\r\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\r\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\r\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\r\n\r\n  // Whether a single character denotes a newline.\r\n\r\n  var newline = /[\\n\\r\\u2028\\u2029]/;\r\n\r\n  // Matches a whole line break (where CRLF is considered a single\r\n  // line break). Used to count lines.\r\n\r\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\r\n\r\n  // Test whether a given character code starts an identifier.\r\n\r\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\r\n    if (code < 65) return code === 36;\r\n    if (code < 91) return true;\r\n    if (code < 97) return code === 95;\r\n    if (code < 123)return true;\r\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\r\n  };\r\n\r\n  // Test whether a given character is part of an identifier.\r\n\r\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\r\n    if (code < 48) return code === 36;\r\n    if (code < 58) return true;\r\n    if (code < 65) return false;\r\n    if (code < 91) return true;\r\n    if (code < 97) return code === 95;\r\n    if (code < 123)return true;\r\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\r\n  };\r\n\r\n  // ## Tokenizer\r\n\r\n  // These are used when `options.locations` is on, for the\r\n  // `tokStartLoc` and `tokEndLoc` properties.\r\n\r\n  function line_loc_t() {\r\n    this.line = tokCurLine;\r\n    this.column = tokPos - tokLineStart;\r\n  }\r\n\r\n  // Reset the token state. Used at the start of a parse.\r\n\r\n  function initTokenState() {\r\n    tokCurLine = 1;\r\n    tokPos = tokLineStart = 0;\r\n    tokRegexpAllowed = true;\r\n    skipSpace();\r\n  }\r\n\r\n  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and\r\n  // `tokRegexpAllowed`, and skips the space after the token, so that\r\n  // the next one's `tokStart` will point at the right position.\r\n\r\n  function finishToken(type, val) {\r\n    tokEnd = tokPos;\r\n    if (options.locations) tokEndLoc = new line_loc_t;\r\n    tokType = type;\r\n    skipSpace();\r\n    tokVal = val;\r\n    tokRegexpAllowed = type.beforeExpr;\r\n  }\r\n\r\n  function skipBlockComment() {\r\n    var startLoc = options.onComment && options.locations && new line_loc_t;\r\n    var start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\r\n    if (end === -1) raise(tokPos - 2, \"Unterminated comment\");\r\n    tokPos = end + 2;\r\n    if (options.locations) {\r\n      lineBreak.lastIndex = start;\r\n      var match;\r\n      while ((match = lineBreak.exec(input)) && match.index < tokPos) {\r\n        ++tokCurLine;\r\n        tokLineStart = match.index + match[0].length;\r\n      }\r\n    }\r\n    if (options.onComment)\r\n      options.onComment(true, input.slice(start + 2, end), start, tokPos,\r\n                        startLoc, options.locations && new line_loc_t);\r\n  }\r\n\r\n  function skipLineComment() {\r\n    var start = tokPos;\r\n    var startLoc = options.onComment && options.locations && new line_loc_t;\r\n    var ch = input.charCodeAt(tokPos+=2);\r\n    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\r\n      ++tokPos;\r\n      ch = input.charCodeAt(tokPos);\r\n    }\r\n    if (options.onComment)\r\n      options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\r\n                        startLoc, options.locations && new line_loc_t);\r\n  }\r\n\r\n  // Called at the start of the parse and after every token. Skips\r\n  // whitespace and comments, and.\r\n\r\n  function skipSpace() {\r\n    while (tokPos < inputLen) {\r\n      var ch = input.charCodeAt(tokPos);\r\n      if (ch === 32) { // ' '\r\n        ++tokPos;\r\n      } else if (ch === 13) {\r\n        ++tokPos;\r\n        var next = input.charCodeAt(tokPos);\r\n        if (next === 10) {\r\n          ++tokPos;\r\n        }\r\n        if (options.locations) {\r\n          ++tokCurLine;\r\n          tokLineStart = tokPos;\r\n        }\r\n      } else if (ch === 10 || ch === 8232 || ch === 8233) {\r\n        ++tokPos;\r\n        if (options.locations) {\r\n          ++tokCurLine;\r\n          tokLineStart = tokPos;\r\n        }\r\n      } else if (ch > 8 && ch < 14) {\r\n        ++tokPos;\r\n      } else if (ch === 47) { // '/'\r\n        var next = input.charCodeAt(tokPos + 1);\r\n        if (next === 42) { // '*'\r\n          skipBlockComment();\r\n        } else if (next === 47) { // '/'\r\n          skipLineComment();\r\n        } else break;\r\n      } else if (ch === 160) { // '\\xa0'\r\n        ++tokPos;\r\n      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\r\n        ++tokPos;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // ### Token reading\r\n\r\n  // This is the function that is called to fetch the next token. It\r\n  // is somewhat obscure, because it works in character codes rather\r\n  // than characters, and because operator parsing has been inlined\r\n  // into it.\r\n  //\r\n  // All in the name of speed.\r\n  //\r\n  // The `forceRegexp` parameter is used in the one case where the\r\n  // `tokRegexpAllowed` trick does not work. See `parseStatement`.\r\n\r\n  function readToken_dot() {\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next >= 48 && next <= 57) return readNumber(true);\r\n    ++tokPos;\r\n    return finishToken(_dot);\r\n  }\r\n\r\n  function readToken_slash() { // '/'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (tokRegexpAllowed) {++tokPos; return readRegexp();}\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(_slash, 1);\r\n  }\r\n\r\n  function readToken_mult_modulo() { // '%*'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(_multiplyModulo, 1);\r\n  }\r\n\r\n  function readToken_pipe_amp(code) { // '|&'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\r\n  }\r\n\r\n  function readToken_caret() { // '^'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(_bitwiseXOR, 1);\r\n  }\r\n\r\n  function readToken_plus_min(code) { // '+-'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === code) {\r\n      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\r\n          newline.test(input.slice(lastEnd, tokPos))) {\r\n        // A `-->` line comment\r\n        tokPos += 3;\r\n        skipLineComment();\r\n        skipSpace();\r\n        return readToken();\r\n      }\r\n      return finishOp(_incDec, 2);\r\n    }\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(_plusMin, 1);\r\n  }\r\n\r\n  function readToken_lt_gt(code) { // '<>'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    var size = 1;\r\n    if (next === code) {\r\n      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\r\n      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\r\n      return finishOp(_bitShift, size);\r\n    }\r\n    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\r\n        input.charCodeAt(tokPos + 3) == 45) {\r\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\r\n      tokPos += 4;\r\n      skipLineComment();\r\n      skipSpace();\r\n      return readToken();\r\n    }\r\n    if (next === 61)\r\n      size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\r\n    return finishOp(_relational, size);\r\n  }\r\n\r\n  function readToken_eq_excl(code) { // '=!'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\r\n    return finishOp(code === 61 ? _eq : _prefix, 1);\r\n  }\r\n\r\n  function getTokenFromCode(code) {\r\n    switch(code) {\r\n      // The interpretation of a dot depends on whether it is followed\r\n      // by a digit.\r\n    case 46: // '.'\r\n      return readToken_dot();\r\n\r\n      // Punctuation tokens.\r\n    case 40: ++tokPos; return finishToken(_parenL);\r\n    case 41: ++tokPos; return finishToken(_parenR);\r\n    case 59: ++tokPos; return finishToken(_semi);\r\n    case 44: ++tokPos; return finishToken(_comma);\r\n    case 91: ++tokPos; return finishToken(_bracketL);\r\n    case 93: ++tokPos; return finishToken(_bracketR);\r\n    case 123: ++tokPos; return finishToken(_braceL);\r\n    case 125: ++tokPos; return finishToken(_braceR);\r\n    case 58: ++tokPos; return finishToken(_colon);\r\n    case 63: ++tokPos; return finishToken(_question);\r\n\r\n      // '0x' is a hexadecimal number.\r\n    case 48: // '0'\r\n      var next = input.charCodeAt(tokPos + 1);\r\n      if (next === 120 || next === 88) return readHexNumber();\r\n      // Anything else beginning with a digit is an integer, octal\r\n      // number, or float.\r\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\r\n      return readNumber(false);\r\n\r\n      // Quotes produce strings.\r\n    case 34: case 39: // '\"', \"'\"\r\n      return readString(code);\r\n\r\n    // Operators are parsed inline in tiny state machines. '=' (61) is\r\n    // often referred to. `finishOp` simply skips the amount of\r\n    // characters it is given as second argument, and returns a token\r\n    // of the type given by its first argument.\r\n\r\n    case 47: // '/'\r\n      return readToken_slash(code);\r\n\r\n    case 37: case 42: // '%*'\r\n      return readToken_mult_modulo();\r\n\r\n    case 124: case 38: // '|&'\r\n      return readToken_pipe_amp(code);\r\n\r\n    case 94: // '^'\r\n      return readToken_caret();\r\n\r\n    case 43: case 45: // '+-'\r\n      return readToken_plus_min(code);\r\n\r\n    case 60: case 62: // '<>'\r\n      return readToken_lt_gt(code);\r\n\r\n    case 61: case 33: // '=!'\r\n      return readToken_eq_excl(code);\r\n\r\n    case 126: // '~'\r\n      return finishOp(_prefix, 1);\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function readToken(forceRegexp) {\r\n    if (!forceRegexp) tokStart = tokPos;\r\n    else tokPos = tokStart + 1;\r\n    if (options.locations) tokStartLoc = new line_loc_t;\r\n    if (forceRegexp) return readRegexp();\r\n    if (tokPos >= inputLen) return finishToken(_eof);\r\n\r\n    var code = input.charCodeAt(tokPos);\r\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\r\n    // identifiers, so '\\' also dispatches to that.\r\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) return readWord();\r\n\r\n    var tok = getTokenFromCode(code);\r\n\r\n    if (tok === false) {\r\n      // If we are here, we either found a non-ASCII identifier\r\n      // character, or something that's entirely disallowed.\r\n      var ch = String.fromCharCode(code);\r\n      if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\r\n      raise(tokPos, \"Unexpected character '\" + ch + \"'\");\r\n    }\r\n    return tok;\r\n  }\r\n\r\n  function finishOp(type, size) {\r\n    var str = input.slice(tokPos, tokPos + size);\r\n    tokPos += size;\r\n    finishToken(type, str);\r\n  }\r\n\r\n  // Parse a regular expression. Some context-awareness is necessary,\r\n  // since a '/' inside a '[]' set does not end the expression.\r\n\r\n  function readRegexp() {\r\n    var content = \"\", escaped, inClass, start = tokPos;\r\n    for (;;) {\r\n      if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\r\n      var ch = input.charAt(tokPos);\r\n      if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\r\n      if (!escaped) {\r\n        if (ch === \"[\") inClass = true;\r\n        else if (ch === \"]\" && inClass) inClass = false;\r\n        else if (ch === \"/\" && !inClass) break;\r\n        escaped = ch === \"\\\\\";\r\n      } else escaped = false;\r\n      ++tokPos;\r\n    }\r\n    var content = input.slice(start, tokPos);\r\n    ++tokPos;\r\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\r\n    // here (don't ask).\r\n    var mods = readWord1();\r\n    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\r\n    return finishToken(_regexp, new RegExp(content, mods));\r\n  }\r\n\r\n  // Read an integer in the given radix. Return null if zero digits\r\n  // were read, the integer value otherwise. When `len` is given, this\r\n  // will return `null` unless the integer has exactly `len` digits.\r\n\r\n  function readInt(radix, len) {\r\n    var start = tokPos, total = 0;\r\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\r\n      var code = input.charCodeAt(tokPos), val;\r\n      if (code >= 97) val = code - 97 + 10; // a\r\n      else if (code >= 65) val = code - 65 + 10; // A\r\n      else if (code >= 48 && code <= 57) val = code - 48; // 0-9\r\n      else val = Infinity;\r\n      if (val >= radix) break;\r\n      ++tokPos;\r\n      total = total * radix + val;\r\n    }\r\n    if (tokPos === start || len != null && tokPos - start !== len) return null;\r\n\r\n    return total;\r\n  }\r\n\r\n  function readHexNumber() {\r\n    tokPos += 2; // 0x\r\n    var val = readInt(16);\r\n    if (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\r\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\r\n    return finishToken(_num, val);\r\n  }\r\n\r\n  // Read an integer, octal integer, or floating-point number.\r\n\r\n  function readNumber(startsWithDot) {\r\n    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\r\n    if (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\r\n    if (input.charCodeAt(tokPos) === 46) {\r\n      ++tokPos;\r\n      readInt(10);\r\n      isFloat = true;\r\n    }\r\n    var next = input.charCodeAt(tokPos);\r\n    if (next === 69 || next === 101) { // 'eE'\r\n      next = input.charCodeAt(++tokPos);\r\n      if (next === 43 || next === 45) ++tokPos; // '+-'\r\n      if (readInt(10) === null) raise(start, \"Invalid number\");\r\n      isFloat = true;\r\n    }\r\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\r\n\r\n    var str = input.slice(start, tokPos), val;\r\n    if (isFloat) val = parseFloat(str);\r\n    else if (!octal || str.length === 1) val = parseInt(str, 10);\r\n    else if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\r\n    else val = parseInt(str, 8);\r\n    return finishToken(_num, val);\r\n  }\r\n\r\n  // Read a string value, interpreting backslash-escapes.\r\n\r\n  function readString(quote) {\r\n    tokPos++;\r\n    var out = \"\";\r\n    for (;;) {\r\n      if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\r\n      var ch = input.charCodeAt(tokPos);\r\n      if (ch === quote) {\r\n        ++tokPos;\r\n        return finishToken(_string, out);\r\n      }\r\n      if (ch === 92) { // '\\'\r\n        ch = input.charCodeAt(++tokPos);\r\n        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\r\n        if (octal) octal = octal[0];\r\n        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\r\n        if (octal === \"0\") octal = null;\r\n        ++tokPos;\r\n        if (octal) {\r\n          if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\r\n          out += String.fromCharCode(parseInt(octal, 8));\r\n          tokPos += octal.length - 1;\r\n        } else {\r\n          switch (ch) {\r\n          case 110: out += \"\\n\"; break; // 'n' -> '\\n'\r\n          case 114: out += \"\\r\"; break; // 'r' -> '\\r'\r\n          case 120: out += String.fromCharCode(readHexChar(2)); break; // 'x'\r\n          case 117: out += String.fromCharCode(readHexChar(4)); break; // 'u'\r\n          case 85: out += String.fromCharCode(readHexChar(8)); break; // 'U'\r\n          case 116: out += \"\\t\"; break; // 't' -> '\\t'\r\n          case 98: out += \"\\b\"; break; // 'b' -> '\\b'\r\n          case 118: out += \"\\u000b\"; break; // 'v' -> '\\u000b'\r\n          case 102: out += \"\\f\"; break; // 'f' -> '\\f'\r\n          case 48: out += \"\\0\"; break; // 0 -> '\\0'\r\n          case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\\r\\n'\r\n          case 10: // ' \\n'\r\n            if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\r\n            break;\r\n          default: out += String.fromCharCode(ch); break;\r\n          }\r\n        }\r\n      } else {\r\n        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\r\n        out += String.fromCharCode(ch); // '\\'\r\n        ++tokPos;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\r\n\r\n  function readHexChar(len) {\r\n    var n = readInt(16, len);\r\n    if (n === null) raise(tokStart, \"Bad character escape sequence\");\r\n    return n;\r\n  }\r\n\r\n  // Used to signal to callers of `readWord1` whether the word\r\n  // contained any escape sequences. This is needed because words with\r\n  // escape sequences must not be interpreted as keywords.\r\n\r\n  var containsEsc;\r\n\r\n  // Read an identifier, and return it as a string. Sets `containsEsc`\r\n  // to whether the word contained a '\\u' escape.\r\n  //\r\n  // Only builds up the word character-by-character when it actually\r\n  // containeds an escape, as a micro-optimization.\r\n\r\n  function readWord1() {\r\n    containsEsc = false;\r\n    var word, first = true, start = tokPos;\r\n    for (;;) {\r\n      var ch = input.charCodeAt(tokPos);\r\n      if (isIdentifierChar(ch)) {\r\n        if (containsEsc) word += input.charAt(tokPos);\r\n        ++tokPos;\r\n      } else if (ch === 92) { // \"\\\"\r\n        if (!containsEsc) word = input.slice(start, tokPos);\r\n        containsEsc = true;\r\n        if (input.charCodeAt(++tokPos) != 117) // \"u\"\r\n          raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\r\n        ++tokPos;\r\n        var esc = readHexChar(4);\r\n        var escStr = String.fromCharCode(esc);\r\n        if (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\r\n        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\r\n          raise(tokPos - 4, \"Invalid Unicode escape\");\r\n        word += escStr;\r\n      } else {\r\n        break;\r\n      }\r\n      first = false;\r\n    }\r\n    return containsEsc ? word : input.slice(start, tokPos);\r\n  }\r\n\r\n  // Read an identifier or keyword token. Will check for reserved\r\n  // words when necessary.\r\n\r\n  function readWord() {\r\n    var word = readWord1();\r\n    var type = _name;\r\n    if (!containsEsc) {\r\n      if (isKeyword(word)) type = keywordTypes[word];\r\n      else if (options.forbidReserved &&\r\n               (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) ||\r\n               strict && isStrictReservedWord(word))\r\n        raise(tokStart, \"The keyword '\" + word + \"' is reserved\");\r\n    }\r\n    return finishToken(type, word);\r\n  }\r\n\r\n  // ## Parser\r\n\r\n  // A recursive descent parser operates by defining functions for all\r\n  // syntactic elements, and recursively calling those, each function\r\n  // advancing the input stream and returning an AST node. Precedence\r\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\r\n  // instead of `(!x)[1]` is handled by the fact that the parser\r\n  // function that parses unary prefix operators is called first, and\r\n  // in turn calls the function that parses `[]` subscripts  that\r\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\r\n  // *that* in the unary operator node.\r\n  //\r\n  // Acorn uses an [operator precedence parser][opp] to handle binary\r\n  // operator precedence, because it is much more compact than using\r\n  // the technique outlined above, which uses different, nesting\r\n  // functions to specify precedence, for all of the ten binary\r\n  // precedence levels that JavaScript defines.\r\n  //\r\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\r\n\r\n  // ### Parser utilities\r\n\r\n  // Continue to the next token.\r\n\r\n  function next() {\r\n    lastStart = tokStart;\r\n    lastEnd = tokEnd;\r\n    lastEndLoc = tokEndLoc;\r\n    readToken();\r\n  }\r\n\r\n  // Enter strict mode. Re-reads the next token to please pedantic\r\n  // tests (\"use strict\"; 010; -- should fail).\r\n\r\n  function setStrict(strct) {\r\n    strict = strct;\r\n    tokPos = lastEnd;\r\n    if (options.locations) {\r\n      while (tokPos < tokLineStart) {\r\n        tokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\r\n        --tokCurLine;\r\n      }\r\n    }\r\n    skipSpace();\r\n    readToken();\r\n  }\r\n\r\n  // Start an AST node, attaching a start offset.\r\n\r\n  function node_t() {\r\n    this.type = null;\r\n    this.start = tokStart;\r\n    this.end = null;\r\n  }\r\n\r\n  function node_loc_t() {\r\n    this.start = tokStartLoc;\r\n    this.end = null;\r\n    if (sourceFile !== null) this.source = sourceFile;\r\n  }\r\n\r\n  function startNode() {\r\n    var node = new node_t();\r\n    if (options.locations)\r\n      node.loc = new node_loc_t();\r\n    if (options.directSourceFile)\r\n      node.sourceFile = options.directSourceFile;\r\n    if (options.ranges)\r\n      node.range = [tokStart, 0];\r\n    return node;\r\n  }\r\n\r\n  // Start a node whose start offset information should be based on\r\n  // the start of another node. For example, a binary operator node is\r\n  // only started after its left-hand side has already been parsed.\r\n\r\n  function startNodeFrom(other) {\r\n    var node = new node_t();\r\n    node.start = other.start;\r\n    if (options.locations) {\r\n      node.loc = new node_loc_t();\r\n      node.loc.start = other.loc.start;\r\n    }\r\n    if (options.ranges)\r\n      node.range = [other.range[0], 0];\r\n\r\n    return node;\r\n  }\r\n\r\n  // Finish an AST node, adding `type` and `end` properties.\r\n\r\n  function finishNode(node, type) {\r\n    node.type = type;\r\n    node.end = lastEnd;\r\n    if (options.locations)\r\n      node.loc.end = lastEndLoc;\r\n    if (options.ranges)\r\n      node.range[1] = lastEnd;\r\n    return node;\r\n  }\r\n\r\n  // Test whether a statement node is the string literal `\"use strict\"`.\r\n\r\n  function isUseStrict(stmt) {\r\n    return options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\r\n      stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\r\n  }\r\n\r\n  // Predicate that tests whether the next token is of the given\r\n  // type, and if yes, consumes it as a side effect.\r\n\r\n  function eat(type) {\r\n    if (tokType === type) {\r\n      next();\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // Test whether a semicolon can be inserted at the current position.\r\n\r\n  function canInsertSemicolon() {\r\n    return !options.strictSemicolons &&\r\n      (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\r\n  }\r\n\r\n  // Consume a semicolon, or, failing that, see if we are allowed to\r\n  // pretend that there is a semicolon at this position.\r\n\r\n  function semicolon() {\r\n    if (!eat(_semi) && !canInsertSemicolon()) unexpected();\r\n  }\r\n\r\n  // Expect a token of a given type. If found, consume it, otherwise,\r\n  // raise an unexpected token error.\r\n\r\n  function expect(type) {\r\n    if (tokType === type) next();\r\n    else unexpected();\r\n  }\r\n\r\n  // Raise an unexpected token error.\r\n\r\n  function unexpected() {\r\n    raise(tokStart, \"Unexpected token\");\r\n  }\r\n\r\n  // Verify that a node is an lval  something that can be assigned\r\n  // to.\r\n\r\n  function checkLVal(expr) {\r\n    if (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\r\n      raise(expr.start, \"Assigning to rvalue\");\r\n    if (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\r\n      raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\r\n  }\r\n\r\n  // ### Statement parsing\r\n\r\n  // Parse a program. Initializes the parser, reads any number of\r\n  // statements, and wraps them in a Program node.  Optionally takes a\r\n  // `program` argument.  If present, the statements will be appended\r\n  // to its body instead of creating a new node.\r\n\r\n  function parseTopLevel(program) {\r\n    lastStart = lastEnd = tokPos;\r\n    if (options.locations) lastEndLoc = new line_loc_t;\r\n    inFunction = strict = null;\r\n    labels = [];\r\n    readToken();\r\n\r\n    var node = program || startNode(), first = true;\r\n    if (!program) node.body = [];\r\n    while (tokType !== _eof) {\r\n      var stmt = parseStatement();\r\n      node.body.push(stmt);\r\n      if (first && isUseStrict(stmt)) setStrict(true);\r\n      first = false;\r\n    }\r\n    return finishNode(node, \"Program\");\r\n  }\r\n\r\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\r\n\r\n  // Parse a single statement.\r\n  //\r\n  // If expecting a statement and finding a slash operator, parse a\r\n  // regular expression literal. This is to handle cases like\r\n  // `if (foo) /blah/.exec(foo);`, where looking at the previous token\r\n  // does not help.\r\n\r\n  function parseStatement() {\r\n    if (tokType === _slash || tokType === _assign && tokVal == \"/=\")\r\n      readToken(true);\r\n\r\n    var starttype = tokType, node = startNode();\r\n\r\n    // Most types of statements are recognized by the keyword they\r\n    // start with. Many are trivial to parse, some require a bit of\r\n    // complexity.\r\n\r\n    switch (starttype) {\r\n    case _break: case _continue:\r\n      next();\r\n      var isBreak = starttype === _break;\r\n      if (eat(_semi) || canInsertSemicolon()) node.label = null;\r\n      else if (tokType !== _name) unexpected();\r\n      else {\r\n        node.label = parseIdent();\r\n        semicolon();\r\n      }\r\n\r\n      // Verify that there is an actual destination to break or\r\n      // continue to.\r\n      for (var i = 0; i < labels.length; ++i) {\r\n        var lab = labels[i];\r\n        if (node.label == null || lab.name === node.label.name) {\r\n          if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\r\n          if (node.label && isBreak) break;\r\n        }\r\n      }\r\n      if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\r\n      return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\r\n\r\n    case _debugger:\r\n      next();\r\n      semicolon();\r\n      return finishNode(node, \"DebuggerStatement\");\r\n\r\n    case _do:\r\n      next();\r\n      labels.push(loopLabel);\r\n      node.body = parseStatement();\r\n      labels.pop();\r\n      expect(_while);\r\n      node.test = parseParenExpression();\r\n      semicolon();\r\n      return finishNode(node, \"DoWhileStatement\");\r\n\r\n      // Disambiguating between a `for` and a `for`/`in` loop is\r\n      // non-trivial. Basically, we have to parse the init `var`\r\n      // statement or expression, disallowing the `in` operator (see\r\n      // the second parameter to `parseExpression`), and then check\r\n      // whether the next token is `in`. When there is no init part\r\n      // (semicolon immediately after the opening parenthesis), it is\r\n      // a regular `for` loop.\r\n\r\n    case _for:\r\n      next();\r\n      labels.push(loopLabel);\r\n      expect(_parenL);\r\n      if (tokType === _semi) return parseFor(node, null);\r\n      if (tokType === _var) {\r\n        var init = startNode();\r\n        next();\r\n        parseVar(init, true);\r\n        finishNode(init, \"VariableDeclaration\");\r\n        if (init.declarations.length === 1 && eat(_in))\r\n          return parseForIn(node, init);\r\n        return parseFor(node, init);\r\n      }\r\n      var init = parseExpression(false, true);\r\n      if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\r\n      return parseFor(node, init);\r\n\r\n    case _function:\r\n      next();\r\n      return parseFunction(node, true);\r\n\r\n    case _if:\r\n      next();\r\n      node.test = parseParenExpression();\r\n      node.consequent = parseStatement();\r\n      node.alternate = eat(_else) ? parseStatement() : null;\r\n      return finishNode(node, \"IfStatement\");\r\n\r\n    case _return:\r\n      if (!inFunction) raise(tokStart, \"'return' outside of function\");\r\n      next();\r\n\r\n      // In `return` (and `break`/`continue`), the keywords with\r\n      // optional arguments, we eagerly look for a semicolon or the\r\n      // possibility to insert one.\r\n\r\n      if (eat(_semi) || canInsertSemicolon()) node.argument = null;\r\n      else { node.argument = parseExpression(); semicolon(); }\r\n      return finishNode(node, \"ReturnStatement\");\r\n\r\n    case _switch:\r\n      next();\r\n      node.discriminant = parseParenExpression();\r\n      node.cases = [];\r\n      expect(_braceL);\r\n      labels.push(switchLabel);\r\n\r\n      // Statements under must be grouped (by label) in SwitchCase\r\n      // nodes. `cur` is used to keep the node that we are currently\r\n      // adding statements to.\r\n\r\n      for (var cur, sawDefault; tokType != _braceR;) {\r\n        if (tokType === _case || tokType === _default) {\r\n          var isCase = tokType === _case;\r\n          if (cur) finishNode(cur, \"SwitchCase\");\r\n          node.cases.push(cur = startNode());\r\n          cur.consequent = [];\r\n          next();\r\n          if (isCase) cur.test = parseExpression();\r\n          else {\r\n            if (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\r\n            cur.test = null;\r\n          }\r\n          expect(_colon);\r\n        } else {\r\n          if (!cur) unexpected();\r\n          cur.consequent.push(parseStatement());\r\n        }\r\n      }\r\n      if (cur) finishNode(cur, \"SwitchCase\");\r\n      next(); // Closing brace\r\n      labels.pop();\r\n      return finishNode(node, \"SwitchStatement\");\r\n\r\n    case _throw:\r\n      next();\r\n      if (newline.test(input.slice(lastEnd, tokStart)))\r\n        raise(lastEnd, \"Illegal newline after throw\");\r\n      node.argument = parseExpression();\r\n      semicolon();\r\n      return finishNode(node, \"ThrowStatement\");\r\n\r\n    case _try:\r\n      next();\r\n      node.block = parseBlock();\r\n      node.handler = null;\r\n      if (tokType === _catch) {\r\n        var clause = startNode();\r\n        next();\r\n        expect(_parenL);\r\n        clause.param = parseIdent();\r\n        if (strict && isStrictBadIdWord(clause.param.name))\r\n          raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\r\n        expect(_parenR);\r\n        clause.guard = null;\r\n        clause.body = parseBlock();\r\n        node.handler = finishNode(clause, \"CatchClause\");\r\n      }\r\n      node.guardedHandlers = empty;\r\n      node.finalizer = eat(_finally) ? parseBlock() : null;\r\n      if (!node.handler && !node.finalizer)\r\n        raise(node.start, \"Missing catch or finally clause\");\r\n      return finishNode(node, \"TryStatement\");\r\n\r\n    case _var:\r\n      next();\r\n      parseVar(node);\r\n      semicolon();\r\n      return finishNode(node, \"VariableDeclaration\");\r\n\r\n    case _while:\r\n      next();\r\n      node.test = parseParenExpression();\r\n      labels.push(loopLabel);\r\n      node.body = parseStatement();\r\n      labels.pop();\r\n      return finishNode(node, \"WhileStatement\");\r\n\r\n    case _with:\r\n      if (strict) raise(tokStart, \"'with' in strict mode\");\r\n      next();\r\n      node.object = parseParenExpression();\r\n      node.body = parseStatement();\r\n      return finishNode(node, \"WithStatement\");\r\n\r\n    case _braceL:\r\n      return parseBlock();\r\n\r\n    case _semi:\r\n      next();\r\n      return finishNode(node, \"EmptyStatement\");\r\n\r\n      // If the statement does not start with a statement keyword or a\r\n      // brace, it's an ExpressionStatement or LabeledStatement. We\r\n      // simply start parsing an expression, and afterwards, if the\r\n      // next token is a colon and the expression was a simple\r\n      // Identifier node, we switch to interpreting it as a label.\r\n\r\n    default:\r\n      var maybeName = tokVal, expr = parseExpression();\r\n      if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\r\n        for (var i = 0; i < labels.length; ++i)\r\n          if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\r\n        var kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\r\n        labels.push({name: maybeName, kind: kind});\r\n        node.body = parseStatement();\r\n        labels.pop();\r\n        node.label = expr;\r\n        return finishNode(node, \"LabeledStatement\");\r\n      } else {\r\n        node.expression = expr;\r\n        semicolon();\r\n        return finishNode(node, \"ExpressionStatement\");\r\n      }\r\n    }\r\n  }\r\n\r\n  // Used for constructs like `switch` and `if` that insist on\r\n  // parentheses around their expression.\r\n\r\n  function parseParenExpression() {\r\n    expect(_parenL);\r\n    var val = parseExpression();\r\n    expect(_parenR);\r\n    return val;\r\n  }\r\n\r\n  // Parse a semicolon-enclosed block of statements, handling `\"use\r\n  // strict\"` declarations when `allowStrict` is true (used for\r\n  // function bodies).\r\n\r\n  function parseBlock(allowStrict) {\r\n    var node = startNode(), first = true, strict = false, oldStrict;\r\n    node.body = [];\r\n    expect(_braceL);\r\n    while (!eat(_braceR)) {\r\n      var stmt = parseStatement();\r\n      node.body.push(stmt);\r\n      if (first && allowStrict && isUseStrict(stmt)) {\r\n        oldStrict = strict;\r\n        setStrict(strict = true);\r\n      }\r\n      first = false;\r\n    }\r\n    if (strict && !oldStrict) setStrict(false);\r\n    return finishNode(node, \"BlockStatement\");\r\n  }\r\n\r\n  // Parse a regular `for` loop. The disambiguation code in\r\n  // `parseStatement` will already have parsed the init statement or\r\n  // expression.\r\n\r\n  function parseFor(node, init) {\r\n    node.init = init;\r\n    expect(_semi);\r\n    node.test = tokType === _semi ? null : parseExpression();\r\n    expect(_semi);\r\n    node.update = tokType === _parenR ? null : parseExpression();\r\n    expect(_parenR);\r\n    node.body = parseStatement();\r\n    labels.pop();\r\n    return finishNode(node, \"ForStatement\");\r\n  }\r\n\r\n  // Parse a `for`/`in` loop.\r\n\r\n  function parseForIn(node, init) {\r\n    node.left = init;\r\n    node.right = parseExpression();\r\n    expect(_parenR);\r\n    node.body = parseStatement();\r\n    labels.pop();\r\n    return finishNode(node, \"ForInStatement\");\r\n  }\r\n\r\n  // Parse a list of variable declarations.\r\n\r\n  function parseVar(node, noIn) {\r\n    node.declarations = [];\r\n    node.kind = \"var\";\r\n    for (;;) {\r\n      var decl = startNode();\r\n      decl.id = parseIdent();\r\n      if (strict && isStrictBadIdWord(decl.id.name))\r\n        raise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\r\n      decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\r\n      node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\r\n      if (!eat(_comma)) break;\r\n    }\r\n    return node;\r\n  }\r\n\r\n  // ### Expression parsing\r\n\r\n  // These nest, from the most general expression type at the top to\r\n  // 'atomic', nondivisible expression types at the bottom. Most of\r\n  // the functions will simply let the function(s) below them parse,\r\n  // and, *if* the syntactic construct they handle is present, wrap\r\n  // the AST node that the inner parser gave them in another node.\r\n\r\n  // Parse a full expression. The arguments are used to forbid comma\r\n  // sequences (in argument lists, array literals, or object literals)\r\n  // or the `in` operator (in for loops initalization expressions).\r\n\r\n  function parseExpression(noComma, noIn) {\r\n    var expr = parseMaybeAssign(noIn);\r\n    if (!noComma && tokType === _comma) {\r\n      var node = startNodeFrom(expr);\r\n      node.expressions = [expr];\r\n      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\r\n      return finishNode(node, \"SequenceExpression\");\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // Parse an assignment expression. This includes applications of\r\n  // operators like `+=`.\r\n\r\n  function parseMaybeAssign(noIn) {\r\n    var left = parseMaybeConditional(noIn);\r\n    if (tokType.isAssign) {\r\n      var node = startNodeFrom(left);\r\n      node.operator = tokVal;\r\n      node.left = left;\r\n      next();\r\n      node.right = parseMaybeAssign(noIn);\r\n      checkLVal(left);\r\n      return finishNode(node, \"AssignmentExpression\");\r\n    }\r\n    return left;\r\n  }\r\n\r\n  // Parse a ternary conditional (`?:`) operator.\r\n\r\n  function parseMaybeConditional(noIn) {\r\n    var expr = parseExprOps(noIn);\r\n    if (eat(_question)) {\r\n      var node = startNodeFrom(expr);\r\n      node.test = expr;\r\n      node.consequent = parseExpression(true);\r\n      expect(_colon);\r\n      node.alternate = parseExpression(true, noIn);\r\n      return finishNode(node, \"ConditionalExpression\");\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // Start the precedence parser.\r\n\r\n  function parseExprOps(noIn) {\r\n    return parseExprOp(parseMaybeUnary(), -1, noIn);\r\n  }\r\n\r\n  // Parse binary operators with the operator precedence parsing\r\n  // algorithm. `left` is the left-hand side of the operator.\r\n  // `minPrec` provides context that allows the function to stop and\r\n  // defer further parser to one of its callers when it encounters an\r\n  // operator that has a lower precedence than the set it is parsing.\r\n\r\n  function parseExprOp(left, minPrec, noIn) {\r\n    var prec = tokType.binop;\r\n    if (prec != null && (!noIn || tokType !== _in)) {\r\n      if (prec > minPrec) {\r\n        var node = startNodeFrom(left);\r\n        node.left = left;\r\n        node.operator = tokVal;\r\n        var op = tokType;\r\n        next();\r\n        node.right = parseExprOp(parseMaybeUnary(), prec, noIn);\r\n        var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\r\n        return parseExprOp(exprNode, minPrec, noIn);\r\n      }\r\n    }\r\n    return left;\r\n  }\r\n\r\n  // Parse unary operators, both prefix and postfix.\r\n\r\n  function parseMaybeUnary() {\r\n    if (tokType.prefix) {\r\n      var node = startNode(), update = tokType.isUpdate;\r\n      node.operator = tokVal;\r\n      node.prefix = true;\r\n      tokRegexpAllowed = true;\r\n      next();\r\n      node.argument = parseMaybeUnary();\r\n      if (update) checkLVal(node.argument);\r\n      else if (strict && node.operator === \"delete\" &&\r\n               node.argument.type === \"Identifier\")\r\n        raise(node.start, \"Deleting local variable in strict mode\");\r\n      return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\r\n    }\r\n    var expr = parseExprSubscripts();\r\n    while (tokType.postfix && !canInsertSemicolon()) {\r\n      var node = startNodeFrom(expr);\r\n      node.operator = tokVal;\r\n      node.prefix = false;\r\n      node.argument = expr;\r\n      checkLVal(expr);\r\n      next();\r\n      expr = finishNode(node, \"UpdateExpression\");\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // Parse call, dot, and `[]`-subscript expressions.\r\n\r\n  function parseExprSubscripts() {\r\n    return parseSubscripts(parseExprAtom());\r\n  }\r\n\r\n  function parseSubscripts(base, noCalls) {\r\n    if (eat(_dot)) {\r\n      var node = startNodeFrom(base);\r\n      node.object = base;\r\n      node.property = parseIdent(true);\r\n      node.computed = false;\r\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\r\n    } else if (eat(_bracketL)) {\r\n      var node = startNodeFrom(base);\r\n      node.object = base;\r\n      node.property = parseExpression();\r\n      node.computed = true;\r\n      expect(_bracketR);\r\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\r\n    } else if (!noCalls && eat(_parenL)) {\r\n      var node = startNodeFrom(base);\r\n      node.callee = base;\r\n      node.arguments = parseExprList(_parenR, false);\r\n      return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\r\n    } else return base;\r\n  }\r\n\r\n  // Parse an atomic expression  either a single token that is an\r\n  // expression, an expression started by a keyword like `function` or\r\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\r\n  // or `{}`.\r\n\r\n  function parseExprAtom() {\r\n    switch (tokType) {\r\n    case _this:\r\n      var node = startNode();\r\n      next();\r\n      return finishNode(node, \"ThisExpression\");\r\n    case _name:\r\n      return parseIdent();\r\n    case _num: case _string: case _regexp:\r\n      var node = startNode();\r\n      node.value = tokVal;\r\n      node.raw = input.slice(tokStart, tokEnd);\r\n      next();\r\n      return finishNode(node, \"Literal\");\r\n\r\n    case _null: case _true: case _false:\r\n      var node = startNode();\r\n      node.value = tokType.atomValue;\r\n      node.raw = tokType.keyword;\r\n      next();\r\n      return finishNode(node, \"Literal\");\r\n\r\n    case _parenL:\r\n      var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\r\n      next();\r\n      var val = parseExpression();\r\n      val.start = tokStart1;\r\n      val.end = tokEnd;\r\n      if (options.locations) {\r\n        val.loc.start = tokStartLoc1;\r\n        val.loc.end = tokEndLoc;\r\n      }\r\n      if (options.ranges)\r\n        val.range = [tokStart1, tokEnd];\r\n      expect(_parenR);\r\n      return val;\r\n\r\n    case _bracketL:\r\n      var node = startNode();\r\n      next();\r\n      node.elements = parseExprList(_bracketR, true, true);\r\n      return finishNode(node, \"ArrayExpression\");\r\n\r\n    case _braceL:\r\n      return parseObj();\r\n\r\n    case _function:\r\n      var node = startNode();\r\n      next();\r\n      return parseFunction(node, false);\r\n\r\n    case _new:\r\n      return parseNew();\r\n\r\n    default:\r\n      unexpected();\r\n    }\r\n  }\r\n\r\n  // New's precedence is slightly tricky. It must allow its argument\r\n  // to be a `[]` or dot subscript expression, but not a call  at\r\n  // least, not without wrapping it in parentheses. Thus, it uses the\r\n\r\n  function parseNew() {\r\n    var node = startNode();\r\n    next();\r\n    node.callee = parseSubscripts(parseExprAtom(), true);\r\n    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\r\n    else node.arguments = empty;\r\n    return finishNode(node, \"NewExpression\");\r\n  }\r\n\r\n  // Parse an object literal.\r\n\r\n  function parseObj() {\r\n    var node = startNode(), first = true, sawGetSet = false;\r\n    node.properties = [];\r\n    next();\r\n    while (!eat(_braceR)) {\r\n      if (!first) {\r\n        expect(_comma);\r\n        if (options.allowTrailingCommas && eat(_braceR)) break;\r\n      } else first = false;\r\n\r\n      var prop = {key: parsePropertyName()}, isGetSet = false, kind;\r\n      if (eat(_colon)) {\r\n        prop.value = parseExpression(true);\r\n        kind = prop.kind = \"init\";\r\n      } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\r\n                 (prop.key.name === \"get\" || prop.key.name === \"set\")) {\r\n        isGetSet = sawGetSet = true;\r\n        kind = prop.kind = prop.key.name;\r\n        prop.key = parsePropertyName();\r\n        if (tokType !== _parenL) unexpected();\r\n        prop.value = parseFunction(startNode(), false);\r\n      } else unexpected();\r\n\r\n      // getters and setters are not allowed to clash  either with\r\n      // each other or with an init property  and in strict mode,\r\n      // init properties are also not allowed to be repeated.\r\n\r\n      if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\r\n        for (var i = 0; i < node.properties.length; ++i) {\r\n          var other = node.properties[i];\r\n          if (other.key.name === prop.key.name) {\r\n            var conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\r\n              kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\r\n            if (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\r\n            if (conflict) raise(prop.key.start, \"Redefinition of property\");\r\n          }\r\n        }\r\n      }\r\n      node.properties.push(prop);\r\n    }\r\n    return finishNode(node, \"ObjectExpression\");\r\n  }\r\n\r\n  function parsePropertyName() {\r\n    if (tokType === _num || tokType === _string) return parseExprAtom();\r\n    return parseIdent(true);\r\n  }\r\n\r\n  // Parse a function declaration or literal (depending on the\r\n  // `isStatement` parameter).\r\n\r\n  function parseFunction(node, isStatement) {\r\n    if (tokType === _name) node.id = parseIdent();\r\n    else if (isStatement) unexpected();\r\n    else node.id = null;\r\n    node.params = [];\r\n    var first = true;\r\n    expect(_parenL);\r\n    while (!eat(_parenR)) {\r\n      if (!first) expect(_comma); else first = false;\r\n      node.params.push(parseIdent());\r\n    }\r\n\r\n    // Start a new scope with regard to labels and the `inFunction`\r\n    // flag (restore them to their old value afterwards).\r\n    var oldInFunc = inFunction, oldLabels = labels;\r\n    inFunction = true; labels = [];\r\n    node.body = parseBlock(true);\r\n    inFunction = oldInFunc; labels = oldLabels;\r\n\r\n    // If this is a strict mode function, verify that argument names\r\n    // are not repeated, and it does not try to bind the words `eval`\r\n    // or `arguments`.\r\n    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\r\n      for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\r\n        var id = i < 0 ? node.id : node.params[i];\r\n        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\r\n          raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\r\n        if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\r\n          raise(id.start, \"Argument name clash in strict mode\");\r\n      }\r\n    }\r\n\r\n    return finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\r\n  }\r\n\r\n  // Parses a comma-separated list of expressions, and returns them as\r\n  // an array. `close` is the token type that ends the list, and\r\n  // `allowEmpty` can be turned on to allow subsequent commas with\r\n  // nothing in between them to be parsed as `null` (which is needed\r\n  // for array literals).\r\n\r\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\r\n    var elts = [], first = true;\r\n    while (!eat(close)) {\r\n      if (!first) {\r\n        expect(_comma);\r\n        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\r\n      } else first = false;\r\n\r\n      if (allowEmpty && tokType === _comma) elts.push(null);\r\n      else elts.push(parseExpression(true));\r\n    }\r\n    return elts;\r\n  }\r\n\r\n  // Parse the next token as an identifier. If `liberal` is true (used\r\n  // when parsing properties), it will also convert keywords into\r\n  // identifiers.\r\n\r\n  function parseIdent(liberal) {\r\n    var node = startNode();\r\n    node.name = tokType === _name ? tokVal : (liberal && !options.forbidReserved && tokType.keyword) || unexpected();\r\n    tokRegexpAllowed = false;\r\n    next();\r\n    return finishNode(node, \"Identifier\");\r\n  }\r\n\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib/acorn.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 3\n// module chunks = 0","/// <reference path=\"./_estree.d.ts\" />\r\n\r\n// Declare missing functions\r\ndeclare function escape(s:string): string;\r\ndeclare function unescape(s:string): string;\r\n\r\n/**\r\n * @license\r\n * JavaScript Interpreter\r\n *\r\n * Copyright 2013-2017 Google Inc. and Jun Kato\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @fileoverview Interpreting JavaScript in JavaScript.\r\n * @author fraser@google.com (Neil Fraser)\r\n * @author i@junkato (Jun Kato)\r\n */\r\n\r\n/**\r\n * Create a new interpreter.\r\n * @param {string|!Object} code Raw JavaScript text or AST.\r\n * @param {Function=} opt_initFunc Optional initialization function.  Used to\r\n *     define APIs.  When called it is passed the interpreter object and the\r\n *     global scope object.\r\n * @constructor\r\n */\r\nclass Interpreter {\r\npublic static acorn: Interpreter.Acorn;\r\n\r\nprivate nodeConstructor: Interpreter.NodeConstructor;\r\npublic ast: ESTree.Program;\r\npublic global: Interpreter.MyObject;\r\npublic stateStack: Interpreter.MyState[];\r\npublic value: Interpreter.MyValue;\r\nprivate initFunc_: (i: Interpreter, scope: Interpreter.MyObject) => void;\r\nprivate paused_: boolean;\r\nprivate polyfills_: string[];\r\nprivate functionCounter_: number;\r\nprivate stepFunctions_: { [key: string]: Function };\r\n\r\npublic OBJECT: Interpreter.MyObject;\r\npublic OBJECT_PROTO: Interpreter.MyObject;\r\npublic FUNCTION: Interpreter.MyObject;\r\npublic FUNCTION_PROTO: Interpreter.MyObject;\r\npublic ARRAY: Interpreter.MyObject;\r\npublic ARRAY_PROTO: Interpreter.MyObject;\r\npublic REGEXP: Interpreter.MyObject;\r\npublic REGEXP_PROTO: Interpreter.MyObject;\r\n\r\npublic ERROR: Interpreter.MyObject;\r\npublic EVAL_ERROR: Interpreter.MyObject;\r\npublic RANGE_ERROR: Interpreter.MyObject;\r\npublic REFERENCE_ERROR: Interpreter.MyObject;\r\npublic SYNTAX_ERROR: Interpreter.MyObject;\r\npublic TYPE_ERROR: Interpreter.MyObject;\r\npublic URI_ERROR: Interpreter.MyObject;\r\n\r\npublic STRING: Interpreter.MyObject;\r\npublic BOOLEAN: Interpreter.MyObject;\r\npublic NUMBER: Interpreter.MyObject;\r\npublic DATE: Interpreter.MyObject;\r\n\r\n// The following properties are obsolete.  Do not use.\r\npublic UNDEFINED: Interpreter.MyObject;\r\npublic NULL: null;\r\npublic NAN: number;\r\npublic TRUE: boolean;\r\npublic FALSE: boolean;\r\npublic STRING_EMPTY: string;\r\npublic NUMBER_ZERO: number;\r\npublic NUMBER_ONE: number;\r\n\r\nconstructor(code: string | ESTree.Program\r\n    , opt_initFunc?: (i: Interpreter, scope: Interpreter.MyObject) => void) {\r\n  if (typeof code === 'string') {\r\n    code = Interpreter.acorn.parse(code, Interpreter.PARSE_OPTIONS);\r\n  }\r\n  this.ast = code;\r\n  this.initFunc_ = opt_initFunc;\r\n  this.paused_ = false;\r\n  this.polyfills_ = [];\r\n  // Unique identifier for native functions.  Used in serialization.\r\n  this.functionCounter_ = 0;\r\n  // Map node types to our step function names; a property lookup is faster\r\n  // than string concatenation with \"step\" prefix.\r\n  this.stepFunctions_ = Object.create(null);\r\n  var stepMatch = /^step([A-Z]\\w*)$/;\r\n  var m;\r\n  for (var methodName in this) {\r\n    if ((typeof this[methodName] === 'function') &&\r\n        (m = methodName.match(stepMatch))) {\r\n      this.stepFunctions_[m[1]] = (<Function>this[methodName]).bind(this);\r\n    }\r\n  }\r\n  // Create and initialize the global scope.\r\n  this.global = this.createScope(this.ast, null);\r\n  // Run the polyfills.\r\n  this.ast = Interpreter.acorn.parse(this.polyfills_.join('\\n'), Interpreter.PARSE_OPTIONS);\r\n  this.polyfills_ = undefined;  // Allow polyfill strings to garbage collect.\r\n  this.stripLocations_(this.ast, undefined, undefined);\r\n  var state = new Interpreter.MyState(this.ast, this.global);\r\n  state.done = false;\r\n  this.stateStack = [state];\r\n  this.run();\r\n  this.value = undefined;\r\n  // Point at the main program.\r\n  this.ast = code;\r\n  var state = new Interpreter.MyState(this.ast, this.global);\r\n  state.done = false;\r\n  this.stateStack.length = 0;\r\n  this.stateStack[0] = state;\r\n  // Get a handle on Acorn's node_t object.  It's tricky to access.\r\n  this.nodeConstructor = <Interpreter.NodeConstructor>state.node.constructor;\r\n  // Preserve publicly properties from being pruned/renamed by JS compilers.\r\n  // Add others as needed.\r\n  this['stateStack'] = this.stateStack;\r\n  this['OBJECT'] = this.OBJECT; this['OBJECT_PROTO'] = this.OBJECT_PROTO;\r\n  this['FUNCTION'] = this.FUNCTION; this['FUNCTION_PROTO'] = this.FUNCTION_PROTO;\r\n  this['ARRAY'] = this.ARRAY; this['ARRAY_PROTO'] = this.ARRAY_PROTO;\r\n  this['REGEXP'] = this.REGEXP; this['REGEXP_PROTO'] = this.REGEXP_PROTO;\r\n  // The following properties are obsolete.  Do not use.\r\n  this['UNDEFINED'] = undefined; this['NULL'] = null; this['NAN'] = NaN;\r\n  this['TRUE'] = true; this['FALSE'] = false; this['STRING_EMPTY'] = '';\r\n  this['NUMBER_ZERO'] = 0; this['NUMBER_ONE'] = 1;\r\n};\r\n\r\n/**\r\n * @const {!Object} Configuration used for all Acorn parsing.\r\n */\r\nstatic PARSE_OPTIONS = {\r\n  ecmaVersion: 5\r\n};\r\n\r\n/**\r\n * Property descriptor of readonly properties.\r\n */\r\nstatic READONLY_DESCRIPTOR = {\r\n  configurable: true,\r\n  enumerable: true,\r\n  writable: false\r\n};\r\n\r\n/**\r\n * Property descriptor of non-enumerable properties.\r\n */\r\nstatic NONENUMERABLE_DESCRIPTOR = {\r\n  configurable: true,\r\n  enumerable: false,\r\n  writable: true\r\n};\r\n\r\n/**\r\n * Property descriptor of readonly, non-enumerable properties.\r\n */\r\nstatic READONLY_NONENUMERABLE_DESCRIPTOR = {\r\n  configurable: true,\r\n  enumerable: false,\r\n  writable: false\r\n};\r\n\r\n/**\r\n * Property descriptor of variables.\r\n */\r\nstatic VARIABLE_DESCRIPTOR = {\r\n  configurable: false,\r\n  enumerable: true,\r\n  writable: true\r\n};\r\n\r\n/**\r\n * Unique symbol for indicating that a step has encountered an error, has\r\n * added it to the stack, and will be thrown within the user's program.\r\n * When STEP_ERROR is thrown in the JS-Interpreter, the error can be ignored.\r\n */\r\nstatic STEP_ERROR = {};\r\n\r\n/**\r\n * Unique symbol for indicating that a reference is a variable on the scope,\r\n * not an object property.\r\n */\r\nstatic SCOPE_REFERENCE = {};\r\n\r\n/**\r\n * For cycle detection in array to string and error conversion;\r\n * see spec bug github.com/tc39/ecma262/issues/289\r\n * Since this is for atomic actions only, it can be a class property.\r\n */\r\nstatic toStringCycles_ = [];\r\n\r\n/**\r\n * Add more code to the interpreter.\r\n * @param {string|!Object} code Raw JavaScript text or AST.\r\n */\r\npublic appendCode(code: string | ESTree.Node) {\r\n  var state = this.stateStack[0];\r\n  if (!state || state.node['type'] !== 'Program') {\r\n    throw Error('Expecting original AST to start with a Program node.');\r\n  }\r\n  if (typeof code === 'string') {\r\n    code = Interpreter.acorn.parse(code, Interpreter.PARSE_OPTIONS);\r\n  }\r\n  if (!code || code['type'] !== 'Program') {\r\n    throw Error('Expecting new AST to start with a Program node.');\r\n  }\r\n  this.populateScope_(code, state.scope);\r\n  // Append the new program to the old one.\r\n  for (var i = 0, node; (node = code['body'][i]); i++) {\r\n    state.node['body'].push(node);\r\n  }\r\n  state.done = false;\r\n};\r\n\r\n/**\r\n * Execute one step of the interpreter.\r\n * @return {boolean} True if a step was executed, false if no more instructions.\r\n */\r\npublic step(): boolean {\r\n  var stack = this.stateStack;\r\n  var state = stack[stack.length - 1];\r\n  if (!state) {\r\n    return false;\r\n  }\r\n  var node = state.node, type = node['type'];\r\n  if (type === 'Program' && state.done) {\r\n    return false;\r\n  } else if (this.paused_) {\r\n    return true;\r\n  }\r\n  try {\r\n    var nextState = this.stepFunctions_[type](stack, state, node);\r\n  } catch (e) {\r\n    // Eat any step errors.  They have been thrown on the stack.\r\n    if (e !== Interpreter.STEP_ERROR) {\r\n      // Uh oh.  This is a real error in the JS-Interpreter.  Rethrow.\r\n      throw e;\r\n    }\r\n  }\r\n  if (nextState) {\r\n    stack.push(nextState);\r\n  }\r\n  if (!node['end']) {\r\n    // This is polyfill code.  Keep executing until we arrive at user code.\r\n    return this.step();\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Execute the interpreter to program completion.  Vulnerable to infinite loops.\r\n * @return {boolean} True if a execution is asynchronously blocked,\r\n *     false if no more instructions.\r\n */\r\npublic run() {\r\n  while (!this.paused_ && this.step()) {}\r\n  return this.paused_;\r\n};\r\n\r\n/**\r\n * Initialize the global scope with buitin properties and functions.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initGlobalScope(scope: Interpreter.MyObject) {\r\n  // Initialize uneditable global properties.\r\n  this.setProperty(scope, 'NaN', NaN,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'Infinity', Infinity,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'undefined', undefined,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'window', scope,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'this', scope,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'self', scope); // Editable.\r\n\r\n  // Create the objects which will become Object.prototype and\r\n  // Function.prototype, which are needed to bootstrap everything else.\r\n  this.OBJECT_PROTO = new Interpreter.MyObject(null);\r\n  this.FUNCTION_PROTO = new Interpreter.MyObject(this.OBJECT_PROTO);\r\n  // Initialize global objects.\r\n  this.initFunction(scope);\r\n  this.initObject(scope);\r\n  // Unable to set scope's parent prior (OBJECT did not exist).\r\n  // Note that in a browser this would be 'Window', whereas in Node.js it would\r\n  // be 'Object'.  This interpreter is closer to Node in that it has no DOM.\r\n  scope.proto = this.OBJECT_PROTO;\r\n  this.setProperty(scope, 'constructor', this.OBJECT);\r\n  this.initArray(scope);\r\n  this.initString(scope);\r\n  this.initBoolean(scope);\r\n  this.initNumber(scope);\r\n  this.initDate(scope);\r\n  this.initRegExp(scope);\r\n  this.initError(scope);\r\n  this.initMath(scope);\r\n  this.initJSON(scope);\r\n\r\n  // Initialize global functions.\r\n  var thisInterpreter = this;\r\n  var func = this.createNativeFunction(\r\n      function(x) {throw EvalError(\"Can't happen\");}, false);\r\n  func.eval = true;\r\n  this.setProperty(scope, 'eval', func);\r\n\r\n  this.setProperty(scope, 'parseInt',\r\n      this.createNativeFunction(parseInt, false));\r\n  this.setProperty(scope, 'parseFloat',\r\n      this.createNativeFunction(parseFloat, false));\r\n\r\n  this.setProperty(scope, 'isNaN',\r\n      this.createNativeFunction(isNaN, false));\r\n\r\n  this.setProperty(scope, 'isFinite',\r\n      this.createNativeFunction(isFinite, false));\r\n\r\n  var strFunctions: any[] = [\r\n    [escape, 'escape'], [unescape, 'unescape'],\r\n    [decodeURI, 'decodeURI'], [decodeURIComponent, 'decodeURIComponent'],\r\n    [encodeURI, 'encodeURI'], [encodeURIComponent, 'encodeURIComponent']\r\n  ];\r\n  for (var i = 0; i < strFunctions.length; i++) {\r\n    var wrapper = (function(nativeFunc: (s: string) => string) {\r\n      return function(str) {\r\n        try {\r\n          return nativeFunc(str);\r\n        } catch (e) {\r\n          // decodeURI('%xy') will throw an error.  Catch and rethrow.\r\n          thisInterpreter.throwException(thisInterpreter.URI_ERROR, e.message);\r\n        }\r\n      };\r\n    })(strFunctions[i][0]);\r\n    this.setProperty(scope, strFunctions[i][1],\r\n        this.createNativeFunction(wrapper, false),\r\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n\r\n  // Run any user-provided initialization.\r\n  if (this.initFunc_) {\r\n    this.initFunc_(this, scope);\r\n  }\r\n};\r\n\r\n/**\r\n * Initialize the Function class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initFunction(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  var identifierRegexp = /^[A-Za-z_$][\\w$]*$/;\r\n  // Function constructor.\r\n  wrapper = function(var_args) {\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Function().\r\n      var newFunc = <Interpreter.MyObject>this;\r\n    } else {\r\n      // Called as Function().\r\n      var newFunc =\r\n          thisInterpreter.createObjectProto(thisInterpreter.FUNCTION_PROTO);\r\n    }\r\n    if (arguments.length) {\r\n      var code = String(arguments[arguments.length - 1]);\r\n    } else {\r\n      var code = '';\r\n    }\r\n    var args: string[] | string = [];\r\n    for (var i = 0; i < arguments.length - 1; i++) {\r\n      var name = String(arguments[i]);\r\n      if (!name.match(identifierRegexp)) {\r\n        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR,\r\n            'Invalid function argument: ' + name);\r\n      }\r\n      args.push(name);\r\n    }\r\n    args = args.join(', ');\r\n    // Interestingly, the scope for constructed functions is the global scope,\r\n    // even if they were constructed in some other scope.\r\n    newFunc.parentScope = thisInterpreter.global;\r\n    // Acorn needs to parse code in the context of a function or else 'return'\r\n    // statements will be syntax errors.\r\n    try {\r\n    var ast = Interpreter.acorn.parse('$ = function(' + args + ') {' + code + '};',\r\n        Interpreter.PARSE_OPTIONS);\r\n    } catch (e) {\r\n      // Acorn threw a SyntaxError.  Rethrow as a trappable error.\r\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR,\r\n          'Invalid code: ' + e.message);\r\n    }\r\n    if (ast['body'].length !== 1) {\r\n      // Function('a', 'return a + 6;}; {alert(1);');\r\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR,\r\n          'Invalid code in function body.');\r\n    }\r\n    newFunc.node = ast['body'][0]['expression']['right'];\r\n    thisInterpreter.setProperty(newFunc, 'length', newFunc.node['length'],\r\n        Interpreter.READONLY_DESCRIPTOR);\r\n    return newFunc;\r\n  };\r\n  wrapper.id = this.functionCounter_++;\r\n  this.FUNCTION = this.createObjectProto(this.FUNCTION_PROTO);\r\n\r\n  this.setProperty(scope, 'Function', this.FUNCTION);\r\n  // Manually setup type and prototype because createObj doesn't recognize\r\n  // this object as a function (this.FUNCTION did not exist).\r\n  this.setProperty(this.FUNCTION, 'prototype', this.FUNCTION_PROTO);\r\n  this.FUNCTION.nativeFunc = wrapper;\r\n\r\n  // Configure Function.prototype.\r\n  this.setProperty(this.FUNCTION_PROTO, 'constructor', this.FUNCTION,\r\n                   Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  this.FUNCTION_PROTO.nativeFunc = function() {};\r\n  this.FUNCTION_PROTO.nativeFunc.id = this.functionCounter_++;\r\n  this.setProperty(this.FUNCTION_PROTO, 'length', 0,\r\n      Interpreter.READONLY_DESCRIPTOR);\r\n\r\n  var boxThis = function(value) {\r\n    // In non-strict mode 'this' must be an object.\r\n    if ((!value || !value.isObject) && !thisInterpreter.getScope().strict) {\r\n      if (value === undefined || value === null) {\r\n        // 'Undefined' and 'null' are changed to global object.\r\n        value = thisInterpreter.global;\r\n      } else {\r\n        // Primitives must be boxed in non-strict mode.\r\n        var box = thisInterpreter.createObjectProto(\r\n            thisInterpreter.getPrototype(value));\r\n        box.data = value;\r\n        value = box;\r\n      }\r\n    }\r\n    return value;\r\n  };\r\n\r\n  wrapper = function(thisArg, args) {\r\n    var state =\r\n        thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\r\n    // Rewrite the current 'CallExpression' to apply a different function.\r\n    state.func_ = this;\r\n    // Assign the 'this' object.\r\n    state.funcThis_ = boxThis(thisArg);\r\n    // Bind any provided arguments.\r\n    state.arguments_ = [];\r\n    if (args !== null && args !== undefined) {\r\n      if (args.isObject) {\r\n        state.arguments_ = thisInterpreter.pseudoToNative(args);\r\n      } else {\r\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n            'CreateListFromArrayLike called on non-object');\r\n      }\r\n    }\r\n    state.doneExec_ = false;\r\n  };\r\n  this.setNativeFunctionPrototype(this.FUNCTION, 'apply', wrapper);\r\n\r\n  wrapper = function(thisArg, var_args) {\r\n    var state =\r\n        thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\r\n    // Rewrite the current 'CallExpression' to call a different function.\r\n    state.func_ = this;\r\n    // Assign the 'this' object.\r\n    state.funcThis_ = boxThis(thisArg);\r\n    // Bind any provided arguments.\r\n    state.arguments_ = [];\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      state.arguments_.push(arguments[i]);\r\n    }\r\n    state.doneExec_ = false;\r\n  };\r\n  this.setNativeFunctionPrototype(this.FUNCTION, 'call', wrapper);\r\n\r\n  this.polyfills_.push(\r\n// Polyfill copied from:\r\n// developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\r\n\"Object.defineProperty(Function.prototype, 'bind',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(oThis) {\",\r\n    \"if (typeof this !== 'function') {\",\r\n      \"throw TypeError('What is trying to be bound is not callable');\",\r\n    \"}\",\r\n    \"var aArgs   = Array.prototype.slice.call(arguments, 1),\",\r\n        \"fToBind = this,\",\r\n        \"fNOP    = function() {},\",\r\n        \"fBound  = function() {\",\r\n          \"return fToBind.apply(this instanceof fNOP\",\r\n                 \"? this\",\r\n                 \": oThis,\",\r\n                 \"aArgs.concat(Array.prototype.slice.call(arguments)));\",\r\n        \"};\",\r\n    \"if (this.prototype) {\",\r\n      \"fNOP.prototype = this.prototype;\",\r\n    \"}\",\r\n    \"fBound.prototype = new fNOP();\",\r\n    \"return fBound;\",\r\n  \"}\",\r\n\"});\",\r\n\"\");\r\n\r\n  // Function has no parent to inherit from, so it needs its own mandatory\r\n  // toString and valueOf functions.\r\n  wrapper = function() {\r\n    return this.toString();\r\n  };\r\n  this.setNativeFunctionPrototype(this.FUNCTION, 'toString', wrapper);\r\n  this.setProperty(this.FUNCTION, 'toString',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  wrapper = function() {\r\n    return this.valueOf();\r\n  };\r\n  this.setNativeFunctionPrototype(this.FUNCTION, 'valueOf', wrapper);\r\n  this.setProperty(this.FUNCTION, 'valueOf',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n};\r\n\r\n/**\r\n * Initialize the Object class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initObject(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // Object constructor.\r\n  wrapper = function(value) {\r\n    if (value === undefined || value === null) {\r\n      // Create a new object.\r\n      if (thisInterpreter.calledWithNew()) {\r\n        // Called as new Object().\r\n        return this;\r\n      } else {\r\n        // Called as Object().\r\n        return thisInterpreter.createObjectProto(thisInterpreter.OBJECT_PROTO);\r\n      }\r\n    }\r\n    if (!value.isObject) {\r\n      // Wrap the value as an object.\r\n      var box = thisInterpreter.createObjectProto(\r\n          thisInterpreter.getPrototype(value));\r\n      box.data = value;\r\n      return box;\r\n    }\r\n    // Return the provided object.\r\n    return value;\r\n  };\r\n  this.OBJECT = this.createNativeFunction(wrapper, true);\r\n  // Throw away the created prototype and use the root prototype.\r\n  this.setProperty(this.OBJECT, 'prototype', this.OBJECT_PROTO);\r\n  this.setProperty(this.OBJECT_PROTO, 'constructor', this.OBJECT);\r\n  this.setProperty(scope, 'Object', this.OBJECT);\r\n\r\n  /**\r\n   * Checks if the provided value is null or undefined.\r\n   * If so, then throw an error in the call stack.\r\n   * @param {Interpreter.MyValue} value Value to check.\r\n   */\r\n  var throwIfNullUndefined = function(value) {\r\n    if (value === undefined || value === null) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          \"Cannot convert '\" + value + \"' to object\");\r\n    }\r\n  };\r\n\r\n  // Static methods on Object.\r\n  wrapper = function(obj) {\r\n    throwIfNullUndefined(obj);\r\n    var props = obj.isObject ? obj.properties : obj;\r\n    return thisInterpreter.nativeToPseudo(Object.getOwnPropertyNames(props));\r\n  };\r\n  this.setProperty(this.OBJECT, 'getOwnPropertyNames',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(obj) {\r\n    throwIfNullUndefined(obj);\r\n    if (!obj.isObject) {\r\n      return thisInterpreter.nativeToPseudo(Object.keys(obj));\r\n    }\r\n    return thisInterpreter.nativeToPseudo(Object.keys(obj.properties));\r\n  };\r\n  this.setProperty(this.OBJECT, 'keys',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(proto) {\r\n    // Support for the second argument is the responsibility of a polyfill.\r\n    if (proto === null) {\r\n      return thisInterpreter.createObjectProto(null);\r\n    }\r\n    if (proto === undefined || !proto.isObject) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          'Object prototype may only be an Object or null');\r\n    }\r\n    return thisInterpreter.createObjectProto(proto);\r\n  };\r\n  this.setProperty(this.OBJECT, 'create',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Add a polyfill to handle create's second argument.\r\n  this.polyfills_.push(\r\n\"(function() {\",\r\n  \"var create_ = Object.create;\",\r\n  \"Object.create = function(proto, props) {\",\r\n    \"var obj = create_(proto);\",\r\n    \"props && Object.defineProperties(obj, props);\",\r\n    \"return obj;\",\r\n  \"};\",\r\n\"})();\",\r\n\"\");\r\n\r\n  wrapper = function(obj, prop, descriptor) {\r\n    prop = String(prop);\r\n    if (!obj || !obj.isObject) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          'Object.defineProperty called on non-object');\r\n    }\r\n    if (!descriptor || !descriptor.isObject) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          'Property description must be an object');\r\n    }\r\n    if (!obj.properties[prop] && obj.preventExtensions) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          \"Can't define property '\" + prop + \"', object is not extensible\");\r\n    }\r\n    // The polyfill guarantees no inheritance and no getter functions.\r\n    // Therefore the descriptor properties map is the native object needed.\r\n    thisInterpreter.setProperty(obj, prop, ReferenceError,\r\n                                descriptor.properties);\r\n    return obj;\r\n  };\r\n  this.setProperty(this.OBJECT, 'defineProperty',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  this.polyfills_.push(\r\n// Flatten the descriptor to remove any inheritance or getter functions.\r\n\"(function() {\",\r\n  \"var defineProperty_ = Object.defineProperty;\",\r\n  \"Object.defineProperty = function(obj, prop, d1) {\",\r\n    \"var d2 = {};\",\r\n    \"if ('configurable' in d1) d2.configurable = d1.configurable;\",\r\n    \"if ('enumerable' in d1) d2.enumerable = d1.enumerable;\",\r\n    \"if ('writable' in d1) d2.writable = d1.writable;\",\r\n    \"if ('value' in d1) d2.value = d1.value;\",\r\n    \"if ('get' in d1) d2.get = d1.get;\",\r\n    \"if ('set' in d1) d2.set = d1.set;\",\r\n    \"return defineProperty_(obj, prop, d2);\",\r\n  \"};\",\r\n\"})();\",\r\n\r\n\"Object.defineProperty(Object, 'defineProperties',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(obj, props) {\",\r\n    \"var keys = Object.keys(props);\",\r\n    \"for (var i = 0; i < keys.length; i++) {\",\r\n      \"Object.defineProperty(obj, keys[i], props[keys[i]]);\",\r\n    \"}\",\r\n    \"return obj;\",\r\n  \"}\",\r\n\"});\",\r\n\"\");\r\n\r\n  wrapper = function(obj, prop) {\r\n    if (!obj || !obj.isObject) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          'Object.getOwnPropertyDescriptor called on non-object');\r\n    }\r\n    prop = String(prop);\r\n    if (!(prop in obj.properties)) {\r\n      return undefined;\r\n    }\r\n    var descriptor = Object.getOwnPropertyDescriptor(obj.properties, prop);\r\n    var getter = obj.getter[prop];\r\n    var setter = obj.setter[prop];\r\n\r\n    if (getter || setter) {\r\n      descriptor.get = getter;\r\n      descriptor.set = setter;\r\n      delete descriptor.value;\r\n      delete descriptor.writable;\r\n    }\r\n    var pseudoDescriptor = <Interpreter.MyObject>thisInterpreter.nativeToPseudo(descriptor);\r\n    if ('value' in descriptor) {\r\n      thisInterpreter.setProperty(pseudoDescriptor, 'value', descriptor.value);\r\n    }\r\n    return pseudoDescriptor;\r\n  };\r\n  this.setProperty(this.OBJECT, 'getOwnPropertyDescriptor',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(obj) {\r\n    throwIfNullUndefined(obj);\r\n    return thisInterpreter.getPrototype(obj);\r\n  };\r\n  this.setProperty(this.OBJECT, 'getPrototypeOf',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(obj) {\r\n    return Boolean(obj) && !obj.preventExtensions;\r\n  };\r\n  this.setProperty(this.OBJECT, 'isExtensible',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(obj) {\r\n    if (obj && obj.isObject) {\r\n      obj.preventExtensions = true;\r\n    }\r\n    return obj;\r\n  };\r\n  this.setProperty(this.OBJECT, 'preventExtensions',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Instance methods on Object.\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'toString',\r\n      Interpreter.MyObject.prototype.toString);\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'toLocaleString',\r\n      Interpreter.MyObject.prototype.toString);\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'valueOf',\r\n      Interpreter.MyObject.prototype.valueOf);\r\n\r\n  wrapper = function(prop) {\r\n    throwIfNullUndefined(this);\r\n    if (!this.isObject) {\r\n      return this.hasOwnProperty(prop);\r\n    }\r\n    return String(prop) in this.properties;\r\n  };\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'hasOwnProperty', wrapper);\r\n\r\n  wrapper = function(prop) {\r\n    throwIfNullUndefined(this);\r\n    return Object.prototype.propertyIsEnumerable.call(this.properties, prop);\r\n  };\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'propertyIsEnumerable', wrapper);\r\n\r\n  wrapper = function(obj) {\r\n    while (true) {\r\n      // Note, circular loops shouldn't be possible.\r\n      obj = thisInterpreter.getPrototype(obj);\r\n      if (!obj) {\r\n        // No parent; reached the top.\r\n        return false;\r\n      }\r\n      if (obj === this) {\r\n        return true;\r\n      }\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'isPrototypeOf',  wrapper);\r\n};\r\n\r\n/**\r\n * Initialize the Array class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initArray(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var getInt = function(obj, def) {\r\n    // Return an integer, or the default.\r\n    var n = obj ? Math.floor(obj) : def;\r\n    if (isNaN(n)) {\r\n      n = def;\r\n    }\r\n    return n;\r\n  };\r\n  var wrapper;\r\n  // Array constructor.\r\n  wrapper = function(var_args) {\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Array().\r\n      var newArray = <Interpreter.MyObject>this;\r\n    } else {\r\n      // Called as Array().\r\n      var newArray =\r\n          thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\r\n    }\r\n    var first = arguments[0];\r\n    if (arguments.length === 1 && typeof first === 'number') {\r\n      if (isNaN(Interpreter.legalArrayLength(first))) {\r\n        thisInterpreter.throwException(thisInterpreter.RANGE_ERROR,\r\n                                       'Invalid array length');\r\n      }\r\n      newArray.properties.length = first;\r\n    } else {\r\n      for (var i = 0; i < arguments.length; i++) {\r\n        newArray.properties[i] = arguments[i];\r\n      }\r\n      newArray.properties.length = i;\r\n    }\r\n    return newArray;\r\n  };\r\n  this.ARRAY = this.createNativeFunction(wrapper, true);\r\n  this.ARRAY_PROTO = this.ARRAY.properties['prototype'];\r\n  this.setProperty(scope, 'Array', this.ARRAY);\r\n\r\n  // Static methods on Array.\r\n  wrapper = function(obj) {\r\n    return obj && obj.class === 'Array';\r\n  };\r\n  this.setProperty(this.ARRAY, 'isArray',\r\n                   this.createNativeFunction(wrapper, false),\r\n                   Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Instance methods on Array.\r\n  wrapper = function() {\r\n    return Array.prototype.pop.call(this.properties);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'pop', wrapper);\r\n\r\n  wrapper = function(var_args) {\r\n    return Array.prototype.push.apply(this.properties, arguments);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'push', wrapper);\r\n\r\n  wrapper = function() {\r\n    return Array.prototype.shift.call(this.properties);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'shift', wrapper);\r\n\r\n  wrapper = function(var_args) {\r\n    return Array.prototype.unshift.apply(this.properties, arguments);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'unshift', wrapper);\r\n\r\n  wrapper = function() {\r\n    Array.prototype.reverse.call(this.properties);\r\n    return this;\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'reverse', wrapper);\r\n\r\n  wrapper = function(index, howmany /*, var_args*/) {\r\n    var list = Array.prototype.splice.apply(this.properties, arguments);\r\n    return thisInterpreter.nativeToPseudo(list);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'splice', wrapper);\r\n\r\n  wrapper = function(opt_begin, opt_end) {\r\n    var list = Array.prototype.slice.call(this.properties, opt_begin, opt_end);\r\n    return thisInterpreter.nativeToPseudo(list);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'slice', wrapper);\r\n\r\n  wrapper = function(opt_separator) {\r\n    return Array.prototype.join.call(this.properties, opt_separator);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'join', wrapper);\r\n\r\n  wrapper = function(var_args) {\r\n    var list = [];\r\n    var length = 0;\r\n    // Start by copying the current array.\r\n    var iLength = thisInterpreter.getProperty(this, 'length');\r\n    for (var i = 0; i < iLength; i++) {\r\n      if (thisInterpreter.hasProperty(this, i)) {\r\n        var element = thisInterpreter.getProperty(this, i);\r\n        list[length] = element;\r\n      }\r\n      length++;\r\n    }\r\n    // Loop through all arguments and copy them in.\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      var value = arguments[i];\r\n      if (thisInterpreter.isa(value, thisInterpreter.ARRAY)) {\r\n        var jLength = thisInterpreter.getProperty(value, 'length');\r\n        for (var j = 0; j < jLength; j++) {\r\n          if (thisInterpreter.hasProperty(value, j)) {\r\n            list[length] = thisInterpreter.getProperty(value, j);\r\n          }\r\n          length++;\r\n        }\r\n      } else {\r\n        list[length] = value;\r\n      }\r\n    }\r\n    return thisInterpreter.nativeToPseudo(list);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'concat', wrapper);\r\n\r\n  wrapper = function(searchElement, opt_fromIndex) {\r\n    return Array.prototype.indexOf.apply(this.properties, arguments);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'indexOf', wrapper);\r\n\r\n  wrapper = function(searchElement, opt_fromIndex) {\r\n    return Array.prototype.lastIndexOf.apply(this.properties, arguments);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'lastIndexOf', wrapper);\r\n\r\n  wrapper = function() {\r\n    Array.prototype.sort.call(this.properties);\r\n    return this;\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'sort', wrapper);\r\n\r\n  this.polyfills_.push(\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/every\r\n\"Object.defineProperty(Array.prototype, 'every',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callbackfn, thisArg) {\",\r\n    \"if (!this || typeof callbackfn !== 'function') throw TypeError();\",\r\n    \"var T, k;\",\r\n    \"var O = Object(this);\",\r\n    \"var len = O.length >>> 0;\",\r\n    \"if (arguments.length > 1) T = thisArg;\",\r\n    \"k = 0;\",\r\n    \"while (k < len) {\",\r\n      \"if (k in O && !callbackfn.call(T, O[k], k, O)) return false;\",\r\n      \"k++;\",\r\n    \"}\",\r\n    \"return true;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\r\n\"Object.defineProperty(Array.prototype, 'filter',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(fun/*, thisArg*/) {\",\r\n    \"if (this === void 0 || this === null || typeof fun !== 'function') throw TypeError();\",\r\n    \"var t = Object(this);\",\r\n    \"var len = t.length >>> 0;\",\r\n    \"var res = [];\",\r\n    \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\",\r\n    \"for (var i = 0; i < len; i++) {\",\r\n      \"if (i in t) {\",\r\n        \"var val = t[i];\",\r\n        \"if (fun.call(thisArg, val, i, t)) res.push(val);\",\r\n      \"}\",\r\n    \"}\",\r\n    \"return res;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n\"Object.defineProperty(Array.prototype, 'forEach',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callback, thisArg) {\",\r\n    \"if (!this || typeof callback !== 'function') throw TypeError();\",\r\n    \"var T, k;\",\r\n    \"var O = Object(this);\",\r\n    \"var len = O.length >>> 0;\",\r\n    \"if (arguments.length > 1) T = thisArg;\",\r\n    \"k = 0;\",\r\n    \"while (k < len) {\",\r\n      \"if (k in O) callback.call(T, O[k], k, O);\",\r\n      \"k++;\",\r\n    \"}\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map\r\n\"Object.defineProperty(Array.prototype, 'map',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callback, thisArg) {\",\r\n    \"if (!this || typeof callback !== 'function') new TypeError;\",\r\n    \"var T, A, k;\",\r\n    \"var O = Object(this);\",\r\n    \"var len = O.length >>> 0;\",\r\n    \"if (arguments.length > 1) T = thisArg;\",\r\n    \"A = new Array(len);\",\r\n    \"k = 0;\",\r\n    \"while (k < len) {\",\r\n      \"if (k in O) A[k] = callback.call(T, O[k], k, O);\",\r\n      \"k++;\",\r\n    \"}\",\r\n    \"return A;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\r\n\"Object.defineProperty(Array.prototype, 'reduce',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callback /*, initialValue*/) {\",\r\n    \"if (!this || typeof callback !== 'function') throw TypeError();\",\r\n    \"var t = Object(this), len = t.length >>> 0, k = 0, value;\",\r\n    \"if (arguments.length === 2) {\",\r\n      \"value = arguments[1];\",\r\n    \"} else {\",\r\n      \"while (k < len && !(k in t)) k++;\",\r\n      \"if (k >= len) {\",\r\n        \"throw TypeError('Reduce of empty array with no initial value');\",\r\n      \"}\",\r\n      \"value = t[k++];\",\r\n    \"}\",\r\n    \"for (; k < len; k++) {\",\r\n      \"if (k in t) value = callback(value, t[k], k, t);\",\r\n    \"}\",\r\n    \"return value;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\r\n\"Object.defineProperty(Array.prototype, 'reduceRight',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callback /*, initialValue*/) {\",\r\n    \"if (null === this || 'undefined' === typeof this || 'function' !== typeof callback) throw TypeError();\",\r\n    \"var t = Object(this), len = t.length >>> 0, k = len - 1, value;\",\r\n    \"if (arguments.length >= 2) {\",\r\n      \"value = arguments[1];\",\r\n    \"} else {\",\r\n      \"while (k >= 0 && !(k in t)) k--;\",\r\n      \"if (k < 0) {\",\r\n        \"throw TypeError('Reduce of empty array with no initial value');\",\r\n      \"}\",\r\n      \"value = t[k--];\",\r\n    \"}\",\r\n    \"for (; k >= 0; k--) {\",\r\n      \"if (k in t) value = callback(value, t[k], k, t);\",\r\n    \"}\",\r\n    \"return value;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/some\r\n\"Object.defineProperty(Array.prototype, 'some',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(fun/*, thisArg*/) {\",\r\n    \"if (!this || typeof fun !== 'function') throw TypeError();\",\r\n    \"var t = Object(this);\",\r\n    \"var len = t.length >>> 0;\",\r\n    \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\",\r\n    \"for (var i = 0; i < len; i++) {\",\r\n      \"if (i in t && fun.call(thisArg, t[i], i, t)) {\",\r\n        \"return true;\",\r\n      \"}\",\r\n    \"}\",\r\n    \"return false;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n\r\n\"(function() {\",\r\n  \"var sort_ = Array.prototype.sort;\",\r\n  \"Array.prototype.sort = function(opt_comp) {\",\r\n    // Fast native sort.\r\n    \"if (typeof opt_comp !== 'function') {\",\r\n      \"return sort_.call(this);\",\r\n    \"}\",\r\n    // Slow bubble sort.\r\n    \"for (var i = 0; i < this.length; i++) {\",\r\n      \"var changes = 0;\",\r\n      \"for (var j = 0; j < this.length - i - 1; j++) {\",\r\n        \"if (opt_comp(this[j], this[j + 1]) > 0) {\",\r\n          \"var swap = this[j];\",\r\n          \"this[j] = this[j + 1];\",\r\n          \"this[j + 1] = swap;\",\r\n          \"changes++;\",\r\n        \"}\",\r\n      \"}\",\r\n      \"if (!changes) break;\",\r\n    \"}\",\r\n    \"return this;\",\r\n  \"};\",\r\n\"})();\",\r\n\r\n\"Object.defineProperty(Array.prototype, 'toLocaleString',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function() {\",\r\n    \"var out = [];\",\r\n    \"for (var i = 0; i < this.length; i++) {\",\r\n      \"out[i] = (this[i] === null || this[i] === undefined) ? '' : this[i].toLocaleString();\",\r\n    \"}\",\r\n    \"return out.join(',');\",\r\n  \"}\",\r\n\"});\",\r\n\"\");\r\n};\r\n\r\n/**\r\n * Initialize the String class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initString(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // String constructor.\r\n  wrapper = function(value) {\r\n    value = String(value);\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new String().\r\n      this.data = value;\r\n      return this;\r\n    } else {\r\n      // Called as String().\r\n      return value;\r\n    }\r\n  };\r\n  this.STRING = this.createNativeFunction(wrapper, true);\r\n  this.setProperty(scope, 'String', this.STRING);\r\n\r\n  // Static methods on String.\r\n  this.setProperty(this.STRING, 'fromCharCode',\r\n      this.createNativeFunction(String.fromCharCode, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Instance methods on String.\r\n  // Methods with exclusively primitive arguments.\r\n  var functions = ['trim', 'toLowerCase', 'toUpperCase',\r\n      'toLocaleLowerCase', 'toLocaleUpperCase', 'charAt', 'charCodeAt',\r\n      'substring', 'slice', 'substr', 'indexOf', 'lastIndexOf', 'concat'];\r\n  for (var i = 0; i < functions.length; i++) {\r\n    this.setNativeFunctionPrototype(this.STRING, functions[i],\r\n                                    String.prototype[functions[i]]);\r\n  }\r\n\r\n  wrapper = function(compareString, locales, options) {\r\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\r\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\r\n    return String(this).localeCompare(compareString, locales, options);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'localeCompare', wrapper);\r\n\r\n  wrapper = function(separator, limit) {\r\n    if (thisInterpreter.isa(separator, thisInterpreter.REGEXP)) {\r\n      separator = separator.data;\r\n    }\r\n    var jsList = String(this).split(separator, limit);\r\n    return thisInterpreter.nativeToPseudo(jsList);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'split', wrapper);\r\n\r\n  wrapper = function(regexp) {\r\n    regexp = regexp ? regexp.data : undefined;\r\n    var match = String(this).match(regexp);\r\n    if (!match) {\r\n      return null;\r\n    }\r\n    return thisInterpreter.nativeToPseudo(match);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'match', wrapper);\r\n\r\n  wrapper = function(regexp) {\r\n    regexp = regexp ? regexp.data : undefined;\r\n    return String(this).search(regexp);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'search', wrapper);\r\n\r\n  wrapper = function(substr, newSubstr) {\r\n    // Support for function replacements is the responsibility of a polyfill.\r\n    return String(this).replace(substr.data || substr, newSubstr);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'replace', wrapper);\r\n  // Add a polyfill to handle replace's second argument being a function.\r\n  this.polyfills_.push(\r\n\"(function() {\",\r\n  \"var replace_ = String.prototype.replace;\",\r\n  \"String.prototype.replace = function(substr, newSubstr) {\",\r\n    \"if (typeof newSubstr !== 'function') {\",\r\n      // string.replace(string|regexp, string)\r\n      \"return replace_.call(this, substr, newSubstr);\",\r\n    \"}\",\r\n    \"var str = this;\",\r\n    \"if (substr instanceof RegExp) {\",  // string.replace(regexp, function)\r\n      \"var subs = [];\",\r\n      \"var m = substr.exec(str);\",\r\n      \"while (m) {\",\r\n        \"m.push(m.index, str);\",\r\n        \"var inject = newSubstr.apply(null, m);\",\r\n        \"subs.push([m.index, m[0].length, inject]);\",\r\n        \"m = substr.global ? substr.exec(str) : null;\",\r\n      \"}\",\r\n      \"for (var i = subs.length - 1; i >= 0; i--) {\",\r\n        \"str = str.substring(0, subs[i][0]) + subs[i][2] + \" +\r\n            \"str.substring(subs[i][0] + subs[i][1]);\",\r\n      \"}\",\r\n    \"} else {\",                         // string.replace(string, function)\r\n      \"var i = str.indexOf(substr);\",\r\n      \"if (i !== -1) {\",\r\n        \"var inject = newSubstr(str.substr(i, substr.length), i, str);\",\r\n        \"str = str.substring(0, i) + inject + \" +\r\n            \"str.substring(i + substr.length);\",\r\n      \"}\",\r\n    \"}\",\r\n    \"return str;\",\r\n  \"};\",\r\n\"})();\",\r\n\"\");\r\n};\r\n\r\n/**\r\n * Initialize the Boolean class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initBoolean(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // Boolean constructor.\r\n  wrapper = function(value) {\r\n    value = Boolean(value);\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Boolean().\r\n      this.data = value;\r\n      return this;\r\n    } else {\r\n      // Called as Boolean().\r\n      return value;\r\n    }\r\n  };\r\n  this.BOOLEAN = this.createNativeFunction(wrapper, true);\r\n  this.setProperty(scope, 'Boolean', this.BOOLEAN);\r\n};\r\n\r\n/**\r\n * Initialize the Number class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initNumber(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // Number constructor.\r\n  wrapper = function(value) {\r\n    value = Number(value);\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Number().\r\n      this.data = value;\r\n      return this;\r\n    } else {\r\n      // Called as Number().\r\n      return value;\r\n    }\r\n  };\r\n  this.NUMBER = this.createNativeFunction(wrapper, true);\r\n  this.setProperty(scope, 'Number', this.NUMBER);\r\n\r\n  var numConsts = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY',\r\n                   'POSITIVE_INFINITY'];\r\n  for (var i = 0; i < numConsts.length; i++) {\r\n    this.setProperty(this.NUMBER, numConsts[i], Number[numConsts[i]],\r\n        Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n\r\n  // Instance methods on Number.\r\n  wrapper = function(fractionDigits) {\r\n    try {\r\n      return Number(this).toExponential(fractionDigits);\r\n    } catch (e) {\r\n      // Throws if fractionDigits isn't within 0-20.\r\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toExponential', wrapper);\r\n\r\n  wrapper = function(digits) {\r\n    try {\r\n      return Number(this).toFixed(digits);\r\n    } catch (e) {\r\n      // Throws if digits isn't within 0-20.\r\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toFixed', wrapper);\r\n\r\n  wrapper = function(precision) {\r\n    try {\r\n      return Number(this).toPrecision(precision);\r\n    } catch (e) {\r\n      // Throws if precision isn't within range (depends on implementation).\r\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toPrecision', wrapper);\r\n\r\n  wrapper = function(radix) {\r\n    try {\r\n      return Number(this).toString(radix);\r\n    } catch (e) {\r\n      // Throws if radix isn't within 2-36.\r\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toString', wrapper);\r\n\r\n  wrapper = function(locales, options) {\r\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\r\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\r\n    return Number(this).toLocaleString(locales, options);\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toLocaleString', wrapper);\r\n};\r\n\r\n/**\r\n * Initialize the Date class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initDate(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // Date constructor.\r\n  wrapper = function(value, var_args) {\r\n    if (!thisInterpreter.calledWithNew()) {\r\n      // Called as Date().\r\n      // Calling Date() as a function returns a string, no arguments are heeded.\r\n      return Date();\r\n    }\r\n    // Called as new Date().\r\n    var args = [null].concat([].slice.call(arguments));\r\n    this.data = new (Function.prototype.bind.apply(Date, args));\r\n    return this;\r\n  };\r\n  this.DATE = this.createNativeFunction(wrapper, true);\r\n  this.setProperty(scope, 'Date', this.DATE);\r\n\r\n  // Static methods on Date.\r\n  this.setProperty(this.DATE, 'now', this.createNativeFunction(Date.now, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  this.setProperty(this.DATE, 'parse',\r\n      this.createNativeFunction(Date.parse, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  this.setProperty(this.DATE, 'UTC', this.createNativeFunction(Date.UTC, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Instance methods on Date.\r\n  var functions = ['getDate', 'getDay', 'getFullYear', 'getHours',\r\n      'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTime',\r\n      'getTimezoneOffset', 'getUTCDate', 'getUTCDay', 'getUTCFullYear',\r\n      'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth',\r\n      'getUTCSeconds', 'getYear',\r\n      'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\r\n      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate',\r\n      'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes',\r\n      'setUTCMonth', 'setUTCSeconds', 'setYear',\r\n      'toDateString', 'toISOString', 'toJSON', 'toGMTString',\r\n      'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString',\r\n      'toTimeString', 'toUTCString'];\r\n  for (var i = 0; i < functions.length; i++) {\r\n    wrapper = (function(nativeFunc) {\r\n      return function(var_args) {\r\n        var args = [];\r\n        for (var i = 0; i < arguments.length; i++) {\r\n          args[i] = thisInterpreter.pseudoToNative(arguments[i]);\r\n        }\r\n        return this.data[nativeFunc].apply(this.data, args);\r\n      };\r\n    })(functions[i]);\r\n    this.setNativeFunctionPrototype(this.DATE, functions[i], wrapper);\r\n  }\r\n};\r\n\r\n/**\r\n * Initialize Regular Expression object.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initRegExp(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // RegExp constructor.\r\n  wrapper = function(pattern, flags) {\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new RegExp().\r\n      var rgx = <Interpreter.MyObject>this;\r\n    } else {\r\n      // Called as RegExp().\r\n      var rgx = thisInterpreter.createObjectProto(thisInterpreter.REGEXP_PROTO);\r\n    }\r\n    pattern = pattern ? pattern.toString() : '';\r\n    flags = flags ? flags.toString() : '';\r\n    thisInterpreter.populateRegExp(rgx, new RegExp(pattern, flags));\r\n    return rgx;\r\n  };\r\n  this.REGEXP = this.createNativeFunction(wrapper, true);\r\n  this.REGEXP_PROTO = this.REGEXP.properties['prototype'];\r\n  this.setProperty(scope, 'RegExp', this.REGEXP);\r\n\r\n  this.setProperty(this.REGEXP.properties['prototype'], 'global', undefined,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(this.REGEXP.properties['prototype'], 'ignoreCase', undefined,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(this.REGEXP.properties['prototype'], 'multiline', undefined,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(this.REGEXP.properties['prototype'], 'source', '(?:)',\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(str) {\r\n    return this.data.test(str);\r\n  };\r\n  this.setNativeFunctionPrototype(this.REGEXP, 'test', wrapper);\r\n\r\n  wrapper = function(str) {\r\n    str = str.toString();\r\n    // Get lastIndex from wrapped regex, since this is settable.\r\n    this.data.lastIndex =\r\n        Number(thisInterpreter.getProperty(this, 'lastIndex'));\r\n    var match = this.data.exec(str);\r\n    thisInterpreter.setProperty(this, 'lastIndex', this.data.lastIndex);\r\n\r\n    if (match) {\r\n      var result =\r\n          thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\r\n      for (var i = 0; i < match.length; i++) {\r\n        thisInterpreter.setProperty(result, i, match[i]);\r\n      }\r\n      // match has additional properties.\r\n      thisInterpreter.setProperty(result, 'index', match.index);\r\n      thisInterpreter.setProperty(result, 'input', match.input);\r\n      return result;\r\n    }\r\n    return null;\r\n  };\r\n  this.setNativeFunctionPrototype(this.REGEXP, 'exec', wrapper);\r\n};\r\n\r\n/**\r\n * Initialize the Error class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initError(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  // Error constructor.\r\n  this.ERROR = this.createNativeFunction(function(opt_message) {\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Error().\r\n      var newError = <Interpreter.MyObject>this;\r\n    } else {\r\n      // Called as Error().\r\n      var newError = thisInterpreter.createObject(thisInterpreter.ERROR);\r\n    }\r\n    if (opt_message) {\r\n      thisInterpreter.setProperty(newError, 'message', String(opt_message),\r\n          Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n    }\r\n    return newError;\r\n  }, true);\r\n  this.setProperty(scope, 'Error', this.ERROR);\r\n  this.setProperty(this.ERROR.properties['prototype'], 'message', '',\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(this.ERROR.properties['prototype'], 'name', 'Error',\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  var createErrorSubclass = function(name) {\r\n    var constructor = thisInterpreter.createNativeFunction(\r\n        function(opt_message) {\r\n          if (thisInterpreter.calledWithNew()) {\r\n            // Called as new XyzError().\r\n            var newError = <Interpreter.MyObject>this;\r\n          } else {\r\n            // Called as XyzError().\r\n            var newError = thisInterpreter.createObject(constructor);\r\n          }\r\n          if (opt_message) {\r\n            thisInterpreter.setProperty(newError, 'message',\r\n                String(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n          }\r\n          return newError;\r\n        }, true);\r\n    thisInterpreter.setProperty(constructor, 'prototype',\r\n        thisInterpreter.createObject(thisInterpreter.ERROR));\r\n    thisInterpreter.setProperty(constructor.properties['prototype'], 'name',\r\n        name, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n    thisInterpreter.setProperty(scope, name, constructor);\r\n\r\n    return constructor;\r\n  };\r\n\r\n  this.EVAL_ERROR = createErrorSubclass('EvalError');\r\n  this.RANGE_ERROR = createErrorSubclass('RangeError');\r\n  this.REFERENCE_ERROR = createErrorSubclass('ReferenceError');\r\n  this.SYNTAX_ERROR = createErrorSubclass('SyntaxError');\r\n  this.TYPE_ERROR = createErrorSubclass('TypeError');\r\n  this.URI_ERROR = createErrorSubclass('URIError');\r\n};\r\n\r\n/**\r\n * Initialize Math object.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initMath(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var myMath = this.createObjectProto(this.OBJECT_PROTO);\r\n  this.setProperty(scope, 'Math', myMath);\r\n  var mathConsts = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI',\r\n                    'SQRT1_2', 'SQRT2'];\r\n  for (var i = 0; i < mathConsts.length; i++) {\r\n    this.setProperty(myMath, mathConsts[i], Math[mathConsts[i]],\r\n        Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n  var numFunctions = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos',\r\n                      'exp', 'floor', 'log', 'max', 'min', 'pow', 'random',\r\n                      'round', 'sin', 'sqrt', 'tan'];\r\n  for (var i = 0; i < numFunctions.length; i++) {\r\n    this.setProperty(myMath, numFunctions[i],\r\n        this.createNativeFunction(Math[numFunctions[i]], false),\r\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n};\r\n\r\n/**\r\n * Initialize JSON object.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initJSON(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var myJSON = thisInterpreter.createObjectProto(this.OBJECT_PROTO);\r\n  this.setProperty(scope, 'JSON', myJSON);\r\n\r\n  var wrapper = function(text) {\r\n    try {\r\n      var nativeObj = JSON.parse(text.toString());\r\n    } catch (e) {\r\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, e.message);\r\n    }\r\n    return thisInterpreter.nativeToPseudo(nativeObj);\r\n  };\r\n  this.setProperty(myJSON, 'parse', this.createNativeFunction(wrapper, false));\r\n\r\n  wrapper = function(value) {\r\n    var nativeObj = thisInterpreter.pseudoToNative(value);\r\n    try {\r\n      var str = JSON.stringify(nativeObj);\r\n    } catch (e) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, e.message);\r\n    }\r\n    return str;\r\n  };\r\n  this.setProperty(myJSON, 'stringify',\r\n      this.createNativeFunction(wrapper, false));\r\n};\r\n\r\n/**\r\n * Is an object of a certain class?\r\n * @param {Interpreter.MyValue} child Object to check.\r\n * @param {Interpreter.MyObject} constructor Constructor of object.\r\n * @return {boolean} True if object is the class or inherits from it.\r\n *     False otherwise.\r\n */\r\npublic isa(child: Interpreter.MyValue, constructor: Interpreter.MyObject) {\r\n  if (child === null || child === undefined || !constructor) {\r\n    return false;\r\n  }\r\n  var proto = constructor.properties['prototype'];\r\n  if (child === proto) {\r\n    return true;\r\n  }\r\n  // The first step up the prototype chain is harder since the child might be\r\n  // a primitive value.  Subsequent steps can just follow the .proto property.\r\n  var childObj = this.getPrototype(child);\r\n  while (childObj) {\r\n    if (childObj === proto) {\r\n      return true;\r\n    }\r\n    childObj = childObj.proto;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Is a value a legal integer for an array length?\r\n * @param {Interpreter.MyValue} x Value to check.\r\n * @return {number} Zero, or a positive integer if the value can be\r\n *     converted to such.  NaN otherwise.\r\n */\r\nstatic legalArrayLength(x: Interpreter.MyValue) {\r\n  var n = <number>x >>> 0;\r\n  // Array length must be between 0 and 2^32-1 (inclusive).\r\n  return (n === Number(x)) ? n : NaN;\r\n};\r\n\r\n/**\r\n * Is a value a legal integer for an array index?\r\n * @param {Interpreter.MyValue} x Value to check.\r\n * @return {number} Zero, or a positive integer if the value can be\r\n *     converted to such.  NaN otherwise.\r\n */\r\nstatic legalArrayIndex(x: Interpreter.MyValue) {\r\n  var n = <number>x >>> 0;\r\n  // Array index cannot be 2^32-1, otherwise length would be 2^32.\r\n  // 0xffffffff is 2^32-1.\r\n  return (String(n) === String(x) && n !== 0xffffffff) ? n : NaN;\r\n};\r\n\r\n/**\r\n * Create a new data object based on a constructor's prototype.\r\n * @param {Interpreter.MyObject} constructor Parent constructor function,\r\n *     or null if scope object.\r\n * @return {!Interpreter.MyObject} New data object.\r\n */\r\npublic createObject(constructor: Interpreter.MyObject) {\r\n  return this.createObjectProto(constructor &&\r\n                                constructor.properties['prototype']);\r\n};\r\n\r\n/**\r\n * Create a new data object based on a prototype.\r\n * @param {Interpreter.MyObject} proto Prototype object.\r\n * @return {!Interpreter.MyObject} New data object.\r\n */\r\npublic createObjectProto(proto: Interpreter.MyObject) {\r\n  var obj = new Interpreter.MyObject(proto);\r\n  // Functions have prototype objects.\r\n  if (this.isa(obj, this.FUNCTION)) {\r\n    this.setProperty(obj, 'prototype',\r\n                     this.createObjectProto(this.OBJECT_PROTO || null));\r\n    obj.class = 'Function';\r\n  }\r\n  // Arrays have length.\r\n  if (this.isa(obj, this.ARRAY)) {\r\n    this.setProperty(obj, 'length', 0,\r\n        {configurable: false, enumerable: false, writable: true});\r\n    obj.class = 'Array';\r\n  }\r\n  if (this.isa(obj, this.ERROR)) {\r\n    obj.class = 'Error';\r\n  }\r\n  return obj;\r\n};\r\n\r\n/**\r\n * Initialize a pseudo regular expression object based on a native regular\r\n * expression object.\r\n * @param {!Interpreter.MyObject} pseudoRegexp The existing object to set.\r\n * @param {!RegExp} nativeRegexp The native regular expression.\r\n */\r\npublic populateRegExp(pseudoRegexp: Interpreter.MyObject, nativeRegexp: RegExp) {\r\n  pseudoRegexp.data = nativeRegexp;\r\n  // lastIndex is settable, all others are read-only attributes\r\n  this.setProperty(pseudoRegexp, 'lastIndex', nativeRegexp.lastIndex,\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(pseudoRegexp, 'source', nativeRegexp.source,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(pseudoRegexp, 'global', nativeRegexp.global,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(pseudoRegexp, 'ignoreCase', nativeRegexp.ignoreCase,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(pseudoRegexp, 'multiline', nativeRegexp.multiline,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n};\r\n\r\n/**\r\n * Create a new function.\r\n * @param {!Object} node AST node defining the function.\r\n * @param {!Object} scope Parent scope.\r\n * @return {!Interpreter.MyObject} New function.\r\n */\r\npublic createFunction(node: ESTree.FunctionDeclaration, scope: Interpreter.MyObject) {\r\n  var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n  func.parentScope = scope;\r\n  func.node = node;\r\n  this.setProperty(func, 'length', func.node['params'].length,\r\n      Interpreter.READONLY_DESCRIPTOR);\r\n  return func;\r\n};\r\n\r\n/**\r\n * Create a new native function.\r\n * @param {!Function} nativeFunc JavaScript function.\r\n * @param {boolean=} opt_constructor If true, the function's\r\n * prototype will have its constructor property set to the function.\r\n * If false, the function cannot be called as a constructor (e.g. escape).\r\n * Defaults to undefined.\r\n * @return {!Interpreter.MyObject} New function.\r\n */\r\npublic createNativeFunction(nativeFunc: Interpreter.NativeFunction, opt_constructor?: boolean) {\r\n  var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n  func.nativeFunc = nativeFunc;\r\n  nativeFunc.id = this.functionCounter_++;\r\n  this.setProperty(func, 'length', nativeFunc.length,\r\n      Interpreter.READONLY_DESCRIPTOR);\r\n  if (opt_constructor) {\r\n    this.setProperty(func.properties['prototype'], 'constructor',\r\n        func, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  } else if (opt_constructor === false) {\r\n    func.illegalConstructor = true;\r\n    this.setProperty(func, 'prototype', undefined);\r\n  }\r\n  return func;\r\n};\r\n\r\n/**\r\n * Create a new native asynchronous function.\r\n * @param {!Function} asyncFunc JavaScript function.\r\n * @return {!Interpreter.MyObject} New function.\r\n */\r\npublic createAsyncFunction(asyncFunc) {\r\n  var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n  func.asyncFunc = asyncFunc;\r\n  asyncFunc.id = this.functionCounter_++;\r\n  this.setProperty(func, 'length', asyncFunc.length,\r\n      Interpreter.READONLY_DESCRIPTOR);\r\n  return func;\r\n};\r\n\r\n/**\r\n * Converts from a native JS object or value to a JS interpreter object.\r\n * Can handle JSON-style values.\r\n * @param {*} nativeObj The native JS object to be converted.\r\n * @return {Interpreter.MyValue} The equivalent JS interpreter object.\r\n */\r\npublic nativeToPseudo(nativeObj: any): Interpreter.MyValue {\r\n  if (typeof nativeObj === 'boolean' ||\r\n      typeof nativeObj === 'number' ||\r\n      typeof nativeObj === 'string' ||\r\n      nativeObj === null || nativeObj === undefined) {\r\n    return nativeObj;\r\n  }\r\n\r\n  if (nativeObj instanceof RegExp) {\r\n    var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\r\n    this.populateRegExp(pseudoRegexp, nativeObj);\r\n    return pseudoRegexp;\r\n  }\r\n\r\n  if (nativeObj instanceof Function) {\r\n    var interpreter = this;\r\n    var wrapper = function() {\r\n      return interpreter.nativeToPseudo(\r\n        nativeObj.apply(interpreter,\r\n          Array.prototype.slice.call(arguments)\r\n          .map(function(i) {\r\n            return interpreter.pseudoToNative(i);\r\n          })\r\n        )\r\n      );\r\n    };\r\n    return this.createNativeFunction(wrapper, undefined);\r\n  }\r\n\r\n  var pseudoObj: Interpreter.MyObject;\r\n  if (Array.isArray(nativeObj)) {  // Array.\r\n    pseudoObj = this.createObjectProto(this.ARRAY_PROTO);\r\n    for (var i = 0; i < nativeObj.length; i++) {\r\n      if (i in nativeObj) {\r\n        this.setProperty(pseudoObj, i, this.nativeToPseudo(nativeObj[i]));\r\n      }\r\n    }\r\n  } else {  // Object.\r\n    pseudoObj = this.createObjectProto(this.OBJECT_PROTO);\r\n    for (var key in nativeObj) {\r\n      this.setProperty(pseudoObj, key, this.nativeToPseudo(nativeObj[key]));\r\n    }\r\n  }\r\n  return pseudoObj;\r\n};\r\n\r\n/**\r\n * Converts from a JS interpreter object to native JS object.\r\n * Can handle JSON-style values, plus cycles.\r\n * @param {Interpreter.MyValue} pseudoObj The JS interpreter object to be\r\n * converted.\r\n * @param {Object=} opt_cycles Cycle detection (used in recursive calls).\r\n * @return {*} The equivalent native JS object or value.\r\n */\r\npublic pseudoToNative(pseudoObj: Interpreter.MyValue, opt_cycles?: Interpreter.MyValueTable) {\r\n  if (typeof pseudoObj === 'boolean' ||\r\n      typeof pseudoObj === 'number' ||\r\n      typeof pseudoObj === 'string' ||\r\n      pseudoObj === null || pseudoObj === undefined) {\r\n    return pseudoObj;\r\n  }\r\n\r\n  if (this.isa(pseudoObj, this.REGEXP)) {  // Regular expression.\r\n    return pseudoObj.data;\r\n  }\r\n\r\n  var cycles = opt_cycles || {\r\n    pseudo: [],\r\n    native: []\r\n  };\r\n  var i = cycles.pseudo.indexOf(pseudoObj);\r\n  if (i !== -1) {\r\n    return cycles.native[i];\r\n  }\r\n  cycles.pseudo.push(pseudoObj);\r\n  var nativeObj;\r\n  if (this.isa(pseudoObj, this.ARRAY)) {  // Array.\r\n    nativeObj = [];\r\n    cycles.native.push(nativeObj);\r\n    var length = this.getProperty(pseudoObj, 'length');\r\n    for (var i = 0; i < length; i++) {\r\n      if (this.hasProperty(pseudoObj, i)) {\r\n        nativeObj[i] =\r\n            this.pseudoToNative(this.getProperty(pseudoObj, i), cycles);\r\n      }\r\n    }\r\n  } else {  // Object.\r\n    nativeObj = {};\r\n    cycles.native.push(nativeObj);\r\n    var val;\r\n    for (var key in pseudoObj.properties) {\r\n      val = pseudoObj.properties[key];\r\n      nativeObj[key] = this.pseudoToNative(val, cycles);\r\n    }\r\n  }\r\n  cycles.pseudo.pop();\r\n  cycles.native.pop();\r\n  return nativeObj;\r\n};\r\n\r\n/**\r\n * Look up the prototype for this value.\r\n * @param {Interpreter.MyValue} value Data object.\r\n * @return {Interpreter.MyObject} Prototype object, null if none.\r\n */\r\npublic getPrototype(value: Interpreter.MyValue): Interpreter.MyObject {\r\n  switch (typeof value) {\r\n    case 'number':\r\n      return this.NUMBER.properties['prototype'];\r\n    case 'boolean':\r\n      return this.BOOLEAN.properties['prototype'];\r\n    case 'string':\r\n      return this.STRING.properties['prototype'];\r\n  }\r\n  if (value) {\r\n    return (<Interpreter.MyObject>value).proto;\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Fetch a property value from a data object.\r\n * @param {Interpreter.MyValue} obj Data object.\r\n * @param {Interpreter.MyValue} name Name of property.\r\n * @return {Interpreter.MyValue} Property value (may be undefined).\r\n */\r\npublic getProperty(obj: Interpreter.MyValue, name: Interpreter.MyValue): Interpreter.MyValue {\r\n  name = String(name);\r\n  if (obj === undefined || obj === null) {\r\n    this.throwException(this.TYPE_ERROR,\r\n                        \"Cannot read property '\" + name + \"' of \" + obj);\r\n  }\r\n  if (name === 'length') {\r\n    // Special cases for magic length property.\r\n    if (this.isa(obj, this.STRING)) {\r\n      return String(obj).length;\r\n    }\r\n  } else if (name.charCodeAt(0) < 0x40) {\r\n    // Might have numbers in there?\r\n    // Special cases for string array indexing\r\n    if (this.isa(obj, this.STRING)) {\r\n      var n = Interpreter.legalArrayIndex(name);\r\n      if (!isNaN(n) && n < String(obj).length) {\r\n        return String(obj)[n];\r\n      }\r\n    }\r\n  }\r\n  do {\r\n    const myObj = <Interpreter.MyObject>obj;\r\n    if (myObj.properties && name in myObj.properties) {\r\n      var getter = myObj.getter[name];\r\n      if (getter) {\r\n        // Flag this function as being a getter and thus needing immediate\r\n        // execution (rather than being the value of the property).\r\n        getter.isGetter = true;\r\n        return getter;\r\n      }\r\n      return myObj.properties[name];\r\n    }\r\n  } while ((obj = this.getPrototype(obj)));\r\n  return undefined;\r\n};\r\n\r\n/**\r\n * Does the named property exist on a data object.\r\n * @param {Interpreter.MyValue} obj Data object.\r\n * @param {Interpreter.MyValue} name Name of property.\r\n * @return {boolean} True if property exists.\r\n */\r\npublic hasProperty(obj: Interpreter.MyValue, name: Interpreter.MyValue) {\r\n  if (!obj['isObject']) {\r\n    throw TypeError('Primitive data type has no properties');\r\n  }\r\n  name = String(name);\r\n  if (name === 'length' && this.isa(obj, this.STRING)) {\r\n    return true;\r\n  }\r\n  if (this.isa(obj, this.STRING)) {\r\n    var n = Interpreter.legalArrayIndex(name);\r\n    if (!isNaN(n) && n < String(obj).length) {\r\n      return true;\r\n    }\r\n  }\r\n  do {\r\n    const myObj = <Interpreter.MyObject> obj;\r\n    if (myObj.properties && name in myObj.properties) {\r\n      return true;\r\n    }\r\n  } while ((obj = this.getPrototype(obj)));\r\n  return false;\r\n};\r\n\r\n/**\r\n * Set a property value on a data object.\r\n * @param {!Interpreter.MyObject} obj Data object.\r\n * @param {Interpreter.MyValue} name Name of property.\r\n * @param {Interpreter.MyValue|ReferenceError} value New property value.\r\n *   Use ReferenceError if value is handled by descriptor instead.\r\n * @param {Object=} opt_descriptor Optional descriptor object.\r\n * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n *     needs to be called, otherwise undefined.\r\n */\r\npublic setProperty(obj: Interpreter.MyObject, name: Interpreter.MyValue, value: Interpreter.MyValue | ReferenceErrorConstructor, opt_descriptor?): Interpreter.MyObject {\r\n  name = String(name);\r\n  if (obj === undefined || obj === null) {\r\n    this.throwException(this.TYPE_ERROR,\r\n                        \"Cannot set property '\" + name + \"' of \" + obj);\r\n  }\r\n  if (opt_descriptor && ('get' in opt_descriptor || 'set' in opt_descriptor) &&\r\n      ('value' in opt_descriptor || 'writable' in opt_descriptor)) {\r\n    this.throwException(this.TYPE_ERROR, 'Invalid property descriptor. ' +\r\n        'Cannot both specify accessors and a value or writable attribute');\r\n  }\r\n  var strict = !this.stateStack || this.getScope().strict;\r\n  if (!obj.isObject) {\r\n    if (strict) {\r\n      this.throwException(this.TYPE_ERROR, \"Can't create property '\" + name +\r\n                          \"' on '\" + obj + \"'\");\r\n    }\r\n    return;\r\n  }\r\n  if (this.isa(obj, this.STRING)) {\r\n    var n = Interpreter.legalArrayIndex(name);\r\n    if (name === 'length' || (!isNaN(n) && n < String(obj).length)) {\r\n      // Can't set length or letters on String objects.\r\n      if (strict) {\r\n        this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\r\n            \"property '\" + name + \"' of String '\" + obj.data + \"'\");\r\n      }\r\n      return;\r\n    }\r\n  }\r\n  if (obj.class === 'Array') {\r\n    // Arrays have a magic length variable that is bound to the elements.\r\n    var length = obj.properties.length;\r\n    var i;\r\n    if (name === 'length') {\r\n      // Delete elements if length is smaller.\r\n      value = Interpreter.legalArrayLength(<number>value);\r\n      if (isNaN(value)) {\r\n        this.throwException(this.RANGE_ERROR, 'Invalid array length');\r\n      }\r\n      if (value < length) {\r\n        for (i in obj.properties) {\r\n          i = Interpreter.legalArrayIndex(i);\r\n          if (!isNaN(i) && value <= i) {\r\n            delete obj.properties[i];\r\n          }\r\n        }\r\n      }\r\n    } else if (!isNaN(i = Interpreter.legalArrayIndex(name))) {\r\n      // Increase length if this index is larger.\r\n      obj.properties.length = Math.max(length, i + 1);\r\n    }\r\n  }\r\n  if (obj.preventExtensions && !(name in obj.properties)) {\r\n    if (strict) {\r\n      this.throwException(this.TYPE_ERROR, \"Can't add property '\" + name +\r\n                          \"', object is not extensible\");\r\n    }\r\n    return;\r\n  }\r\n  if (opt_descriptor) {\r\n    // Define the property.\r\n    if ('get' in opt_descriptor) {\r\n      if (opt_descriptor.get) {\r\n        obj.getter[name] = opt_descriptor.get;\r\n      } else {\r\n        delete obj.getter[name];\r\n      }\r\n    }\r\n    if ('set' in opt_descriptor) {\r\n      if (opt_descriptor.set) {\r\n        obj.setter[name] = opt_descriptor.set;\r\n      } else {\r\n        delete obj.setter[name];\r\n      }\r\n    }\r\n    var descriptor: {\r\n      configurable?: boolean;\r\n      enumerable?: boolean;\r\n      writable?: boolean;\r\n      value?: any;\r\n    } = {};\r\n    if ('configurable' in opt_descriptor) {\r\n      descriptor.configurable = opt_descriptor.configurable;\r\n    }\r\n    if ('enumerable' in opt_descriptor) {\r\n      descriptor.enumerable = opt_descriptor.enumerable;\r\n    }\r\n    if ('writable' in opt_descriptor) {\r\n      descriptor.writable = opt_descriptor.writable;\r\n      delete obj.getter[name];\r\n      delete obj.setter[name];\r\n    }\r\n    if ('value' in opt_descriptor) {\r\n      descriptor.value = opt_descriptor.value;\r\n      delete obj.getter[name];\r\n      delete obj.setter[name];\r\n    } else if (value !== ReferenceError) {\r\n      descriptor.value = value;\r\n      delete obj.getter[name];\r\n      delete obj.setter[name];\r\n    }\r\n    try {\r\n      Object.defineProperty(obj.properties, name, descriptor);\r\n    } catch (e) {\r\n      this.throwException(this.TYPE_ERROR, 'Cannot redefine property: ' + name);\r\n    }\r\n  } else {\r\n    // Set the property.\r\n    if (value === ReferenceError) {\r\n      throw ReferenceError('Value not specified.');\r\n    }\r\n    // Determine the parent (possibly self) where the property is defined.\r\n    var defObj = obj;\r\n    while (!(name in defObj.properties)) {\r\n      defObj = this.getPrototype(defObj);\r\n      if (!defObj) {\r\n        // This is a new property.\r\n        defObj = obj;\r\n        break;\r\n      }\r\n    }\r\n    if (defObj.setter && defObj.setter[name]) {\r\n      return defObj.setter[name];\r\n    }\r\n    if (defObj.getter && defObj.getter[name]) {\r\n      if (strict) {\r\n        this.throwException(this.TYPE_ERROR, \"Cannot set property '\" + name +\r\n            \"' of object '\" + obj + \"' which only has a getter\");\r\n      }\r\n    } else {\r\n      // No setter, simple assignment.\r\n      try {\r\n        obj.properties[name] = value;\r\n      } catch (e) {\r\n        if (strict) {\r\n          this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\r\n              \"property '\" + name + \"' of object '\" + obj + \"'\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Convenience method for adding a native function as a non-enumerable property\r\n * onto an object's prototype.\r\n * @param {!Interpreter.MyObject} obj Data object.\r\n * @param {Interpreter.MyValue} name Name of property.\r\n * @param {!Function} wrapper Function object.\r\n */\r\nprivate setNativeFunctionPrototype(obj: Interpreter.MyObject, name: Interpreter.MyValue, wrapper: Function) {\r\n  this.setProperty(obj.properties['prototype'], name,\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n};\r\n\r\n/**\r\n * Returns the current scope from the stateStack.\r\n * @return {!Interpreter.MyObject} Current scope dictionary.\r\n */\r\npublic getScope() {\r\n  var scope = this.stateStack[this.stateStack.length - 1].scope;\r\n  if (!scope) {\r\n    throw Error('No scope found.');\r\n  }\r\n  return scope;\r\n};\r\n\r\n/**\r\n * Create a new scope dictionary.\r\n * @param {!Object} node AST node defining the scope container\r\n *     (e.g. a function).\r\n * @param {Interpreter.MyObject} parentScope Scope to link to.\r\n * @return {!Interpreter.MyObject} New scope.\r\n */\r\npublic createScope(node: ESTree.Node, parentScope: Interpreter.MyObject) {\r\n  var scope = this.createObjectProto(null);\r\n  scope.parentScope = parentScope;\r\n  if (!parentScope) {\r\n    this.initGlobalScope(scope);\r\n  }\r\n  this.populateScope_(node, scope);\r\n\r\n  // Determine if this scope starts with 'use strict'.\r\n  scope.strict = false;\r\n  if (parentScope && parentScope.strict) {\r\n    scope.strict = true;\r\n  } else {\r\n    var firstNode = node['body'] && node['body'][0];\r\n    if (firstNode && firstNode.expression &&\r\n        firstNode.expression['type'] === 'Literal' &&\r\n        firstNode.expression.value === 'use strict') {\r\n      scope.strict = true;\r\n    }\r\n  }\r\n  return scope;\r\n};\r\n\r\n/**\r\n * Create a new special scope dictionary. Similar to createScope(), but\r\n * doesn't assume that the scope is for a function body.\r\n * This is used for 'catch' clauses and 'with' statements.\r\n * @param {!Interpreter.MyObject} parentScope Scope to link to.\r\n * @param {Interpreter.MyObject=} opt_scope Optional object to transform into\r\n *     scope.\r\n * @return {!Interpreter.MyObject} New scope.\r\n */\r\npublic createSpecialScope(parentScope: Interpreter.MyObject, opt_scope?: Interpreter.MyObject) {\r\n  if (!parentScope) {\r\n    throw Error('parentScope required');\r\n  }\r\n  var scope = opt_scope || this.createObjectProto(null);\r\n  scope.parentScope = parentScope;\r\n  scope.strict = parentScope.strict;\r\n  return scope;\r\n};\r\n\r\n/**\r\n * Retrieves a value from the scope chain.\r\n * @param {string} name Name of variable.\r\n * @return {Interpreter.MyValue} Any value.\r\n *   May be flagged as being a getter and thus needing immediate execution\r\n *   (rather than being the value of the property).\r\n */\r\npublic getValueFromScope(name: string): Interpreter.MyValue {\r\n  var scope = this.getScope();\r\n  while (scope && scope !== this.global) {\r\n    if (name in scope.properties) {\r\n      return scope.properties[name];\r\n    }\r\n    scope = scope.parentScope;\r\n  }\r\n  // The root scope is also an object which has inherited properties and\r\n  // could also have getters.\r\n  if (scope === this.global && this.hasProperty(scope, name)) {\r\n    return this.getProperty(scope, name);\r\n  }\r\n  // Typeof operator is unique: it can safely look at non-defined variables.\r\n  var prevNode = this.stateStack[this.stateStack.length - 1].node;\r\n  if (prevNode['type'] === 'UnaryExpression' &&\r\n      prevNode['operator'] === 'typeof') {\r\n    return undefined;\r\n  }\r\n  this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\r\n};\r\n\r\n/**\r\n * Sets a value to the current scope.\r\n * @param {string} name Name of variable.\r\n * @param {Interpreter.MyValue} value Value.\r\n * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n *     needs to be called, otherwise undefined.\r\n */\r\npublic setValueToScope(name: string, value: Interpreter.MyValue) {\r\n  var scope = this.getScope();\r\n  var strict = scope.strict;\r\n  while (scope && scope !== this.global) {\r\n    if (name in scope.properties) {\r\n      scope.properties[name] = value;\r\n      return undefined;\r\n    }\r\n    scope = scope.parentScope;\r\n  }\r\n  // The root scope is also an object which has readonly properties and\r\n  // could also have setters.\r\n  if (scope === this.global && (!strict || this.hasProperty(scope, name))) {\r\n    return this.setProperty(scope, name, value);\r\n  }\r\n  this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\r\n};\r\n\r\n/**\r\n * Create a new scope for the given node.\r\n * @param {!Object} node AST node (program or function).\r\n * @param {!Interpreter.MyObject} scope Scope dictionary to populate.\r\n * @private\r\n */\r\npublic populateScope_(node: ESTree.Node, scope: Interpreter.MyObject) {\r\n  if (node['type'] === 'VariableDeclaration') {\r\n    for (var i = 0; i < node['declarations'].length; i++) {\r\n      this.setProperty(scope, node['declarations'][i]['id']['name'],\r\n          undefined, Interpreter.VARIABLE_DESCRIPTOR);\r\n    }\r\n  } else if (node['type'] === 'FunctionDeclaration') {\r\n    this.setProperty(scope, node['id']['name'],\r\n        this.createFunction(<ESTree.FunctionDeclaration>node, scope), Interpreter.VARIABLE_DESCRIPTOR);\r\n    return;  // Do not recurse into function.\r\n  } else if (node['type'] === 'FunctionExpression') {\r\n    return;  // Do not recurse into function.\r\n  } else if (node['type'] === 'ExpressionStatement') {\r\n    return;  // Expressions can't contain variable/function declarations.\r\n  }\r\n  var nodeClass = node['constructor'];\r\n  for (var name in node) {\r\n    var prop = node[name];\r\n    if (prop && typeof prop === 'object') {\r\n      if (Array.isArray(prop)) {\r\n        for (var i = 0; i < prop.length; i++) {\r\n          if (prop[i] && prop[i].constructor === nodeClass) {\r\n            this.populateScope_(prop[i], scope);\r\n          }\r\n        }\r\n      } else {\r\n        if (prop.constructor === nodeClass) {\r\n          this.populateScope_(prop, scope);\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Remove start and end values from AST, or set start and end values to a\r\n * constant value.  Used to remove highlighting from polyfills and to set\r\n * highlighting in an eval to cover the entire eval expression.\r\n * @param {!Object} node AST node.\r\n * @param {number=} start Starting character of all nodes, or undefined.\r\n * @param {number=} end Ending character of all nodes, or undefined.\r\n * @private\r\n */\r\nprivate stripLocations_(node: ESTree.BaseNode, start: number, end: number) {\r\n  if (start) {\r\n    node['start'] = start;\r\n  } else {\r\n    delete node['start'];\r\n  }\r\n  if (end) {\r\n    node['end'] = end;\r\n  } else {\r\n    delete node['end'];\r\n  }\r\n  for (var name in node) {\r\n    if (node.hasOwnProperty(name)) {\r\n      var prop = node[name];\r\n      if (prop && typeof prop === 'object') {\r\n        this.stripLocations_(prop, start, end);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Is the current state directly being called with as a construction with 'new'.\r\n * @return {boolean} True if 'new foo()', false if 'foo()'.\r\n */\r\npublic calledWithNew(): boolean {\r\n  return this.stateStack[this.stateStack.length - 1].isConstructor;\r\n};\r\n\r\n/**\r\n * Gets a value from the scope chain or from an object property.\r\n * @param {!Array} ref Name of variable or object/propname tuple.\r\n * @return {Interpreter.MyValue} Any value.\r\n *   May be flagged as being a getter and thus needing immediate execution\r\n *   (rather than being the value of the property).\r\n */\r\npublic getValue(ref) {\r\n  if (ref[0] === Interpreter.SCOPE_REFERENCE) {\r\n    // A null/varname variable lookup.\r\n    return this.getValueFromScope(ref[1]);\r\n  } else {\r\n    // An obj/prop components tuple (foo.bar).\r\n    return this.getProperty(ref[0], ref[1]);\r\n  }\r\n};\r\n\r\n/**\r\n * Sets a value to the scope chain or to an object property.\r\n * @param {!Array} ref Name of variable or object/propname tuple.\r\n * @param {Interpreter.MyValue} value Value.\r\n * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n *     needs to be called, otherwise undefined.\r\n */\r\npublic setValue(ref: Array<any> & { 0: Interpreter.MyObject, 1: string }, value: Interpreter.MyValue) {\r\n  if (ref[0] === Interpreter.SCOPE_REFERENCE) {\r\n    // A null/varname variable lookup.\r\n    return this.setValueToScope(ref[1], value);\r\n  } else {\r\n    // An obj/prop components tuple (foo.bar).\r\n    return this.setProperty(ref[0], ref[1], value);\r\n  }\r\n};\r\n\r\n/**\r\n * Throw an exception in the interpreter that can be handled by an\r\n * interpreter try/catch statement.  If unhandled, a real exception will\r\n * be thrown.  Can be called with either an error class and a message, or\r\n * with an actual object to be thrown.\r\n * @param {!Interpreter.MyObject} errorClass Type of error (if message is\r\n *   provided) or the value to throw (if no message).\r\n * @param {string=} opt_message Message being thrown.\r\n */\r\npublic throwException(errorClass: Interpreter.MyObject, opt_message?: string) {\r\n  if (opt_message === undefined) {\r\n    var error = <Interpreter.MyObject>errorClass;  // This is a value to throw, not an error class.\r\n  } else {\r\n    var error = this.createObject(errorClass);\r\n    this.setProperty(error, 'message', opt_message,\r\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n  this.executeException(error);\r\n  // Abort anything related to the current step.\r\n  throw Interpreter.STEP_ERROR;\r\n};\r\n\r\n/**\r\n * Throw an exception in the interpreter that can be handled by a\r\n * interpreter try/catch statement.  If unhandled, a real exception will\r\n * be thrown.\r\n * @param {!Interpreter.MyObject} error Error object to execute.\r\n */\r\npublic executeException(error: Interpreter.MyObject) {\r\n  // Search for a try statement.\r\n  do {\r\n    this.stateStack.pop();\r\n    var state = this.stateStack[this.stateStack.length - 1];\r\n    if (state.node['type'] === 'TryStatement') {\r\n      state.throwValue = error;\r\n      return;\r\n    }\r\n  } while (state && state.node['type'] !== 'Program');\r\n\r\n  // Throw a real error.\r\n  var realError;\r\n  if (this.isa(error, this.ERROR)) {\r\n    var errorTable = {\r\n      'EvalError': EvalError,\r\n      'RangeError': RangeError,\r\n      'ReferenceError': ReferenceError,\r\n      'SyntaxError': SyntaxError,\r\n      'TypeError': TypeError,\r\n      'URIError': URIError\r\n    };\r\n    var name = this.getProperty(error, 'name').toString();\r\n    var message = this.getProperty(error, 'message').valueOf();\r\n    var type = errorTable[name] || Error;\r\n    realError = type(message);\r\n  } else {\r\n    realError = error.toString();\r\n  }\r\n  throw realError;\r\n};\r\n\r\n/**\r\n * Create a call to a getter function.\r\n * @param {!Interpreter.MyObject} func Function to execute.\r\n * @param {!Interpreter.MyObject|!Array} left\r\n *     Name of variable or object/propname tuple.\r\n * @private\r\n */\r\npublic createGetter_(func: Interpreter.MyObject, left: Interpreter.MyObject | Array<Interpreter.MyObject>) {\r\n  // Normally 'this' will be specified as the object component (o.x).\r\n  // Sometimes 'this' is explicitly provided (o).\r\n  var funcThis = Array.isArray(left) ? left[0] : left;\r\n  var node = new this.nodeConstructor();\r\n  node['type'] = 'CallExpression';\r\n  var state = new Interpreter.MyState(node,\r\n      this.stateStack[this.stateStack.length - 1].scope);\r\n  state.doneCallee_ = true;\r\n  state.funcThis_ = funcThis;\r\n  state.func_ = func;\r\n  state.doneArgs_ = true;\r\n  state.arguments_ = [];\r\n  return state;\r\n};\r\n\r\n/**\r\n * Create a call to a setter function.\r\n * @param {!Interpreter.MyObject} func Function to execute.\r\n * @param {!Interpreter.MyObject|!Array} left\r\n *     Name of variable or object/propname tuple.\r\n * @param {Interpreter.MyValue} value Value to set.\r\n * @private\r\n */\r\npublic createSetter_(func: Interpreter.MyObject, left: Interpreter.MyObject | Array<Interpreter.MyObject>, value: Interpreter.MyValue) {\r\n  // Normally 'this' will be specified as the object component (o.x).\r\n  // Sometimes 'this' is implicitly the global object (x).\r\n  var funcThis = Array.isArray(left) ? left[0] : this.global;\r\n  var node = new this.nodeConstructor();\r\n  node['type'] = 'CallExpression';\r\n  var state = new Interpreter.MyState(node,\r\n      this.stateStack[this.stateStack.length - 1].scope);\r\n  state.doneCallee_ = true;\r\n  state.funcThis_ = funcThis;\r\n  state.func_ = func;\r\n  state.doneArgs_ = true;\r\n  state.arguments_ = [value];\r\n  return state;\r\n};\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Functions to handle each node type.\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nprivate stepArrayExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var elements = node['elements'];\r\n  var n = state.n_ || 0;\r\n  if (!state.array_) {\r\n    state.array_ = this.createObjectProto(this.ARRAY_PROTO);\r\n    state.array_.properties.length = elements.length;\r\n  } else {\r\n    this.setProperty(state.array_, n, state.value);\r\n    n++;\r\n  }\r\n  while (n < elements.length) {\r\n    // Skip missing elements - they're not defined, not undefined.\r\n    if (elements[n]) {\r\n      state.n_ = n;\r\n      return new Interpreter.MyState(elements[n], state.scope);\r\n    }\r\n    n++;\r\n  }\r\n  stack.pop();\r\n  stack[stack.length - 1].value = state.array_;\r\n};\r\n\r\nprivate stepAssignmentExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneLeft_) {\r\n    state.doneLeft_ = true;\r\n    var nextState = new Interpreter.MyState(node['left'], state.scope);\r\n    nextState.components = true;\r\n    return nextState;\r\n  }\r\n  if (!state.doneRight_) {\r\n    if (!state.leftReference_) {\r\n      state.leftReference_ = state.value;\r\n    }\r\n    if (state.doneGetter_) {\r\n      state.leftValue_ = state.value;\r\n    }\r\n    if (!state.doneGetter_ && node['operator'] !== '=') {\r\n      var leftValue = this.getValue(state.leftReference_);\r\n      state.leftValue_ = leftValue;\r\n      if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\r\n        // Clear the getter flag and call the getter function.\r\n        leftValue.isGetter = false;\r\n        state.doneGetter_ = true;\r\n        var func = /** @type {!Interpreter.Object} */ (leftValue);\r\n        return this.createGetter_(func, state.leftReference_);\r\n      }\r\n    }\r\n    state.doneRight_ = true;\r\n    return new Interpreter.MyState(node['right'], state.scope);\r\n  }\r\n  if (state.doneSetter_) {\r\n    // Return if setter function.\r\n    // Setter method on property has completed.\r\n    // Ignore its return value, and use the original set value instead.\r\n    stack.pop();\r\n    stack[stack.length - 1].value = state.doneSetter_;\r\n    return;\r\n  }\r\n  var value = state.leftValue_;\r\n  var rightValue = state.value;\r\n  switch (node['operator']) {\r\n    case '=':    value =    rightValue; break;\r\n    case '+=':   value +=   rightValue; break;\r\n    case '-=':   value -=   rightValue; break;\r\n    case '*=':   value *=   rightValue; break;\r\n    case '/=':   value /=   rightValue; break;\r\n    case '%=':   value %=   rightValue; break;\r\n    case '<<=':  value <<=  rightValue; break;\r\n    case '>>=':  value >>=  rightValue; break;\r\n    case '>>>=': value >>>= rightValue; break;\r\n    case '&=':   value &=   rightValue; break;\r\n    case '^=':   value ^=   rightValue; break;\r\n    case '|=':   value |=   rightValue; break;\r\n    default:\r\n      throw SyntaxError('Unknown assignment expression: ' + node['operator']);\r\n  }\r\n  var setter = this.setValue(state.leftReference_, value);\r\n  if (setter) {\r\n    state.doneSetter_ = value;\r\n    return this.createSetter_(setter, state.leftReference_, value);\r\n  }\r\n  // Return if no setter function.\r\n  stack.pop();\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepBinaryExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneLeft_) {\r\n    state.doneLeft_ = true;\r\n    return new Interpreter.MyState(node['left'], state.scope);\r\n  }\r\n  if (!state.doneRight_) {\r\n    state.doneRight_ = true;\r\n    state.leftValue_ = state.value;\r\n    return new Interpreter.MyState(node['right'], state.scope);\r\n  }\r\n  stack.pop();\r\n  var leftValue = state.leftValue_;\r\n  var rightValue = state.value;\r\n  var value;\r\n  switch (node['operator']) {\r\n    case '==':  value = leftValue ==  rightValue; break;\r\n    case '!=':  value = leftValue !=  rightValue; break;\r\n    case '===': value = leftValue === rightValue; break;\r\n    case '!==': value = leftValue !== rightValue; break;\r\n    case '>':   value = leftValue >   rightValue; break;\r\n    case '>=':  value = leftValue >=  rightValue; break;\r\n    case '<':   value = leftValue <   rightValue; break;\r\n    case '<=':  value = leftValue <=  rightValue; break;\r\n    case '+':   value = leftValue +   rightValue; break;\r\n    case '-':   value = leftValue -   rightValue; break;\r\n    case '*':   value = leftValue *   rightValue; break;\r\n    case '/':   value = leftValue /   rightValue; break;\r\n    case '%':   value = leftValue %   rightValue; break;\r\n    case '&':   value = leftValue &   rightValue; break;\r\n    case '|':   value = leftValue |   rightValue; break;\r\n    case '^':   value = leftValue ^   rightValue; break;\r\n    case '<<':  value = leftValue <<  rightValue; break;\r\n    case '>>':  value = leftValue >>  rightValue; break;\r\n    case '>>>': value = leftValue >>> rightValue; break;\r\n    case 'in':\r\n      if (!rightValue || !rightValue.isObject) {\r\n        this.throwException(this.TYPE_ERROR,\r\n            \"'in' expects an object, not '\" + rightValue + \"'\");\r\n      }\r\n      value = this.hasProperty(rightValue, leftValue);\r\n      break;\r\n    case 'instanceof':\r\n      if (!this.isa(rightValue, this.FUNCTION)) {\r\n        this.throwException(this.TYPE_ERROR,\r\n            'Right-hand side of instanceof is not an object');\r\n      }\r\n      value = leftValue.isObject ? this.isa(leftValue, rightValue) : false;\r\n      break;\r\n    default:\r\n      throw SyntaxError('Unknown binary operator: ' + node['operator']);\r\n  }\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepBlockStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var expression = node['body'][n];\r\n  if (expression) {\r\n    state.n_ = n + 1;\r\n    return new Interpreter.MyState(expression, state.scope);\r\n  }\r\n  stack.pop();\r\n};\r\n\r\nprivate stepBreakStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  var label = null;\r\n  if (node['label']) {\r\n    label = node['label']['name'];\r\n  }\r\n  while (state &&\r\n         state.node['type'] !== 'CallExpression' &&\r\n         state.node['type'] !== 'NewExpression') {\r\n    if (label) {\r\n      if (state.labels && state.labels.indexOf(label) !== -1) {\r\n        return;\r\n      }\r\n    } else if (state.isLoop || state.isSwitch) {\r\n      return;\r\n    }\r\n    state = stack.pop();\r\n  }\r\n  // Syntax error, do not allow this error to be trapped.\r\n  throw SyntaxError('Illegal break statement');\r\n};\r\n\r\nprivate stepCallExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneCallee_) {\r\n    state.doneCallee_ = 1;\r\n    // Components needed to determine value of 'this'.\r\n    var nextState = new Interpreter.MyState(node['callee'], state.scope);\r\n    nextState.components = true;\r\n    return nextState;\r\n  }\r\n  if (state.doneCallee_ === 1) {\r\n    // Determine value of the function.\r\n    state.doneCallee_ = 2;\r\n    var func = state.value;\r\n    if (Array.isArray(func)) {\r\n      state.func_ = this.getValue(func);\r\n      if (func[0] !== Interpreter.SCOPE_REFERENCE) {\r\n        // Method function, 'this' is object (ignored if invoked as 'new').\r\n        state.funcThis_ = func[0];\r\n      }\r\n      func = state.func_;\r\n      if (func && typeof func === 'object' && func.isGetter) {\r\n        // Clear the getter flag and call the getter function.\r\n        func.isGetter = false;\r\n        state.doneCallee_ = 1;\r\n        return this.createGetter_(/** @type {!Interpreter.Object} */ (func),\r\n                         state.value);\r\n      }\r\n    } else {\r\n      // Already evaluated function: (function(){...})();\r\n      state.func_ = func;\r\n    }\r\n    state.arguments_ = [];\r\n    state.n_ = 0;\r\n  }\r\n  var func = state.func_;\r\n  if (!state.doneArgs_) {\r\n    if (state.n_ !== 0) {\r\n      state.arguments_.push(state.value);\r\n    }\r\n    if (node['arguments'][state.n_]) {\r\n      return new Interpreter.MyState(node['arguments'][state.n_++], state.scope);\r\n    }\r\n    // Determine value of 'this' in function.\r\n    if (node['type'] === 'NewExpression') {\r\n      if (func.illegalConstructor) {\r\n        // Illegal: new escape();\r\n        this.throwException(this.TYPE_ERROR, func + ' is not a constructor');\r\n      }\r\n      // Constructor, 'this' is new object.\r\n      state.funcThis_ = this.createObject(func);\r\n      state.isConstructor = true;\r\n    } else if (state.funcThis_ === undefined) {\r\n      // Global function, 'this' is global object (or 'undefined' if strict).\r\n      state.funcThis_ = state.scope.strict ? undefined : this.global;\r\n    }\r\n    state.doneArgs_ = true;\r\n  }\r\n  if (!state.doneExec_) {\r\n    state.doneExec_ = true;\r\n    if (!func || !func.isObject) {\r\n      this.throwException(this.TYPE_ERROR, func + ' is not a function');\r\n    }\r\n    var funcNode = func.node;\r\n    if (funcNode) {\r\n      var scope = this.createScope(funcNode['body'], func.parentScope);\r\n      // Add all arguments.\r\n      for (var i = 0; i < funcNode['params'].length; i++) {\r\n        var paramName = funcNode['params'][i]['name'];\r\n        var paramValue = state.arguments_.length > i ? state.arguments_[i] :\r\n            undefined;\r\n        this.setProperty(scope, paramName, paramValue);\r\n      }\r\n      // Build arguments variable.\r\n      var argsList = this.createObjectProto(this.ARRAY_PROTO);\r\n      for (var i = 0; i < state.arguments_.length; i++) {\r\n        this.setProperty(argsList, i, state.arguments_[i]);\r\n      }\r\n      this.setProperty(scope, 'arguments', argsList);\r\n      // Add the function's name (var x = function foo(){};)\r\n      var name = funcNode['id'] && funcNode['id']['name'];\r\n      if (name) {\r\n        this.setProperty(scope, name, func);\r\n      }\r\n      this.setProperty(scope, 'this', state.funcThis_,\r\n                       Interpreter.READONLY_DESCRIPTOR);\r\n      state.value = undefined;  // Default value if no explicit return.\r\n      return new Interpreter.MyState(funcNode['body'], scope);\r\n    } else if (func.eval) {\r\n      var code = state.arguments_[0];\r\n      if (typeof code !== 'string') {\r\n        // JS does not parse String objects:\r\n        // eval(new String('1 + 1')) -> '1 + 1'\r\n        state.value = code;\r\n      } else {\r\n        try {\r\n          var ast = Interpreter.acorn.parse(code.toString(), Interpreter.PARSE_OPTIONS);\r\n        } catch (e) {\r\n          // Acorn threw a SyntaxError.  Rethrow as a trappable error.\r\n          this.throwException(this.SYNTAX_ERROR, 'Invalid code: ' + e.message);\r\n        }\r\n        var evalNode = new this.nodeConstructor();\r\n        evalNode['type'] = 'EvalProgram_';\r\n        evalNode['body'] = ast['body'];\r\n        this.stripLocations_(evalNode, node['start'], node['end']);\r\n        // Update current scope with definitions in eval().\r\n        var scope = <Interpreter.MyObject>state.scope;\r\n        if (scope.strict) {\r\n          // Strict mode get its own scope in eval.\r\n          scope = this.createScope(ast, scope);\r\n        } else {\r\n          // Non-strict mode pollutes the current scope.\r\n          this.populateScope_(ast, scope);\r\n        }\r\n        this.value = undefined;  // Default value if no code.\r\n        return new Interpreter.MyState(evalNode, scope);\r\n      }\r\n    } else if (func.nativeFunc) {\r\n      state.value = func.nativeFunc.apply(state.funcThis_, state.arguments_);\r\n    } else if (func.asyncFunc) {\r\n      var thisInterpreter = this;\r\n      var callback = function(value) {\r\n        state.value = value;\r\n        thisInterpreter.paused_ = false;\r\n      };\r\n      var argsWithCallback = state.arguments_.concat(callback);\r\n      this.paused_ = true;\r\n      func.asyncFunc.apply(state.funcThis_, argsWithCallback);\r\n      return;\r\n    } else {\r\n      /* A child of a function is a function but is not callable.  For example:\r\n      var F = function() {};\r\n      F.prototype = escape;\r\n      var f = new F();\r\n      f();\r\n      */\r\n      this.throwException(this.TYPE_ERROR, func.class + ' is not a function');\r\n    }\r\n  } else {\r\n    // Execution complete.  Put the return value on the stack.\r\n    stack.pop();\r\n    if (state.isConstructor && typeof state.value !== 'object') {\r\n      stack[stack.length - 1].value = state.funcThis_;\r\n    } else {\r\n      stack[stack.length - 1].value = state.value;\r\n    }\r\n  }\r\n};\r\n\r\nprivate stepCatchClause(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.done_) {\r\n    state.done_ = true;\r\n    // Create an empty scope.\r\n    var scope = this.createSpecialScope(state.scope);\r\n    // Add the argument.\r\n    this.setProperty(scope, node['param']['name'], state.throwValue);\r\n    // Execute catch clause.\r\n    return new Interpreter.MyState(node['body'], scope);\r\n  } else {\r\n    stack.pop();\r\n  }\r\n};\r\n\r\nprivate stepConditionalExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var mode = state.mode_ || 0;\r\n  if (mode === 0) {\r\n    state.mode_ = 1;\r\n    return new Interpreter.MyState(node['test'], state.scope);\r\n  }\r\n  if (mode === 1) {\r\n    state.mode_ = 2;\r\n    var value = Boolean(state.value);\r\n    if (value && node['consequent']) {\r\n      // Execute 'if' block.\r\n      return new Interpreter.MyState(node['consequent'], state.scope);\r\n    } else if (!value && node['alternate']) {\r\n      // Execute 'else' block.\r\n      return new Interpreter.MyState(node['alternate'], state.scope);\r\n    }\r\n    // eval('1;if(false){2}') -> undefined\r\n    this.value = undefined;\r\n  }\r\n  stack.pop();\r\n  if (node['type'] === 'ConditionalExpression') {\r\n    stack[stack.length - 1].value = state.value;\r\n  }\r\n};\r\n\r\nprivate stepContinueStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  var label = null;\r\n  if (node['label']) {\r\n    label = node['label']['name'];\r\n  }\r\n  state = stack[stack.length - 1];\r\n  while (state &&\r\n         state.node['type'] !== 'CallExpression' &&\r\n         state.node['type'] !== 'NewExpression') {\r\n    if (state.isLoop) {\r\n      if (!label || (state.labels && state.labels.indexOf(label) !== -1)) {\r\n        return;\r\n      }\r\n    }\r\n    stack.pop();\r\n    state = stack[stack.length - 1];\r\n  }\r\n  // Syntax error, do not allow this error to be trapped.\r\n  throw SyntaxError('Illegal continue statement');\r\n};\r\n\r\nprivate stepDebuggerStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  // Do nothing.  May be overridden by developers.\r\n  stack.pop();\r\n};\r\n\r\nprivate stepDoWhileStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (node['type'] === 'DoWhileStatement' && state.test_ === undefined) {\r\n    // First iteration of do/while executes without checking test.\r\n    state.value = true;\r\n    state.test_ = true;\r\n  }\r\n  if (!state.test_) {\r\n    state.test_ = true;\r\n    return new Interpreter.MyState(node['test'], state.scope);\r\n  }\r\n  if (!state.value) {  // Done, exit loop.\r\n    stack.pop();\r\n  } else if (node['body']) {  // Execute the body.\r\n    state.test_ = false;\r\n    state.isLoop = true;\r\n    return new Interpreter.MyState(node['body'], state.scope);\r\n  }\r\n};\r\n\r\nprivate stepEmptyStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n};\r\n\r\nprivate stepEvalProgram_(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var expression = node['body'][n];\r\n  if (expression) {\r\n    state.n_ = n + 1;\r\n    return new Interpreter.MyState(expression, state.scope);\r\n  }\r\n  stack.pop();\r\n  stack[stack.length - 1].value = this.value;\r\n};\r\n\r\nprivate stepExpressionStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.done_) {\r\n    state.done_ = true;\r\n    return new Interpreter.MyState(node['expression'], state.scope);\r\n  }\r\n  stack.pop();\r\n  // Save this value to interpreter.value for use as a return value if\r\n  // this code is inside an eval function.\r\n  this.value = state.value;\r\n};\r\n\r\nprivate stepForInStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  // First, initialize a variable if exists.  Only do so once, ever.\r\n  if (!state.doneInit_) {\r\n    state.doneInit_ = true;\r\n    if (node['left']['declarations'] &&\r\n        node['left']['declarations'][0]['init']) {\r\n      if (state.scope.strict) {\r\n        this.throwException(this.SYNTAX_ERROR,\r\n            'for-in loop variable declaration may not have an initializer.');\r\n      }\r\n      // Variable initialization: for (var x = 4 in y)\r\n      return new Interpreter.MyState(node['left'], state.scope);\r\n    }\r\n  }\r\n  // Second, look up the object.  Only do so once, ever.\r\n  if (!state.doneObject_) {\r\n    state.doneObject_ = true;\r\n    if (!state.variable_) {\r\n      state.variable_ = state.value;\r\n    }\r\n    return new Interpreter.MyState(node['right'], state.scope);\r\n  }\r\n  if (!state.isLoop) {\r\n    // First iteration.\r\n    state.isLoop = true;\r\n    state.object_ = state.value;\r\n    state.visited_ = Object.create(null);\r\n  }\r\n  // Third, find the property name for this iteration.\r\n  if (state.name_ === undefined) {\r\n    done: do {\r\n      if (state.object_ && state.object_.isObject) {\r\n        if (!state.props_) {\r\n          state.props_ = Object.getOwnPropertyNames(state.object_.properties);\r\n        }\r\n        do {\r\n          var prop = state.props_.shift();\r\n        } while (prop && (state.visited_[prop] ||\r\n            !Object.prototype.hasOwnProperty.call(state.object_.properties,\r\n                                                  prop)));\r\n        if (prop) {\r\n          state.visited_[prop] = true;\r\n          if (Object.prototype.propertyIsEnumerable.call(\r\n              state.object_.properties, prop)) {\r\n            state.name_ = prop;\r\n            break done;\r\n          }\r\n        }\r\n      } else if (state.object_ !== null) {\r\n        if (!state.props_) {\r\n          state.props_ = Object.getOwnPropertyNames(state.object_);\r\n        }\r\n        do {\r\n          var prop = state.props_.shift();\r\n        } while (prop && state.visited_[prop]);\r\n        if (prop) {\r\n          state.visited_[prop] = true;\r\n          state.name_ = prop;\r\n          break done;\r\n        }\r\n      }\r\n      state.object_ = this.getPrototype(state.object_);\r\n      state.props_ = null;\r\n    } while (state.object_ !== null);\r\n    if (state.object_ === null) {\r\n      // Done, exit loop.\r\n      stack.pop();\r\n      return;\r\n    }\r\n  }\r\n  // Fourth, find the variable\r\n  if (!state.doneVariable_) {\r\n    state.doneVariable_ = true;\r\n    var left = node['left'];\r\n    if (left['type'] === 'VariableDeclaration') {\r\n      // Inline variable declaration: for (var x in y)\r\n      state.variable_ =\r\n          [Interpreter.SCOPE_REFERENCE, left['declarations'][0]['id']['name']];\r\n    } else {\r\n      // Arbitrary left side: for (foo().bar in y)\r\n      state.variable_ = null;\r\n      var nextState = new Interpreter.MyState(left, state.scope);\r\n      nextState.components = true;\r\n      return nextState;\r\n    }\r\n  }\r\n  if (!state.variable_) {\r\n    state.variable_ = state.value;\r\n  }\r\n  // Fifth, set the variable.\r\n  if (!state.doneSetter_) {\r\n    state.doneSetter_ = true;\r\n    var value = state.name_;\r\n    var setter = this.setValue(state.variable_, value);\r\n    if (setter) {\r\n      return this.createSetter_(setter, state.variable_, value);\r\n    }\r\n  }\r\n  // Next step will be step three.\r\n  state.name_ = undefined;\r\n  // Reevaluate the variable since it could be a setter on the global object.\r\n  state.doneVariable_ = false;\r\n  state.doneSetter_ = false;\r\n  // Sixth and finally, execute the body if there was one.  this.\r\n  if (node['body']) {\r\n    return new Interpreter.MyState(node['body'], state.scope);\r\n  }\r\n};\r\n\r\nprivate stepForStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var mode = state.mode_ || 0;\r\n  if (mode === 0) {\r\n    state.mode_ = 1;\r\n    if (node['init']) {\r\n      return new Interpreter.MyState(node['init'], state.scope);\r\n    }\r\n  } else if (mode === 1) {\r\n    state.mode_ = 2;\r\n    if (node['test']) {\r\n      return new Interpreter.MyState(node['test'], state.scope);\r\n    }\r\n  } else if (mode === 2) {\r\n    state.mode_ = 3;\r\n    if (node['test'] && !state.value) {\r\n      // Done, exit loop.\r\n      stack.pop();\r\n    } else {  // Execute the body.\r\n      state.isLoop = true;\r\n      return new Interpreter.MyState(node['body'], state.scope);\r\n    }\r\n  } else if (mode === 3) {\r\n    state.mode_ = 1;\r\n    if (node['update']) {\r\n      return new Interpreter.MyState(node['update'], state.scope);\r\n    }\r\n  }\r\n};\r\n\r\nprivate stepFunctionDeclaration(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  // This was found and handled when the scope was populated.\r\n  stack.pop();\r\n};\r\n\r\nprivate stepFunctionExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  stack[stack.length - 1].value = this.createFunction(<ESTree.FunctionDeclaration>node, state.scope);\r\n};\r\n\r\nprivate stepIdentifier(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  if (state.components) {\r\n    stack[stack.length - 1].value = [Interpreter.SCOPE_REFERENCE, node['name']];\r\n    return;\r\n  }\r\n  var value = this.getValueFromScope(node['name']);\r\n  // An identifier could be a getter if it's a property on the global object.\r\n  if (value && typeof value === 'object' && value.isGetter) {\r\n    // Clear the getter flag and call the getter function.\r\n    value.isGetter = false;\r\n    var scope = state.scope;\r\n    while (!this.hasProperty(scope, node['name'])) {\r\n      scope = scope.parentScope;\r\n    }\r\n    var func = /** @type {!Interpreter.Object} */ (value);\r\n    return this.createGetter_(func, this.global);\r\n  }\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepIfStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  return this.stepConditionalExpression(stack, state, node);\r\n}\r\n\r\nprivate stepLabeledStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  // No need to hit this node again on the way back up the stack.\r\n  stack.pop();\r\n  // Note that a statement might have multiple labels.\r\n  var labels = state.labels || [];\r\n  labels.push(node['label']['name']);\r\n  var nextState = new Interpreter.MyState(node['body'], state.scope);\r\n  nextState.labels = labels;\r\n  return nextState;\r\n};\r\n\r\nprivate stepLiteral(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  var value = node['value'];\r\n  if (value instanceof RegExp) {\r\n    var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\r\n    this.populateRegExp(pseudoRegexp, value);\r\n    value = pseudoRegexp;\r\n  }\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepLogicalExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (node['operator'] !== '&&' && node['operator'] !== '||') {\r\n    throw SyntaxError('Unknown logical operator: ' + node['operator']);\r\n  }\r\n  if (!state.doneLeft_) {\r\n    state.doneLeft_ = true;\r\n    return new Interpreter.MyState(node['left'], state.scope);\r\n  }\r\n  if (!state.doneRight_) {\r\n    if ((node['operator'] === '&&' && !state.value) ||\r\n        (node['operator'] === '||' && state.value)) {\r\n      // Shortcut evaluation.\r\n      stack.pop();\r\n      stack[stack.length - 1].value = state.value;\r\n    } else {\r\n      state.doneRight_ = true;\r\n      return new Interpreter.MyState(node['right'], state.scope);\r\n    }\r\n  } else {\r\n    stack.pop();\r\n    stack[stack.length - 1].value = state.value;\r\n  }\r\n};\r\n\r\nprivate stepMemberExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneObject_) {\r\n    state.doneObject_ = true;\r\n    return new Interpreter.MyState(node['object'], state.scope);\r\n  }\r\n  var propName;\r\n  if (!node['computed']) {\r\n    state.object_ = state.value;\r\n    // obj.foo -- Just access 'foo' directly.\r\n    propName = node['property']['name'];\r\n  } else if (!state.doneProperty_) {\r\n    state.object_ = state.value;\r\n    // obj[foo] -- Compute value of 'foo'.\r\n    state.doneProperty_ = true;\r\n    return new Interpreter.MyState(node['property'], state.scope);\r\n  } else {\r\n    propName = state.value;\r\n  }\r\n  stack.pop();\r\n  if (state.components) {\r\n    stack[stack.length - 1].value = [state.object_, propName];\r\n  } else {\r\n    var value = this.getProperty(state.object_, propName);\r\n    if (value && typeof value === 'object' && value.isGetter) {\r\n      // Clear the getter flag and call the getter function.\r\n      value.isGetter = false;\r\n      var func = /** @type {!Interpreter.Object} */ (value);\r\n      return this.createGetter_(func, state.object_);\r\n    }\r\n    stack[stack.length - 1].value = value;\r\n  }\r\n};\r\n\r\nprivate stepNewExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  return this.stepCallExpression(stack, state, node);\r\n}\r\n\r\nprivate stepObjectExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var property = node['properties'][n];\r\n  if (!state.object_) {\r\n    // First execution.\r\n    state.object_ = this.createObjectProto(this.OBJECT_PROTO);\r\n    state.properties_ = Object.create(null);\r\n  } else {\r\n    // Determine property name.\r\n    var key = <string>property['key'];\r\n    if (key['type'] === 'Identifier') {\r\n      var propName = key['name'];\r\n    } else if (key['type'] === 'Literal') {\r\n      var propName = key['value'];\r\n    } else {\r\n      throw SyntaxError('Unknown object structure: ' + key['type']);\r\n    }\r\n    // Set the property computed in the previous execution.\r\n    if (!state.properties_[propName]) {\r\n      // Create temp object to collect value, getter, and/or setter.\r\n      state.properties_[propName] = {};\r\n    }\r\n    state.properties_[propName][property['kind']] = state.value;\r\n    state.n_ = ++n;\r\n    property = node['properties'][n];\r\n  }\r\n  if (property) {\r\n    return new Interpreter.MyState(property['value'], state.scope);\r\n  }\r\n  for (var key in state.properties_) {\r\n    var kinds = state.properties_[key];\r\n    if ('get' in kinds || 'set' in kinds) {\r\n      // Set a property with a getter or setter.\r\n      var descriptor = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: kinds['get'],\r\n        set: kinds['set']\r\n      };\r\n      this.setProperty(state.object_, key, null, descriptor);\r\n    } else {\r\n      // Set a normal property with a value.\r\n      this.setProperty(state.object_, key, kinds['init']);\r\n    }\r\n  }\r\n  stack.pop();\r\n  stack[stack.length - 1].value = state.object_;\r\n};\r\n\r\nprivate stepProgram(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var expression = node['body'][n];\r\n  if (expression) {\r\n    state.done = false;\r\n    state.n_ = n + 1;\r\n    return new Interpreter.MyState(expression, state.scope);\r\n  }\r\n  state.done = true;\r\n  // Don't pop the stateStack.\r\n  // Leave the root scope on the tree in case the program is appended to.\r\n};\r\n\r\nprivate stepReturnStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (node['argument'] && !state.done_) {\r\n    state.done_ = true;\r\n    return new Interpreter.MyState(node['argument'], state.scope);\r\n  }\r\n  var value = state.value;\r\n  var i = stack.length - 1;\r\n  state = stack[i];\r\n  while (state.node['type'] !== 'CallExpression' &&\r\n         state.node['type'] !== 'NewExpression') {\r\n    if (state.node['type'] !== 'TryStatement') {\r\n      stack.splice(i, 1);\r\n    }\r\n    i--;\r\n    if (i < 0) {\r\n      // Syntax error, do not allow this error to be trapped.\r\n      throw SyntaxError('Illegal return statement');\r\n    }\r\n    state = stack[i];\r\n  }\r\n  state.value = value;\r\n};\r\n\r\nprivate stepSequenceExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var expression = node['expressions'][n];\r\n  if (expression) {\r\n    state.n_ = n + 1;\r\n    return new Interpreter.MyState(expression, state.scope);\r\n  }\r\n  stack.pop();\r\n  stack[stack.length - 1].value = state.value;\r\n};\r\n\r\nprivate stepSwitchStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.test_) {\r\n    state.test_ = 1;\r\n    return new Interpreter.MyState(node['discriminant'], state.scope);\r\n  }\r\n  if (state.test_ === 1) {\r\n    state.test_ = 2;\r\n    // Preserve switch value between case tests.\r\n    state.switchValue_ = state.value;\r\n  }\r\n\r\n  while (true) {\r\n    var index = state.index_ || 0;\r\n    var switchCase = node['cases'][index];\r\n    if (!state.matched_ && switchCase && !switchCase['test']) {\r\n      // Test on the default case is null.\r\n      // Bypass (but store) the default case, and get back to it later.\r\n      state.defaultCase_ = index;\r\n      state.index_ = index + 1;\r\n      continue;\r\n    }\r\n    if (!switchCase && !state.matched_ && state.defaultCase_) {\r\n      // Ran through all cases, no match.  Jump to the default.\r\n      state.matched_ = true;\r\n      state.index_ = state.defaultCase_;\r\n      continue;\r\n    }\r\n    if (switchCase) {\r\n      if (!state.matched_ && !state.tested_ && switchCase['test']) {\r\n        state.tested_ = true;\r\n        return new Interpreter.MyState(switchCase['test'], state.scope);\r\n      }\r\n      if (state.matched_ || state.value === state.switchValue_) {\r\n        state.matched_ = true;\r\n        var n = state.n_ || 0;\r\n        if (switchCase['consequent'][n]) {\r\n          state.isSwitch = true;\r\n          state.n_ = n + 1;\r\n          return new Interpreter.MyState(switchCase['consequent'][n],\r\n                                       state.scope);\r\n        }\r\n      }\r\n      // Move on to next case.\r\n      state.tested_ = false;\r\n      state.n_ = 0;\r\n      state.index_ = index + 1;\r\n    } else {\r\n      stack.pop();\r\n      return;\r\n    }\r\n  }\r\n};\r\n\r\nprivate stepThisExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  stack[stack.length - 1].value = this.getValueFromScope('this');\r\n};\r\n\r\nprivate stepThrowStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.done_) {\r\n    state.done_ = true;\r\n    return new Interpreter.MyState(node['argument'], state.scope);\r\n  } else {\r\n    this.throwException(state.value);\r\n  }\r\n};\r\n\r\nprivate stepTryStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneBlock_) {\r\n    state.doneBlock_ = true;\r\n    return new Interpreter.MyState(node['block'], state.scope);\r\n  }\r\n  if (state.throwValue && !state.doneHandler_ && node['handler']) {\r\n    state.doneHandler_ = true;\r\n    var nextState = new Interpreter.MyState(node['handler'], state.scope);\r\n    nextState.throwValue = state.throwValue;\r\n    state.throwValue = null;  // This error has been handled, don't rethrow.\r\n    return nextState;\r\n  }\r\n  if (!state.doneFinalizer_ && node['finalizer']) {\r\n    state.doneFinalizer_ = true;\r\n    return new Interpreter.MyState(node['finalizer'], state.scope);\r\n  }\r\n  if (state.throwValue) {\r\n    // There was no catch handler, or the catch/finally threw an error.\r\n    // Throw the error up to a higher try.\r\n    this.executeException(state.throwValue);\r\n  } else {\r\n    stack.pop();\r\n  }\r\n};\r\n\r\nprivate stepUnaryExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.done_) {\r\n    state.done_ = true;\r\n    var nextState = new Interpreter.MyState(node['argument'], state.scope);\r\n    nextState.components = node['operator'] === 'delete';\r\n    return nextState;\r\n  }\r\n  stack.pop();\r\n  var value = state.value;\r\n  if (node['operator'] === '-') {\r\n    value = -value;\r\n  } else if (node['operator'] === '+') {\r\n    value = +value;\r\n  } else if (node['operator'] === '!') {\r\n    value = !value;\r\n  } else if (node['operator'] === '~') {\r\n    value = ~value;\r\n  } else if (node['operator'] === 'delete') {\r\n    var result = true;\r\n    // If value is not an array, then it is a primitive, or some other value.\r\n    // If so, skip the delete and return true.\r\n    if (Array.isArray(value)) {\r\n      var obj = value[0];\r\n      if (obj === Interpreter.SCOPE_REFERENCE) {\r\n        // 'delete foo;' is the same as 'delete window.foo'.\r\n        obj = state.scope;\r\n      }\r\n      var name = String(value[1]);\r\n      try {\r\n        delete obj.properties[name];\r\n      } catch (e) {\r\n        if (state.scope.strict) {\r\n          this.throwException(this.TYPE_ERROR, \"Cannot delete property '\" +\r\n                              name + \"' of '\" + obj + \"'\");\r\n        } else {\r\n          result = false;\r\n        }\r\n      }\r\n    }\r\n    value = result;\r\n  } else if (node['operator'] === 'typeof') {\r\n    value = (value && value.class === 'Function') ? 'function' : typeof value;\r\n  } else if (node['operator'] === 'void') {\r\n    value = undefined;\r\n  } else {\r\n    throw SyntaxError('Unknown unary operator: ' + node['operator']);\r\n  }\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepUpdateExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneLeft_) {\r\n    state.doneLeft_ = true;\r\n    var nextState = new Interpreter.MyState(node['argument'], state.scope);\r\n    nextState.components = true;\r\n    return nextState;\r\n  }\r\n  if (!state.leftSide_) {\r\n    state.leftSide_ = state.value;\r\n  }\r\n  if (state.doneGetter_) {\r\n    state.leftValue_ = state.value;\r\n  }\r\n  if (!state.doneGetter_) {\r\n    var leftValue = this.getValue(state.leftSide_);\r\n    state.leftValue_ = leftValue;\r\n    if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\r\n      // Clear the getter flag and call the getter function.\r\n      leftValue.isGetter = false;\r\n      state.doneGetter_ = true;\r\n      var func = /** @type {!Interpreter.Object} */ (leftValue);\r\n      return this.createGetter_(func, state.leftSide_);\r\n    }\r\n  }\r\n  if (state.doneSetter_) {\r\n    // Return if setter function.\r\n    // Setter method on property has completed.\r\n    // Ignore its return value, and use the original set value instead.\r\n    stack.pop();\r\n    stack[stack.length - 1].value = state.doneSetter_;\r\n    return;\r\n  }\r\n  leftValue = Number(state.leftValue_);\r\n  var changeValue;\r\n  if (node['operator'] === '++') {\r\n    changeValue = leftValue + 1;\r\n  } else if (node['operator'] === '--') {\r\n    changeValue = leftValue - 1;\r\n  } else {\r\n    throw SyntaxError('Unknown update expression: ' + node['operator']);\r\n  }\r\n  var returnValue = node['prefix'] ? changeValue : leftValue;\r\n  var setter = this.setValue(state.leftSide_, changeValue);\r\n  if (setter) {\r\n    state.doneSetter_ = returnValue;\r\n    return this.createSetter_(setter, state.leftSide_, changeValue);\r\n  }\r\n  // Return if no setter function.\r\n  stack.pop();\r\n  stack[stack.length - 1].value = returnValue;\r\n};\r\n\r\nprivate stepVariableDeclaration(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var declarations = node['declarations'];\r\n  var n = state.n_ || 0;\r\n  var declarationNode = declarations[n];\r\n  if (state.init_ && declarationNode) {\r\n    // This setValue call never needs to deal with calling a setter function.\r\n    // Note that this is setting the init value, not defining the variable.\r\n    // Variable definition is done when scope is populated.\r\n    this.setValueToScope(declarationNode['id']['name'], state.value);\r\n    state.init_ = false;\r\n    declarationNode = declarations[++n];\r\n  }\r\n  while (declarationNode) {\r\n    // Skip any declarations that are not initialized.  They have already\r\n    // been defined as undefined in populateScope_.\r\n    if (declarationNode['init']) {\r\n      state.n_ = n;\r\n      state.init_ = true;\r\n      return new Interpreter.MyState(declarationNode['init'], state.scope);\r\n    }\r\n    declarationNode = declarations[++n];\r\n  }\r\n  stack.pop();\r\n};\r\n\r\nprivate stepWithStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneObject_) {\r\n    state.doneObject_ = true;\r\n    return new Interpreter.MyState(node['object'], state.scope);\r\n  } else if (!state.doneBody_) {\r\n    state.doneBody_ = true;\r\n    var scope = this.createSpecialScope(state.scope, state.value);\r\n    return new Interpreter.MyState(node['body'], scope);\r\n  } else {\r\n    stack.pop();\r\n  }\r\n};\r\n\r\nprivate stepWhileStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  return this.stepDoWhileStatement(stack, state, node);\r\n}\r\n}\r\n\r\nmodule Interpreter {\r\n/**\r\n * Class for an object.\r\n * @param {Interpreter.MyObject} proto Prototype object or null.\r\n * @constructor\r\n */\r\nexport class MyObject {\r\n[key: string]: any;\r\ngetter: any;\r\nsetter: any;\r\nproperties: any;\r\n\r\nconstructor(proto) {\r\n  this.getter = Object.create(null);\r\n  this.setter = Object.create(null);\r\n  this.properties = Object.create(null);\r\n  this.proto = proto;\r\n}\r\n\r\n/** @type {Interpreter.MyObject} */\r\nproto: Interpreter.MyObject = null;\r\n\r\n/** @type {boolean} */\r\nisObject = true;\r\n\r\n/** @type {string} */\r\nclass = 'Object';\r\n\r\n/** @type {Date|RegExp|boolean|number|string|undefined|null} */\r\ndata: Date | RegExp | boolean | number | string | undefined | null = null;\r\n\r\n/**\r\n * Convert this object into a string.\r\n * @return {string} String value.\r\n * @override\r\n */\r\ntoString() {\r\n  if (this.class === 'Array') {\r\n    // Array\r\n    var cycles = Interpreter.toStringCycles_;\r\n    cycles.push(this);\r\n    try {\r\n      var strs = [];\r\n      for (var i = 0; i < this.properties.length; i++) {\r\n        var value = this.properties[i];\r\n        strs[i] = (value && value.isObject && cycles.indexOf(value) !== -1) ?\r\n            '...' : value;\r\n      }\r\n    } finally {\r\n      cycles.pop();\r\n    }\r\n    return strs.join(',');\r\n  }\r\n  if (this.class === 'Error') {\r\n    var cycles = Interpreter.toStringCycles_;\r\n    if (cycles.indexOf(this) !== -1) {\r\n      return '[object Error]';\r\n    }\r\n    var name, message;\r\n    // Bug: Does not support getters and setters for name or message.\r\n    var obj = <Interpreter.MyObject>this;\r\n    do {\r\n      if ('name' in obj.properties) {\r\n        name = obj.properties['name'];\r\n        break;\r\n      }\r\n    } while ((obj = obj.proto));\r\n    var obj = <Interpreter.MyObject>this;\r\n    do {\r\n      if ('message' in obj.properties) {\r\n        message = obj.properties['message'];\r\n        break;\r\n      }\r\n    } while ((obj = obj.proto));\r\n    cycles.push(this);\r\n    try {\r\n      name = name && name.toString();\r\n      message = message && message.toString();\r\n    } finally {\r\n      cycles.pop();\r\n    }\r\n    return message ? name + ': ' + message : String(name);\r\n  }\r\n\r\n  // RegExp, Date, and boxed primitives.\r\n  if (this.data !== null) {\r\n    return String(this.data);\r\n  }\r\n\r\n  return '[object ' + this.class + ']';\r\n}\r\n\r\n/**\r\n * Return the object's value.\r\n * @return {Interpreter.MyValue} Value.\r\n * @override\r\n */\r\nvalueOf() {\r\n  if (this.data === undefined || this.data === null ||\r\n      this.data instanceof RegExp) {\r\n    return this; // An Object.\r\n  }\r\n  if (this.data instanceof Date) {\r\n    return this.data.valueOf();  // Milliseconds.\r\n  }\r\n  return /** @type {(boolean|number|string)} */ (this.data);  // Boxed primitive.\r\n}\r\n}\r\n\r\n/**\r\n * Typedef for JS values.\r\n * @typedef {!Interpreter.MyObject|boolean|number|string|undefined|null}\r\n */\r\nexport type MyValue = MyObject | boolean | number | string | undefined | null;\r\n\r\n/**\r\n * Class for a state.\r\n * @param {!MyObject} node AST node for the state.\r\n * @param {!Interpreter.MyObject} scope Scope object for the state.\r\n * @constructor\r\n */\r\nexport class MyState {\r\n[key: string]: any;\r\nnode: ESTree.BaseNode;\r\nscope: Interpreter.MyObject;\r\nconstructor(node: ESTree.BaseNode, scope: Interpreter.MyObject) {\r\n  this.node = node;\r\n  this.scope = scope;\r\n}\r\n}\r\n\r\nexport interface MyValueTable {\r\n  pseudo: MyValue[],\r\n  native: any[]\r\n}\r\n\r\nexport interface Acorn {\r\n  parse(code: string, options?: any): ESTree.Program;\r\n}\r\n\r\nexport interface NodeConstructor {\r\n  new (): ESTree.BaseNode;\r\n}\r\n\r\nexport interface NativeFunction extends Function {\r\n  id?: number;\r\n}\r\n}\r\n\r\n// These lines are added for API compatibility\r\nInterpreter['Object'] = Interpreter.MyObject;\r\nInterpreter['State'] = Interpreter.MyState;\r\n\r\n// Look for globally-defined acorn\r\ntry {\r\n  Interpreter.acorn = (self || global)['acorn'];\r\n} catch (e) {\r\n  // do nothing if we fail\r\n}\r\n\r\nexport = Interpreter;\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib/interpreter.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}